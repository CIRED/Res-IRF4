                    # calculating market-shares
        if self._debug_mode:
            s = self.add_certificate(stock)
            stock_single = s.xs('Single-family', level='Housing type', drop_level=False)
            flow_retrofit = stock_single * reindex_mi(calib_renovation['renovation_rate_ini'], stock_single.index)
            ms = market_share.groupby([i for i in market_share.index.names if i != 'Heating system final']).first()
            ms = reindex_mi(ms, flow_retrofit.index).dropna()
            flow_retrofit = flow_retrofit.reindex(ms.index)
            agg = (ms.T * flow_retrofit).T
            market_share_agg = (agg.sum() / agg.sum().sum()).reindex(calib_intensive['ms_insulation_ini'].index)
            self.market_share = market_share_agg



            # graphics showing the distribution of retrofit rate after calibration
            if self._debug_mode:
                r = retrofit_rate.xs(False, level='Heater replacement').rename('')

                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))
                r.plot.box(ax=ax)
                format_ax(ax, format_y=lambda y, _: '{:.0%}'.format(y))
                ax.set_xlabel('')
                ax.set_ylabel('Retrofit rate (%)')
                save_fig(fig, save=os.path.join(self.path_calibration_renovation, 'retrofit_rate_distribution.png'))

                certificate = self.certificate.groupby([l for l in self.stock.index.names if l != 'Income tenant']).first()
                certificate = reindex_mi(certificate, r.index)
                r.to_frame().groupby(certificate).boxplot(fontsize=12, figsize=(8, 10))
                plt.savefig(os.path.join(self.path_calibration_renovation, 'retrofit_rate_distribution_dpe.png'))
                plt.close()

                r = retrofit_rate.rename('')
                certificate = self.certificate.groupby([l for l in self.stock.index.names if l != 'Income tenant']).first()
                certificate = reindex_mi(certificate, r.index)
                temp = concat((r, certificate.rename('Performance')), axis=1).set_index('Performance', append=True)
                temp.groupby(renovation_rate_ini.index.names).describe().to_csv(
                    os.path.join(self.path_calibration_renovation, 'retrofit_rate_desription.csv'))

                consumption_sd = self.consumption_standard(r.index)[2]
                consumption_sd = reindex_mi(consumption_sd, index)

                consumption_sd = reindex_mi(consumption_sd, r.index)
                df = concat((consumption_sd, r), axis=1, keys=['Consumption', 'Retrofit rate'])

                make_plot(df.set_index('Consumption').squeeze().sort_index(), 'Retrofit rate (%)',
                          format_y=lambda x, _: '{:.0%}'.format(x),
                          save=os.path.join(self.path_calibration_renovation, 'retrofit_rate_consumption_calib.png'),
                          legend=False, integer=False)

                df.reset_index('Income owner', inplace=True)
                df['Income owner'] = df['Income owner'].replace(resources_data['colors'])
                for i in renovation_rate_ini.index:
                    if not i[2]:
                        d = df.xs(i[0], level='Housing type').xs(i[1], level='Occupancy status')
                        name = '{}_{}_{}'.format(i[0].lower(), i[1].lower(), str(i[2]).lower())
                        fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))
                        d.plot.scatter(ax=ax, x='Consumption', y='Retrofit rate', c=d['Income owner'])
                        format_ax(ax, format_y=lambda y, _: '{:.0%}'.format(y), y_label=name)
                        save_fig(fig, save=os.path.join(self.path_calibration_renovation, 'retrofit_rate_{}_calib.png'.format(name)))



            percentage_intensive_margin = None
            if False:
                percentage_intensive_margin = calculation_intensive_margin(stock, renovation_rate_ini, bill_saved,
                                                                           subsidies_total, cost_insulation, delta_subsidies)

            if self._debug_mode:
                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))
                utility_intensive.boxplot(ax=ax, fontsize=12, figsize=(8, 10))
                plt.xticks(fontsize=7, rotation=45)
                fig.savefig(os.path.join(self.path_calibration_renovation, 'utility_insulation_distribution.png'))
                plt.close(fig)

                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))
                market_share.boxplot(ax=ax, fontsize=12, figsize=(8, 10))
                plt.xticks(fontsize=7, rotation=45)
                fig.savefig(os.path.join(self.path_calibration_renovation, 'market_share_distribution.png'))
                plt.close(fig)



            if percentage_intensive_margin is not None:
                percentage_intensive_margin = Series(percentage_intensive_margin, index=['Percentage intensive margin'])
                result = concat((result, percentage_intensive_margin), axis=0)






            # graphic showing the impact of the scale in a general case
            if self._debug_mode:
                x, free_riders, elasticity = [], [], []
                for scale in arange(0.1, 5, 0.1):
                    x.append(scale)
                    free_riders.append(to_freeriders(scale, utility, stock, - delta_subsidies_sum / 1000, pref_subsidies,
                                                        ))

                graphs = {'Freeriders cite': free_riders}
                for name, data in graphs.items():
                    df = Series(data, index=Index(x, name='Scale'), name=name)
                    fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))
                    df.plot(ax=ax)
                    format_ax(ax, format_y=lambda y, _: '{:.0%}'.format(y), y_label=name)
                    save_fig(fig, save=os.path.join(self.path_calibration, 'scale_calibration_{}.png'.format(name.lower())))








            # graphic showing the impact of the scale
            if self._debug_mode:
                stock_single = stock.xs('Single-family', level='Housing type', drop_level=False)
                stock_multi = stock.xs('Multi-family', level='Housing type', drop_level=False)
                x_before, y_before, y_before_single, y_before_multi = [], [], [], []
                for delta in arange(0, 2, 0.1):
                    sub = subsidies_insulation * (1 + delta)
                    x_before.append((sub * stock).sum() / stock.sum())
                    rate = to_retrofit_rate(bill_saved_insulation, sub, investment_insulation)[0]
                    y_before.append((rate * stock).sum() / stock.sum())
                    y_before_single.append((rate * stock_single).sum() / stock_single.sum())
                    y_before_multi.append((rate * stock_multi).sum() / stock_multi.sum())




            # graphic showing the impact of the scale
            if self._debug_mode:
                x_after, y_after, y_after_single, y_after_multi = [], [], [], []
                for delta in arange(0, 2, 0.1):
                    sub = subsidies_insulation * (1 + delta)
                    x_after.append((sub * stock).sum() / stock.sum())
                    rate = to_retrofit_rate(bill_saved_insulation, sub, investment_insulation)[0]
                    y_after.append((rate * stock).sum() / stock.sum())
                    y_after_single.append((rate * stock_single).sum() / stock_single.sum())
                    y_after_multi.append((rate * stock_multi).sum() / stock_multi.sum())
                df = concat(
                    (Series(x_before), Series(y_before), Series(y_after), Series(y_before_single),
                     Series(y_after_single), Series(y_before_multi),
                     Series(y_after_multi)), axis=1)
                df.columns = ['Subsidies (€)', 'Before', 'After', 'Before single', 'After single', 'Before multi',
                              'After multi']
                color = {'Before': 'black', 'After': 'black',
                         'Before single': 'darkorange', 'After single': 'darkorange',
                         'Before multi': 'royalblue', 'After multi': 'royalblue'
                         }
                style = ['--', '-'] * 10
                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))
                df.plot(ax=ax, x='Subsidies (€)', color=color, style=style)
                format_ax(ax, format_y=lambda y, _: '{:.0%}'.format(y), y_label='Retrofit rate')
                format_legend(ax)
                save_fig(fig, save=os.path.join(self.path_calibration, 'scale_effect.png'))




        else:
            o = dict()
            temp = buildings.heat_consumption_energy / 10 ** 9
            temp.index = temp.index.map(lambda x: 'Consumption {} (TWh)'.format(x))
            o.update(temp.to_dict())

            o['Investment heater (Billion euro)'] = buildings.investment_heater.sum().sum() / 10**9
            o['Investment insulation (Billion euro)'] = buildings.investment_insulation.sum().sum() / 10**9
            o['Investment (Billion euro)'] = o['Investment heater (Billion euro)'] + o['Investment insulation (Billion euro)']
            o['Subsidies heater (Billion euro)'] = buildings.subsidies_heater.sum().sum() / 10**9
            o['Subsidies insulation (Billion euro)'] = buildings.subsidies_insulation.sum().sum() / 10**9
            o['Subsidies (Billion euro)'] = o['Subsidies heater (Billion euro)'] + o['Subsidies insulation (Billion euro)']

            o['Health cost (Billion euro)'], _ = buildings.health_cost(post_inputs)

            o['Energy poverty (Thousand)'] = buildings.energy_poverty / 10**3
            o['Heating intensity (%)'] = (buildings.stock * buildings.heating_intensity).sum() / buildings.stock.sum()

            temp = buildings.replacement_heater.sum() / 10 ** 3
            temp.index = temp.index.map(lambda x: 'Replacement {} (Thousand)'.format(x))
            o.update(temp.to_dict())

            temp = buildings.stock.groupby('Heating system').sum() / 10 ** 3
            temp.index = temp.index.map(lambda x: 'Stock {} (Thousand)'.format(x))
            o.update(temp.to_dict())

            output.update({y: o})





from pandas import concat
import pandas as pd

def remove_market_failures(self):
    """NotImplemented

    Returns
    -------

    """
    if self.constant_insulation_extensive is not None:

        if self._remove_market_failures['landlord']:
            c = self.constant_insulation_extensive.copy()
            c = c.reset_index('Occupancy status')
            c = c[c['Occupancy status'] == 'Owner-occupied'].drop('Occupancy status', axis=1).squeeze()
            c = concat((c, c, c), axis=0, keys=['Owner-occupied', 'Privately rented', 'Social housing'], names=['Occupancy status'])
            c = c.reorder_levels(self.constant_insulation_extensive.index.names)
            self.constant_insulation_extensive = c

        if self._remove_market_failures['multi-family']:
            c = self.constant_insulation_extensive.copy()
            c = c.reset_index('Housing type')
            c = c[c['Housing type'] == 'Single-family'].drop('Housing type', axis=1).squeeze()
            c = concat((c, c, c), axis=0, keys=['Single-family', 'Multi-family'], names=['Housing type'])
            c = c.reorder_levels(self.constant_insulation_extensive.index.names)
            self.constant_insulation_extensive = c

        if self._remove_market_failures['credit constraint']:
            self.pref_bill_insulation_int = pd.Series(self.pref_bill_insulation_int.loc['D10'], index=self.pref_bill_insulation_int.index)
            self.pref_bill_insulation_ext = pd.Series(self.pref_bill_insulation_ext.loc['D10'], index=self.pref_bill_insulation_ext.index)


def supply_interaction(self, retrofit_rate, stock, investment_insulation):
            """NOT IMPLEMENTED YET.

            Parameters
            ----------
            retrofit_rate
            stock
            investment_insulation

            Returns
            -------

            """
            market_size = (retrofit_rate * stock * investment_insulation).sum()
            etp_size = self.factor_etp * market_size

            if self.param_supply is None:

                self.capacity_utilization = etp_size / 0.8
                self.param_supply = dict()
                self.param_supply['a'], self.param_supply['b'], self.param_supply['c'] = self.calibration_supply()

                x = arange(0, 1.05, 0.05)
                y = self.factor_function(self.param_supply['a'], self.param_supply['b'], self.param_supply['c'], x)
                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))
                ax.plot(x, y, color='black')
                format_ax(ax, y_label='Cost factor')
                ax.set_xlabel('Utilization rate (%)')
                save_fig(fig, save=os.path.join(self.path_calibration, 'marginal_cost_curve.png'))

                x, y_supply, y_demand = [], [], []
                for factor in arange(0.81, 1.5, 0.05):
                    retrofit_rate = to_retrofit_rate(bill_saved_insulation, subsidies_insulation,
                                                     investment_insulation * factor)[0]
                    y_demand.append((retrofit_rate * stock * investment_insulation * self.factor_etp).sum())
                    utilization_rate = self.supply_function(self.param_supply['a'], self.param_supply['b'],
                                                            self.param_supply['c'], factor)
                    y_supply.append(utilization_rate * self.capacity_utilization)
                    x.append(factor)

                df = concat((Series(x), Series(y_supply)/10**3, Series(y_demand)/10**3,),
                               axis=1).set_axis(['Cost factor', 'Supply', 'Demand'], axis=1)

                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))
                df.plot(ax=ax, x='Cost factor', color={'Supply': 'darkorange', 'Demand': 'royalblue'})
                format_ax(ax, y_label='Quantity (thousands of jobs)', format_y=lambda y, _: '{:.0f}'.format(y))
                format_legend(ax)
                save_fig(fig, save=os.path.join(self.path_calibration, 'supply_demand_inverse.png'))

                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))
                df.plot(ax=ax, x='Supply', y='Cost factor', color='darkorange')
                df.plot(ax=ax, x='Demand', y='Cost factor', color='royalblue')
                format_ax(ax, y_label='Cost factor', format_y=lambda y, _: '{:.1f}'.format(y))
                ax.set_xlabel('Quantity (thousands of jobs)')
                format_legend(ax, labels=['Supply', 'Demand'])
                save_fig(fig, save=os.path.join(self.path_calibration, 'supply_demand.png'))

            def solve_equilibrium(factor, bill_saved_insulation, subsidies_insulation, investment_insulation, stock):
                retrofit_rate = to_retrofit_rate(bill_saved_insulation, subsidies_insulation,
                                                 investment_insulation * factor)[0]
                demand = (retrofit_rate * stock * investment_insulation * self.factor_etp).sum()
                offer = self.supply_function(self.param_supply['a'], self.param_supply['b'],
                                             self.param_supply['c'], factor) * self.capacity_utilization
                return demand - offer

            factor_equilibrium = fsolve(solve_equilibrium, array([1]), args=(
            bill_saved_insulation, subsidies_insulation, investment_insulation, stock))

            retrofit_rate = to_retrofit_rate(bill_saved_insulation, subsidies_insulation,
                                             investment_insulation * factor_equilibrium)[0]

            self.factor = factor_equilibrium
            if self._debug_mode:
                self.factor_yrs.update({self.year: factor_equilibrium})
            return retrofit_rate


def calibration_intensive(utility, stock, ms_insulation, retrofit_rate_ini, solver='iteration'):
    if solver == 'iteration':
        return calibration_intensive_iteration(utility, stock, ms_insulation, retrofit_rate_ini)
    elif solver == 'fsolve':
        return calibration_intensive_fsolve(utility, stock, ms_insulation, retrofit_rate_ini)


x0 = ones(1)

"""scale = fsolve(solve, x0, args=(
    flow_retrofit, bill_saved, subsidies_total, cost_insulation, -delta_subsidies,
    target_invest, utility_zil))"""

def calibration_intensive_fsolve(utility, stock, ms_insulation, retrofit_rate_ini):
    def solve(constant, utility_ref, ms_insulation, flow_retrofit):
        # constant = append(0, constant)
        constant = Series(constant, index=utility_ref.columns)
        constant.iloc[0] = 0
        utility = utility_ref + constant
        market_share = (exp(utility).T / exp(utility).sum(axis=1)).T
        agg = (market_share.T * flow_retrofit).T
        market_share_agg = (agg.sum() / agg.sum().sum()).reindex(ms_insulation.index)

        if (market_share_agg.round(decimals=2) == ms_insulation.round(decimals=2)).all():
            return zeros(ms_insulation.shape[0])
        else:
            return market_share_agg - ms_insulation

    if 'Performance' in retrofit_rate_ini.index.names:
        levels = [l for l in retrofit_rate_ini.index.names if l != 'Performance']
        certificate = self.certificate.rename('Performance').groupby(
            [l for l in self.stock.index.names if l != 'Income tenant']).first()
        certificate = reindex_mi(certificate, stock.index)
        stock = concat((stock, certificate), axis=1).set_index('Performance', append=True).squeeze()
        retrofit_rate_simple = (stock * reindex_mi(retrofit_rate_ini, stock.index)).groupby(
            levels).sum() / stock.groupby(levels).sum()
    else:
        retrofit_rate_simple = retrofit_rate_ini

    probability_replacement = self._probability_replacement
    if isinstance(probability_replacement, Series):
        probability_replacement.index = probability_replacement.index.rename('Heating system')
        probability_replacement = reindex_mi(probability_replacement, self._stock.index)

    stock = concat((self.stock * probability_replacement,
                       self.stock * (1 - probability_replacement)), axis=0, keys=[True, False],
                      names=['Heater replacement'])
    stock_single = stock.xs('Single-family', level='Housing type', drop_level=False)

    flow_retrofit = stock_single * reindex_mi(retrofit_rate_simple, stock_single.index)

    utility = utility.groupby([i for i in utility.index.names if i != 'Heating system final']).mean()
    utility_ref = reindex_mi(utility, flow_retrofit.index).dropna()
    flow_retrofit = flow_retrofit.reindex(utility_ref.index)

    x0 = zeros(ms_insulation.shape[0])
    constant = fsolve(solve, x0, args=(utility_ref, ms_insulation, flow_retrofit))
    constant = Series(constant, index=utility_ref.columns)

    utility = utility_ref + constant
    market_share = (exp(utility).T / exp(utility).sum(axis=1)).T
    agg = (market_share.T * flow_retrofit).T
    market_share_agg = (agg.sum() / agg.sum().sum()).reindex(ms_insulation.index)
    details = concat((constant, market_share_agg, ms_insulation), axis=1,
                        keys=['constant', 'calcul', 'observed']).round(decimals=3)
    if self.path is not None:
        details.to_csv(os.path.join(self.path_calibration, 'calibration_constant_insulation.csv'))
    return constant


"""scale_intensive = calibration_intensive_margin(stock, retrofit_rate_ini, bill_saved, subsidies_total,
                                               cost_insulation, delta_subsidies,
                                               target_invest=0.2, utility_zil=utility_zil)

self.constant_insulation_intensive *= scale_intensive
self.pref_subsidy_insulation_int *= scale_intensive
self.pref_investment_insulation_int *= scale_intensive
self.pref_bill_insulation_int *= scale_intensive

ms_after, _ = to_market_share(bill_saved, subsidies_total, cost_insulation,
                                  utility_zil=utility_zil)

s = self.add_certificate(stock)
stock_single = s.xs('Single-family', level='Housing type', drop_level=False)
flow_retrofit = stock_single * reindex_mi(retrofit_rate_ini, stock_single.index)
ms = ms_after.groupby([i for i in ms_after.index.names if i != 'Heating system final']).first()
ms = reindex_mi(ms, flow_retrofit.index).dropna()
flow_retrofit = flow_retrofit.reindex(ms.index)
agg = (ms.T * flow_retrofit).T
market_share_agg_after = (agg.sum() / agg.sum().sum()).reindex(ms_insulation.index)

test = calibration_intensive_margin(stock, retrofit_rate_ini, bill_saved, subsidies_total,
                                               cost_insulation, delta_subsidies,
                                               target_invest=0.2, utility_zil=utility_zil)
"""

# idx = (False, True, 'Owner-occupied', 'D1', 'Multi-family', 'Electricity-Performance boiler', 0.5,  0.2, 0.1, 1.6, 'Electricity-Performance boiler')


# removing floor and roof insulation for multi-family
if False:
    cond1 = utility_intensive.index.get_level_values('Housing type') == 'Multi-family'
    cond2 = (utility_intensive.columns.get_level_values('Floor') == True) | (
                utility_intensive.columns.get_level_values('Roof') == True)
    utility_intensive.loc[cond1, cond2] = float('nan')


def calibration_intensive_iteration(util, stock_segment, ms_ini, retrofit_rate_ini, iteration=100,
                                    all=True):
    else:
        # single-family
        stock_single = stock_segment.xs('Single-family', level='Housing type', drop_level=False)
        flow_retrofit = stock_single * reindex_mi(retrofit_rate_ini, stock_single.index)

        utility_ref = reindex_mi(util, flow_retrofit.index).dropna()

        constant = ms_ini.reindex(utility_ref.columns, axis=0).copy()
        constant[constant > 0] = 0
        market_share_ini, market_share_agg = None, None
        for i in range(iteration):
            _utility = (utility_ref + constant).copy()
            constant.iloc[0] = 0
            ms_ini = (exp(_utility).T / exp(_utility).sum(axis=1)).T
            agg = (ms_ini.T * flow_retrofit).T
            market_share_agg = (agg.sum() / agg.sum().sum()).reindex(ms_ini.index)
            if i == 0:
                market_share_ini = market_share_agg.copy()
            constant = constant + log(ms_ini / market_share_agg)

            if (market_share_agg.round(decimals=2) == ms_ini.round(decimals=2)).all():
                self.logger.debug('Constant intensive optim worked')
                break

        constant.iloc[0] = 0
        details = concat((constant, market_share_ini, market_share_agg, ms_ini), axis=1,
                         keys=['constant', 'calcul ini', 'calcul', 'observed']).round(decimals=3)
        if self.path is not None:
            details.to_csv(os.path.join(self.path_calibration, 'calibration_constant_insulation_single.csv'))
        constant_insulation = constant.rename('Single-family')

        # multi-family
        ms_ini = ms_ini.xs(False, level='Floor', drop_level=False).xs(False, level='Roof', drop_level=False)
        ms_ini = ms_ini / ms_ini.sum()

        stock_multi = stock_segment.xs('Multi-family', level='Housing type', drop_level=False)
        flow_retrofit = stock_multi * reindex_mi(retrofit_rate_ini, stock_multi.index)

        utility_ref = reindex_mi(util, flow_retrofit.index).dropna(how='all', axis=0).dropna(how='all', axis=1)

        constant = ms_ini.reindex(utility_ref.columns, axis=0).copy()
        constant[constant > 0] = 0
        market_share_ini, market_share_agg = None, None
        for i in range(iteration):
            _utility = (utility_ref + constant).copy()
            constant.iloc[0] = 0
            ms_ini = (exp(_utility).T / exp(_utility).sum(axis=1)).T
            agg = (ms_ini.T * flow_retrofit).T
            market_share_agg = (agg.sum() / agg.sum().sum()).reindex(ms_ini.index)
            if i == 0:
                market_share_ini = market_share_agg.copy()
            constant = constant + log(ms_ini / market_share_agg)

            if (market_share_agg.round(decimals=2) == ms_ini.round(decimals=2)).all():
                self.logger.debug('Constant intensive optim worked')
                break

        constant.iloc[0] = 0
        details = concat((constant, market_share_ini, market_share_agg, ms_ini), axis=1,
                         keys=['constant', 'calcul ini', 'calcul', 'observed']).round(decimals=3)
        if self.path is not None:
            details.to_csv(os.path.join(self.path_calibration, 'calibration_constant_insulation_multi.csv'))
        constant = constant.rename('Multi-family')

        constant = concat((constant_insulation, constant), axis=1).T
        constant.index.names = ['Housing type']
        return constant


if debug_mode and self.constant_insulation_extensive is not None:
    levels = [l for l in self.constant_insulation_extensive.index.names if l != 'Performance']
    df = concat((utility_investment.groupby(levels).mean(),
                 utility_subsidies.groupby(levels).mean(),
                 utility_bill_saving.groupby(levels).mean(),
                 self.constant_insulation_extensive.groupby(levels).mean()), axis=1,
                keys=['Investment', 'Subsidies', 'Saving', 'Constant'])

    if zil is not None:
        zil_mean = utility_zil.groupby(levels).mean().rename('ZIL')
        df = concat((df, zil_mean), axis=1)

"""output['Non-weighted retrofit rate (%)'] = t.mean()
t = t.groupby(['Housing type', 'Occupancy status']).mean()
t.index = t.index.map(lambda x: 'Non-weighted retrofit rate {} - {} (%)'.format(x[0], x[1]))
output.update(t.T)

output['Non-weighted retrofit rate w/ heater (%)'] = t.mean()
t = t.groupby(['Housing type', 'Occupancy status']).mean()
t.index = t.index.map(lambda x: 'Non-weighted retrofit rate heater {} - {} (%)'.format(x[0], x[1]))
output.update(t.T)
"""

        self.factor_etp = 7.44 / 10**6 # ETP/€



            # racalculation of renovation rate with new market_share
            investment_insulation, bill_saved_insulation, subsidies_insulation = to_utility_extensive(cost_total,
                                                                                                      bill_saved,
                                                                                                      subsidies_total,
                                                                                                      market_share,
                                                                                                      utility_intensive)

            renovation_rate, _ = to_retrofit_rate(bill_saved_insulation, subsidies_insulation, investment_insulation)

            # test renovation rate
            flow = renovation_rate * stock
            rate = flow.groupby(renovation_rate_ini.index.names).sum() / stock.groupby(renovation_rate_ini.index.names).sum()
            compare_rate = concat((rate.rename('Calculated'), renovation_rate_ini.rename('Observed')), axis=1).round(3)

            self.constant_insulation_extensive = None
            _, utility = to_retrofit_rate(bill_saved_insulation, subsidies_insulation, investment_insulation)

            constant, scale = calibration_extensive(utility, stock, calib_renovation)
            self.constant_insulation_extensive = constant
            self.apply_scale(scale)
            renovation_rate, _ = to_retrofit_rate(bill_saved_insulation, subsidies_insulation, investment_insulation)

            # recalibration of market_share with new scale and renovation rate
            self.constant_insulation_intensive = None
            _, utility_intensive = to_market_share(bill_saved, subsidies_total, cost_total)
            self.constant_insulation_intensive = calibration_intensive(utility_intensive, stock, ms_insulation_ini,
                                                                       renovation_rate)
            # test market-share
            market_share, utility_intensive = to_market_share(bill_saved, subsidies_total, cost_total)

            # racalculation of renovation rate with new market_share
            investment_insulation, bill_saved_insulation, subsidies_insulation = to_utility_extensive(cost_total,
                                                                                                      bill_saved,
                                                                                                      subsidies_total,
                                                                                                      market_share,
                                                                                                      utility_intensive)

            renovation_rate, _ = to_retrofit_rate(bill_saved_insulation, subsidies_insulation, investment_insulation)

            # test renovation rate
            flow = renovation_rate * stock
            rate = flow.groupby(renovation_rate_ini.index.names).sum() / stock.groupby(
                renovation_rate_ini.index.names).sum()
            compare_rate = concat((rate.rename('Calculated'), renovation_rate_ini.rename('Observed')), axis=1).round(3)



            flow = renovation_rate * stock
            rate = flow.groupby(renovation_rate_ini.index.names).sum() / stock.groupby(renovation_rate_ini.index.names).sum()
            compare_rate = concat((rate.rename('Calculated'), renovation_rate_ini.rename('Observed')), axis=1).round(3)
            flow_insulation = (flow * market_share.T).T.sum()
            share = flow_insulation / flow_insulation.sum()
            compare_share = concat((share.rename('Calculated'), ms_insulation_ini.rename('Observed')), axis=1).round(3)

            print('break')


            ######################


            if calib_renovation['scale']['name'] == 'freeriders':
                delta_subsidies = calib_renovation['scale']['delta_subsidies']
                if self._insulation_representative == 'market_share':
                    delta_subsidies_sum = (delta_subsidies.reindex(market_share.index) * market_share).sum(axis=1)
                elif self._insulation_representative == 'max':
                    delta_subsidies_sum = self.find_best_option(utility_intensive, {'delta_subsidies': delta_subsidies}, func='max')['delta_subsidies']
                    delta_subsidies_sum = delta_subsidies_sum.loc[bill_saved_insulation.index].rename(None)
                calib_renovation['scale']['delta_subsidies_sum'] = delta_subsidies_sum

                pref_subsidies = reindex_mi(self.preferences_insulation_ext['subsidy'], subsidies_insulation.index).rename(None)
                calib_renovation['scale']['pref_subsidies'] = pref_subsidies

            constant, scale = calibration_extensive(utility, stock, calib_renovation)
            self.constant_insulation_extensive = constant
            self.apply_scale(scale)

            retrofit_rate, _ = to_retrofit_rate(bill_saved_insulation, subsidies_insulation, investment_insulation)

            self.constant_insulation_intensive = None

            _, utility_intensive = to_market_share(bill_saved, subsidies_total, cost_total)

            self.logger.info('Calibration intensive')
            # calibration do not converge withe renovation rate ini
            self.constant_insulation_intensive = calibration_intensive(utility_intensive, stock,
                                                                                              calib_intensive[
                                                                                                  'ms_insulation_ini'],
                                                                                              retrofit_rate)

            market_share, retrofit_rate = apply_endogenous_retrofit(bill_saved, subsidies_total, cost_total)

            # file concatenating all calibration results
            renovation_rate_ini = calib_renovation['renovation_rate_ini']
            ms_insulation_ini = calib_intensive['ms_insulation_ini']
            flow = retrofit_rate * stock
            rate = flow.groupby(renovation_rate_ini.index.names).sum() / stock.groupby(renovation_rate_ini.index.names).sum()
            compare_rate = concat((rate.rename('Calculated'), renovation_rate_ini.rename('Observed')), axis=1).round(3)
            flow_insulation = (flow * market_share.T).T.sum()
            share = flow_insulation / flow_insulation.sum()
            compare_share = concat((share.rename('Calculated'), ms_insulation_ini.rename('Observed')), axis=1).round(3)


            def calibration_simultaneous(_stock, _bill_saved, _subsidies_total, _cost_total, _calib_renovation,
                                         _calib_intensive):

                def solve(_unknown, _u_intensive, _stock, _ms_target, _rate_target, _std_deviation):

                    cst_intensive = _unknown[:len(_ms_target)]
                    cst_extensive = _unknown[len(_ms_target):-1]
                    _scale = _unknown[-1]

                    f_retrofit = _stock * reindex_mi(_renovation_rate, _stock.index)
                    _u_intensive = reindex_mi(_u_intensive, f_retrofit.index).dropna(how='all')

                    constant_intensive = Series(cst_intensive, _ms_target.index)
                    _u_int = _utility_intensive + constant_intensive
                    _market_share = market_share_func(_u_intensive * _scale)

                    _f_replace = (_market_share.T * f_retrofit).T
                    _ms_agg = (_f_replace.sum() / _f_replace.sum().sum()).reindex(_ms_target.index)

                    rslt = _ms_agg = _ms_target

                    """if (_ms_agg.round(decimals=2) == _ms_ini.round(decimals=2)).all():
                        _ms_agg = _ms_ini"""

                    # calibration constant
                    _i_insulation, _b_insulation, _s_insulation = to_utility_extensive(
                        cost_total,
                        bill_saved,
                        subsidies_total,
                        market_share,
                        utility_intensive)

                    _, _u_extensive = to_retrofit_rate(_b_insulation, _s_insulation, _i_insulation)

                    constant_extensive = Series(cst_extensive, _rate_target.index)
                    constant_extensive = reindex_mi(constant_extensive, _u_extensive.index)
                    _u_ext = _u_extensive + constant_extensive
                    retrofit_rate_calc = retrofit_func(_u_ext * _scale)

                    agg = (retrofit_rate_calc * _stock).groupby(_rate_target.index.names).sum()
                    retrofit_rate_agg = agg / _stock.groupby(_rate_target.index.names).sum()
                    rslt = append(rslt, retrofit_rate_agg - _rate_target)

                    # calibration scale
                    retrofit_mean = (retrofit_rate_calc * _stock).sum() / _stock.sum()
                    std_deviation_calc = (((retrofit_rate_calc - retrofit_mean) ** 2 * _stock).sum() / (
                                _stock.sum() - 1)) ** (1 / 2)
                    rslt = append(rslt, _std_deviation - std_deviation_calc)

                    return rslt

                _ms_target = _calib_intensive['ms_insulation_ini']
                _rate_target = _calib_renovation['renovation_rate_ini']
                _deviation = _calib_renovation['renovation']['scale']['deviation']

                _, _utility_intensive = to_market_share(_bill_saved, _subsidies_total, _cost_total)

                unknown_intensive = _ms_target.copy()
                unknown_intensive[_ms_target > 0] = 0
                unknown = _rate_target.copy()
                unknown[_rate_target > 0] = 0
                unknown = append(unknown_intensive.to_numpy(), unknown.to_numpy(), 1)

                root, infodict, ier, mess = fsolve(solve, unknown, args=(
                    _ms_target, _utility_intensive, _rate_target, _stock, _deviation), full_output=True)




                                scale = Series(self.scale, index=['Scale'])
            constant_ext = self.constant_insulation_extensive.copy()
            constant_ext.index = constant_ext.index.to_flat_index()
            constant_int = self.constant_insulation_intensive.copy()
            constant_int.index = constant_int.index.to_flat_index()
            if isinstance(constant_int, DataFrame):
                constant_int = constant_int.stack(constant_int.columns.names)

            r = self.add_certificate(renovation_rate)
            s = self.add_certificate(stock)
            flow_retrofit = r * s
            retrofit_rate_mean = flow_retrofit.sum() / s.sum()
            retrofit_rate_mean = Series(retrofit_rate_mean, index=['Retrofit rate mean (%)'])
            retrofit_calibrated = flow_retrofit.groupby(renovation_rate_ini.index.names).sum() / s.groupby(renovation_rate_ini.index.names).sum()
            retrofit_calibrated.index = retrofit_calibrated.index.to_flat_index()
            flow_retrofit = flow_retrofit.droplevel('Performance')
            flow_insulation = (flow_retrofit * market_share.T).T.sum()
            flow_insulation_agg, name = list(), ''
            for i in flow_insulation.index.names:
                flow_insulation_agg.append(flow_insulation.xs(True, level=i).sum())
                name = '{}{},'.format(name, i)
            name = Series('', index=[name])
            flow_insulation_agg = Series(flow_insulation_agg, index=flow_insulation.index.names)
            flow_insulation.index = flow_insulation.index.to_flat_index()
            flow_insulation_sum = Series(flow_insulation.sum(), index=['Replacement insulation'])
            ms_calibrated = flow_insulation / flow_insulation.sum()
            ms_calibrated.index = ms_calibrated.index.to_flat_index()
            result = concat((scale, constant_ext, retrofit_rate_mean, retrofit_calibrated, flow_insulation_sum,
                                flow_insulation_agg, name, constant_int, flow_insulation, ms_calibrated,
                                ), axis=0)


            n = 'old'
            if self.new:
                n = 'new'
            n = '{}_{}'.format(self.name, n)
            target = target_subsidies[n]
            if not self.new:
                cost = cost[target].fillna(0)

            if self.new and self.name == 'zero_interest_loan':
                target_global = target_subsidies[n]
                cost_global = cost[target_global].fillna(0).copy()
                cost_included = reindex_mi(cost_included, cost_global.index)
                cost_included[cost_included.index.get_level_values("Heater replacement") == False] = 0
                cost_included = pd.concat([cost_included] * cost_global.shape[1], axis=1).set_axis(cost_global.columns, axis=1)
                cost_global[cost_global > 50000 - cost_included] = 50000 - cost_included

                cost_no_global = cost[~target_global].fillna(0).copy()
                # windows specific cap
                cost_no_global[cost_no_global.loc[:, idx[False, False, False, True]] > 7000] = 7000

                one_insulation = [c for c in cost_no_global.columns if (sum(idx[c]) == 1)]
                two_insulation = [c for c in cost_no_global.columns if (sum(idx[c]) == 2)]
                more_insulation = [c for c in cost_no_global.columns if (sum(idx[c]) > 2)]
                no_switch_idx = cost_no_global.xs(False, level='Heater replacement', drop_level=False).index

                cost_no_global[cost_no_global.loc[no_switch_idx, one_insulation] > 15000] = 15000 # count_cap_effect = 400
                cost_no_global[cost_no_global.loc[no_switch_idx, two_insulation] > 25000] = 25000 # count_cap_effect = 270
                cost_no_global[cost_no_global.loc[no_switch_idx, more_insulation] > 30000] = 30000 # count_cap_effect = 320
                cost_no_global[cost_no_global.loc[:, one_insulation] > 25000 - cost_included.loc[:, one_insulation]] = 25000 - cost_included # count_cap_effect = 1306
                cost_no_global[cost_no_global.loc[:, two_insulation] > 30000 - cost_included.loc[:, two_insulation]] = 30000 - cost_included # count_cap_effect = 2954

                cost = cost_global + cost_no_global
                #count_cap_effect = pd.DataFrame([cost_global > 50000 - cost_included][0], index=cost_global.index, columns=cost_global.columns).sum().sum()




            temp = self._renovation_rate.dropna(how='all')
            temp = temp.groupby([i for i in temp.index.names if i not in ['Heating system final']]).mean()

            if False in temp.index.get_level_values('Heater replacement'):
                t = temp.xs(False, level='Heater replacement')
                s_temp = self.stock
                s_temp = s_temp.groupby([i for i in s_temp.index.names if i != 'Income tenant']).sum()

                # Weighted average with stock to calculate real retrofit rate
                # TODO: doesn't work because self.stock have changed already - calculate before or remove
                output['Renovation rate (%)'] = ((t * s_temp).sum() / s_temp.sum())
                t_grouped = (t * s_temp).groupby(['Housing type', 'Occupancy status']).sum() / s_temp.groupby(
                    ['Housing type',
                     'Occupancy status']).sum()
                t_grouped.index = t_grouped.index.map(lambda x: 'Renovation rate {} - {} (%)'.format(x[0], x[1]))
                output.update(t_grouped.T)

            if True in temp.index.get_level_values('Heater replacement'):
                t = temp.xs(True, level='Heater replacement')
                s_temp = self.stock
                s_temp = s_temp.groupby([i for i in s_temp.index.names if i != 'Income tenant']).sum()
                output['Renovation rate w/ heater (%)'] = ((t * s_temp).sum() / s_temp.sum())

                t_grouped = (t * s_temp).groupby(['Housing type', 'Occupancy status']).sum() / s_temp.groupby(
                    ['Housing type',
                     'Occupancy status']).sum()
                t_grouped.index = t_grouped.index.map(lambda x: 'Renovation rate heater {} - {} (%)'.format(x[0], x[1]))
                output.update(t_grouped.T)


        # index only contains building with energy performance > B
        c_before = reindex_mi(certificate_before_heater, index)
        index = c_before[c_before > 'B'].index


                # prohibited energies can be a string or a list of strings
        energy_regulations = [policy for policy in policies_heater if policy.policy == 'heater_regulation']
        prohibited_energies = Series(list(array([policy.name.replace('_elimination', "").replace("_", " ").capitalize()
                                                 for policy in energy_regulations]).flat),
                                     index=[policy.name for policy in energy_regulations],
                                     dtype=object)

        for regulation in energy_regulations:
            if regulation.value is not None:
                heater = next(x for x in self._choice_heater if prohibited_energies[regulation.name] in x)
                lifetime_heater[heater] = regulation.value

        list_heaters = self._choice_heater
        for energy in prohibited_energies:
            list_heaters = list(set(list_heaters) & set([heater for heater in self._choice_heater if energy not in heater]))

        if energy_regulations:
            choice_heater_idx = Index(list_heaters, name='Heating system final')
        else:









        if False:
            # TODO: check retrofitting obligation
            # check if not already include in replacement could create an issue
            idx = self._renovation_store['replacement'].index
            temp = replaced_by.groupby(levels).sum().reindex(idx).fillna(0)
            self._renovation_store['replacement'] += temp
            temp = (replaced_by * self._renovation_store['cost_households']).groupby(levels).sum().reindex(idx).fillna(0)
            self._renovation_store['cost'] += temp
            temp = (replaced_by * self._renovation_store['cost_financing_households']).groupby(levels).sum().reindex(idx).fillna(0)
            self._renovation_store['cost_financing'] += temp
            temp = (replaced_by * self._renovation_store['subsidies_households']).groupby(levels).sum().reindex(idx).fillna(0)
            self._renovation_store['subsidies'] += temp

            for key, item in self._renovation_store['subsidies_details_households'].items():
                temp = (replaced_by * reindex_mi(item, replaced_by.index)).groupby(levels).sum().reindex(idx).fillna(0)
                self._renovation_store['subsidies_details'][key] += temp

            certificate_jump_all = self._condition_store['certificate_jump_all']
            temp = {}
            l = unique(certificate_jump_all.values.ravel('K'))
            for i in l:
                temp.update({i: ((certificate_jump_all == i) * replaced_by).sum(axis=1)})
            temp = DataFrame(temp).groupby(levels).sum().reindex(self._renovation_store['certificate_jump_all'].index).fillna(0)
            self._renovation_store['certificate_jump_all'] += temp

            temp = {i: 0 for i in range(1, 6)}
            for n, g in NB_MEASURES.items():
                temp[n] += replaced_by.loc[:, g].xs(False, level='Heater replacement').sum().sum()
                # explain why - no heater replacement in flow obligation
            self._renovation_store['nb_measures'] += Series(temp).reindex(self._renovation_store['nb_measures'].index).fillna(0)

            for key, sub in self._renovation_store['subsidies_details'].items():
                mask = sub.copy()
                mask[mask > 0] = 1
                self._renovation_store['subsidies_count'][key] += (replaced_by.fillna(0) * mask).sum(axis=1).groupby('Housing type').sum()

                # self._renovation_store['subsidies_count'][key] += (replaced_by.fillna(0) * mask).sum().sum()
                # self._renovation_store['subsidies_average'][key] += sub.sum().sum() / replaced_by.fillna(0).sum().sum()




            # do not consider the impact of heating system investment
            temp = Series({self.year: output['Annuities insulation (Billion euro/year)']})
            if self._annuities_store['stock_annuities'].empty:
                self._annuities_store['stock_annuities'] = temp
            else:
                self._annuities_store['stock_annuities'] = concat((self._annuities_store['stock_annuities'], temp))

            yrs = [y for y in self._annuities_store['stock_annuities'].index if y > self.year - 10]

            output['Stock annuities (Billion euro/year)'] = self._annuities_store['stock_annuities'].loc[yrs].sum()



            annuities = annuities.groupby(
                [c for c in annuities.index.names if c != 'Heater replacement']).sum()
            annuities = self.add_level(annuities, self._stock_ref, 'Income tenant').sum(axis=1)
            annuities = annuities.groupby(['Occupancy status', 'Income owner', 'Income tenant']).sum()
            coefficient = pd.Series([1, 0.5, 0.5],
                                    index=pd.Index(['Owner-occupied', 'Privately rented', 'Social-housing'],
                                                   name='Occupancy status'))
            investment = (annuities * reindex_mi(coefficient, annuities.index)).groupby('Income owner').sum()
            temp = investment.loc[resources_data['index']['Income owner']].rename(self.year)
            if self._annuities_store['investment_owner'].empty:
                self._annuities_store['investment_owner'] = temp.to_frame()
            else:
                self._annuities_store['investment_owner'] = concat((self._annuities_store['investment_owner'], temp),
                                                                   axis=1)
            investment = self._annuities_store['investment_owner'].loc[:, yrs].sum(axis=1)

            rent = (annuities * reindex_mi(1 - coefficient, annuities.index)).groupby('Income tenant').sum()
            temp = rent.loc[resources_data['index']['Income tenant']].rename(self.year)
            if self._annuities_store['rent_tenant'].empty:
                self._annuities_store['rent_tenant'] = temp.to_frame()
            else:
                self._annuities_store['rent_tenant'] = concat((self._annuities_store['rent_tenant'], temp),
                                                              axis=1)
            rent = self._annuities_store['rent_tenant'].loc[:, yrs].sum(axis=1)

            expense = energy_expenditure + investment + rent

            investment.index = investment.index.map(lambda x: 'Investment owner {} (Billion euro / year)'.format(x))
            output.update(investment.T / 10 ** 9 / step)
            rent.index = rent.index.map(lambda x: 'Rent tenant {} (Billion euro / year)'.format(x))
            output.update(rent.T / 10 ** 9 / step)

            households = self.stock.groupby('Income tenant').sum()
            income = households * self._income
            temp = (expense / income).loc[resources_data['index']['Income tenant']]
            temp.index = temp.index.map(lambda x: 'Budget share {} (%)'.format(x))
            output.update(temp.T)

    if import_calibration is not None and os.path.isfile(import_calibration):
        with open(import_calibration, "rb") as file:
            calibration = load(file)
    else:
        calibration = calibration_res_irf(os.path.join(path, 'calibration'), config=config, cost_factor=cost_factor)

    if export_calibration is not None:
        export_calibration = Path(export_calibration)
        parent = export_calibration.parent.absolute()
        if not os.path.isdir(parent):
            print('Creation of calibration folder here: {}'.format(parent))
            os.mkdir(parent)
        with open(export_calibration, "wb") as file:
            dump(calibration, file)




            """if 'mpr_serenite' in subsidies_details.keys():
                temp = subsidies_details['over_cap'].where(
                    subsidies_details['over_cap'] <= subsidies_details['mpr_serenite'],
                    subsidies_details['mpr_serenite'])
                subsidies_details['mpr_serenite'] -= temp
                remaining = subsidies_details['over_cap'] - temp
                assert (subsidies_details['mpr_serenite'].values >= 0).all(), 'MPR Serenite got negative values'
            if 'mpr' in subsidies_details.keys() and not (remaining > 0).any().any():
                subsidies_details['mpr'] -= remaining
                assert (subsidies_details['mpr'].values >= 0).all(), 'MPR got negative values'"""


    def store_energy_saving(self, flow_retrofit, flow_heater, prices):
        def saving(_flow, _prices):
            _flow = _flow[_flow > 0]
            _index = _flow.index

            _consumption_before = self.consumption_heating_store(_index, level_heater='Heating system', full_output=False)
            _consumption_before = reindex_mi(_consumption_before, _index) * reindex_mi(self._surface, _index)
            _consumption_before = self.consumption_actual(prices, consumption=_consumption_before)
            _consumption_before = (_consumption_before * _flow.T).T

            if isinstance(_flow, DataFrame):
                # insulation
                _consumption = self.prepare_consumption(index=_index, level_heater='Heating system',
                                                        full_output=False, store=False)
                _consumption = reindex_mi(_consumption, _index)
                _consumption = (_consumption.T * reindex_mi(self._surface, _index)).T

                heating_intensity = self.to_heating_intensity(_index, _prices, consumption=_consumption,
                                                              level_heater='Heating system final')
                _consumption *= _flow
                _consumption_after = _consumption * heating_intensity
                _consumption_saving_insulation = _consumption_before - _consumption_after

                # heater
                _consumption_saving_heater = None
                if 'Heating system final' in _index.names:
                    _consumption = self.prepare_consumption(index=_index, level_heater='Heating system final',
                                                            full_output=False)
                    _consumption = reindex_mi(_consumption, _index)
                    _consumption = (_consumption.T * reindex_mi(self._surface, _index)).T
                    heating_intensity = self.to_heating_intensity(_index, _prices, consumption=_consumption,
                                                                  level_heater='Heating system final')
                    _consumption *= _flow
                    _consumption = _consumption * heating_intensity
                    _consumption_saving_heater = _consumption_after - _consumption

                return _consumption_saving_insulation, _consumption_saving_heater

            if isinstance(_flow, Series):
                _consumption_saving_heater = None
                if 'Heating system final' in _index.names:
                    _consumption = self.consumption_heating_store(_index, level_heater='Heating system final',
                                                             full_output=False)
                    _consumption = reindex_mi(_consumption, _index)
                    _consumption = (_consumption.T * reindex_mi(self._surface, _index)).T
                    heating_intensity = self.to_heating_intensity(_index, _prices, consumption=_consumption,
                                                                  level_heater='Heating system final')
                    _consumption *= _flow
                    _consumption = _consumption * heating_intensity
                    _consumption_saving_heater = _consumption_before - _consumption
                    return _consumption_saving_heater

        consumption_saving_insulation, consumption_saving_heater = saving(flow_retrofit, prices)
        consumption_saving_insulation = consumption_saving_insulation.sum().sum()
        consumption_saving_heater = consumption_saving_heater.sum().sum()

        consumption_saving_only_heater = saving(flow_heater.stack(), prices)
        consumption_saving_only_heater = consumption_saving_only_heater.sum().sum()
        consumption_saving_heater += consumption_saving_only_heater

        self.consumption_saving_insulation = consumption_saving_insulation * self.coefficient_global
        self.consumption_saving_heater = consumption_saving_heater * self.coefficient_global

    def store_rebound(self, flow_retrofit, flow_heater, prices, prices_before=None, climate=2006):
        """Calculate consumption based on new building characteristics but current heating intensity.


        Useful to estimate the rebound effect.

        Parameters
        ----------
        flow_retrofit: Series or DataFrame
        flow_heater: Series or DataFrame
        prices: Series
        prices_before: Series
        climate: int, optional

        Returns
        -------
        Series
        """

        def calculate_rebound(_flow, _prices, _prices_before=None, _climate=None):
            # heating intensity is calculated based on index before renovation
            _flow = _flow[_flow > 0]
            _index = _flow.index

            if _prices_before is None:
                _prices_before = _prices

            consumption = self.consumption_heating(index=_index, freq='year', climate=_climate, full_output=False)
            consumption = reindex_mi(consumption, _index) * reindex_mi(self._surface, _index)
            intensity_before = self.to_heating_intensity(_index, _prices_before, consumption=consumption)

            # consumption standard is calculated based on retrofitting (heating system and insulation)
            # TODO: change prepare_consumption docstring
            if isinstance(_flow, DataFrame):
                # insulation and heater
                _consumption = self.prepare_consumption(index=_index, level_heater='Heating system final',
                                                        full_output=False, climate=_climate)
                _consumption = reindex_mi(_consumption, _index).reindex(_consumption.columns, axis=1)
                _consumption = (_consumption.T * reindex_mi(self._surface, _index)).T
                intensity_after = self.to_heating_intensity(_index, _prices, consumption=_consumption,
                                                            level_heater='Heating system final')
                _consumption *= _flow
                _consumption_before = (_consumption.T * intensity_before).T
                _consumption_before = _consumption_before.sum(axis=1)
                _consumption_after = _consumption * intensity_after
                _consumption_after = _consumption_after.sum(axis=1)

                return _consumption_before, _consumption_after

            elif isinstance(_flow, Series):
                level_heater = 'Heating system'
                if 'Heating system final' in _index.names:
                    level_heater = 'Heating system final'

                _consumption = self.consumption_heating(index=_index, freq='year', climate=_climate, full_output=False,
                                                        level_heater=level_heater)
                _consumption = reindex_mi(_consumption, _index) * reindex_mi(self._surface, _index)

                intensity_after = self.to_heating_intensity(_index, _prices, consumption=_consumption,
                                                            level_heater=level_heater)

                _consumption *= _flow
                _consumption_before = _consumption * intensity_before
                _consumption_after = _consumption * intensity_after

                return _consumption_before, _consumption_after

        def clean_flow(_flow, _index):
            if isinstance(_flow, DataFrame):
                _flow = _flow.sum(axis=1)

            if 'Heating system final' in _flow.index.names:
                _flow = _flow.droplevel('Heating system')
                _flow.index = _flow.index.rename('Heating system', level='Heating system final')
            _flow = _flow.groupby(_index.names).sum()

            _union = _index.union(_flow.index)
            _flow = _flow.reindex(_union, fill_value=0)
            return _flow

        flow_heater = flow_heater.stack()

        index = self.stock.index
        c_no_rebound_retrofit, c_rebound_retrofit = calculate_rebound(flow_retrofit, prices,
                                                                      _prices_before=prices_before, _climate=climate)
        c_no_rebound_retrofit = clean_flow(c_no_rebound_retrofit, index)
        c_rebound_retrofit = clean_flow(c_rebound_retrofit, index)

        c_no_rebound_heater, c_rebound_heater = calculate_rebound(flow_heater, prices, _prices_before=prices_before,
                                                                  _climate=climate)
        c_no_rebound_heater = clean_flow(c_no_rebound_heater, index)
        c_rebound_heater = clean_flow(c_no_rebound_heater, index)

        flow_retrofit = clean_flow(flow_retrofit.droplevel('Heating system final'), index)
        flow_heater = clean_flow(flow_heater.droplevel('Heating system final'), index)
        stock_remaining = self.stock - flow_retrofit - flow_heater
        c_no_rebound_remaining, c_rebound_remaining = calculate_rebound(stock_remaining, prices,
                                                                        _prices_before=prices_before, _climate=climate)

        union = c_no_rebound_retrofit.index.union(c_no_rebound_heater.index)
        union = union.union(c_no_rebound_remaining.index)

        c_no_rebound_retrofit = c_no_rebound_retrofit.reindex(union, fill_value=0)
        c_rebound_retrofit = c_rebound_retrofit.reindex(union, fill_value=0)
        c_no_rebound_heater = c_no_rebound_heater.reindex(union, fill_value=0)
        c_rebound_heater = c_rebound_heater.reindex(union, fill_value=0)
        c_no_rebound_remaining = c_no_rebound_remaining.reindex(union, fill_value=0)
        c_rebound_remaining = c_rebound_remaining.reindex(union, fill_value=0)

        c_no_rebound = c_no_rebound_retrofit + c_no_rebound_heater + c_no_rebound_remaining
        c_rebound = c_rebound_retrofit + c_rebound_heater + c_rebound_remaining

        c_no_rebound_energy = self.apply_calibration(c_no_rebound)
        c_rebound_energy = self.apply_calibration(c_rebound)

        self.rebound = c_rebound_energy - c_no_rebound_energy
        self.cost_rebound = (prices * self.rebound).sum()


        if self._debug_mode:
            self.logger.debug('Calculate rebound effect')
            self.store_rebound(replaced_by, flow_only_heater, prices, climate=climate)
            self.logger.debug('Calculate energy saving')
            self.store_energy_saving(replaced_by, flow_only_heater, prices)

def select_output(output):
    """Select output

    Parameters
    ----------
    output: DataFrame
        Res-IRF  output.

    Returns
    -------
    DataFrame
        Selected rows
    """

    energy = ['Electricity', 'Natural gas', 'Oil fuel', 'Wood fuel']
    heater_replacement = ['Electricity-Heat pump water',
                          'Electricity-Heat pump air',
                          'Electricity-Performance boiler',
                          'Natural gas-Performance boiler',
                          'Wood fuel-Performance boiler'
                          ]
    heater_stock = heater_replacement + ['Natural gas-Standard boiler',
                                         'Wood fuel-Standard boiler',
                                         'Oil fuel-Standard boiler',
                                         'Oil fuel-Performance boiler',
                                         ]
    consumption_energy = ['Consumption {} climate (TWh)'.format(i) for i in energy]
    rebound_energy = ['Rebound {} (TWh)'.format(i) for i in energy]

    variables = list()
    variables += consumption_energy
    variables += rebound_energy

    variables += [
        'Investment heater (Billion euro)',
        'Investment insulation (Billion euro)',
        'Investment total (Billion euro)',
        'Subsidies heater (Billion euro)',
        'Subsidies insulation (Billion euro)',
        'Subsidies total (Billion euro)',
        'Health cost (Billion euro)',
        'Energy poverty (Million)',
        'Heating intensity (%)',
        'Emission (MtCO2)',
        'Cost rebound (Billion euro)',
        'Consumption saving insulation (TWh)',
        'Consumption saving heater (TWh)',
        'Investment insulation / saving (euro/kWh)',
        'Investment heater / saving (euro/kWh)'
    ]
    variables += ['Replacement heater {} (Thousand households)'.format(i) for i in heater_replacement]
    variables += ['Stock {} (Thousand households)'.format(i) for i in heater_stock]

    variables = [v for v in variables if v in output.index]
    return output.loc[variables]



                if expected_utility is None:
                utility_bill_saving = reindex_mi(self.preferences_insulation['bill_saved'], _bill_saved.index) * _bill_saved / 1000

                pref_sub = reindex_mi(self.preferences_insulation['subsidy'], _subsidies_total.index).rename(None)
                utility_subsidies = (pref_sub * _subsidies_total) / 1000

                pref_investment = reindex_mi(self.preferences_insulation['cost'], _cost_total.index).rename(None)
                utility_investment = (pref_investment * _cost_total) / 1000

                utility_renovate = utility_investment + utility_bill_saving + utility_subsidies
            else:
                utility_renovate = expected_utility

                                """
                _bill_saved_insulation = (_bill_saved.reindex(_market_share.index) * _market_share).sum(axis=1)
                _subsidies_insulation = (_subsidies_total.reindex(_market_share.index) * _market_share).sum(axis=1)

                # bill saved == 0 should have been removed in market_share calculation
                idx = _bill_saved_insulation[_bill_saved_insulation <= 0].index
                _investment_insulation.drop(idx, inplace=True)
                _bill_saved_insulation.drop(idx, inplace=True)
                _subsidies_insulation.drop(idx, inplace=True)

                utility_bill_saving = reindex_mi(self.preferences_insulation['bill_saved'], _bill_saved_insulation.index) * _bill_saved_insulation / 1000

                utility_subsidies = reindex_mi(self.preferences_insulation['subsidy'], _subsidies_insulation.index).rename(None) * _subsidies_insulation / 1000

                utility_constant = reindex_mi(self.constant_insulation_extensive, utility_bill_saving.index)

                utility_investment = (_investment_insulation * pref_investment) / 1000

                utility = utility_subsidies + utility_bill_saving + utility_constant + utility_investment"""


                """pref_investment = reindex_mi(self.preferences_insulation['cost'], _cost_total.index).rename(None)
                utility_investment = (_cost_total.T * pref_investment).T / 1000
                expected_utility = log(exp(_utility_intensive + (mu - 1) * utility_investment).sum(axis=1))"""
                """pref_investment = reindex_mi(self.preferences_insulation['cost'], _cost_total.index).rename(None)
                _utility_intensive += (self._markup_store - 1) * (_cost_total.T * pref_investment).T / 1000
                expected_utility = log(exp(_utility_intensive).sum(axis=1))
                _renovation_rate = to_renovation_rate(expected_utility)"""