Index: project/model.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import os\nimport pandas as pd\nimport logging\nfrom time import time\nimport json\nfrom importlib import resources\n\nfrom project.building import AgentBuildings, ThermalBuildings\nfrom project.read_input import read_stock, read_policies, read_inputs, parse_inputs, dump_inputs, PublicPolicy\nfrom project.write_output import plot_scenario\nfrom project.utils import reindex_mi\n\nLOG_FORMATTER = '%(asctime)s - %(process)s - %(name)s - %(levelname)s - %(message)s'\n\n\ndef create_logger(path=None):\n    \"\"\"Create logger for one run.\n\n    Parameters\n    ----------\n    path: str\n\n    Returns\n    -------\n    Logger\n    \"\"\"\n    if path is None:\n        name = ''\n    else:\n        name = path.split('/')[-1].lower()\n\n    logger = logging.getLogger('log_{}'.format(name))\n    logger.setLevel('DEBUG')\n    logger.propagate = False\n    # consoler handler\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(logging.Formatter(LOG_FORMATTER))\n    logger.addHandler(console_handler)\n    # file handler\n    if path is not None:\n        file_handler = logging.FileHandler(os.path.join(path, 'log.log'))\n        file_handler.setFormatter(logging.Formatter(LOG_FORMATTER))\n        logger.addHandler(file_handler)\n    return logger\n\n\ndef get_config() -> dict:\n    with resources.path('project.input', 'config.json') as f:\n        with open(f) as file:\n            return json.load(file)['Reference']\n\n\ndef config2inputs(config=None, building_stock=None):\n    \"\"\"Create main Python object from configuration file.\n\n    Parameters\n    ----------\n    config: dict\n    building_stock: str\n        Path to other building stock than reference.\n\n    Returns\n    -------\n\n    \"\"\"\n\n    if config is None:\n        config = get_config()\n\n    if building_stock is not None:\n        config['building_stock'] = building_stock\n\n    stock, year = read_stock(config)\n    policies_heater, policies_insulation, taxes = read_policies(config)\n    inputs = read_inputs(config)\n    if config['quintiles']:\n        stock, policies_heater, policies_insulation, inputs = deciles2quintiles(stock, policies_heater,\n                                                                                policies_insulation, inputs)\n\n    return inputs, stock, year, policies_heater, policies_insulation, taxes\n\n\ndef deciles2quintiles(stock, policies_heater, policies_insulation, inputs):\n    \"\"\"Change all inputs from deciles to quintiles.\n\n    Parameters\n    ----------\n    stock\n    policies_heater\n    policies_insulation\n    inputs\n\n    Returns\n    -------\n\n    \"\"\"\n\n    replace = {'D1': 'C1', 'D2': 'C1',\n               'D3': 'C2', 'D4': 'C2',\n               'D5': 'C3', 'D6': 'C3',\n               'D7': 'C4', 'D8': 'C4',\n               'D9': 'C5', 'D10': 'C5'}\n\n    def apply_to_pandas(data, func='mean'):\n        level_income = []\n        for key in ['Income owner', 'Income tenant', 'Income']:\n            if key in data.index.names:\n                level_income += [key]\n\n        for level in level_income:\n            names = None\n            if isinstance(data.index, pd.MultiIndex):\n                names = data.index.names\n\n            data = data.rename(index=replace, level=level)\n\n            if func == 'mean':\n                data = data.groupby(data.index).mean()\n            elif func == 'sum':\n                data = data.groupby(data.index).sum()\n\n            if names:\n                data.index = pd.MultiIndex.from_tuples(data.index)\n                data.index.names = names\n\n        return data\n\n    for key, item in inputs.items():\n        if isinstance(item, (pd.Series, pd.DataFrame)):\n            inputs[key] = apply_to_pandas(item)\n        elif isinstance(item, dict):\n            for k, i in item.items():\n                if isinstance(i, (pd.Series, pd.DataFrame)):\n                    inputs[key][k] = apply_to_pandas(i)\n                elif isinstance(i, dict):\n                    for kk, ii in i.items():\n                        if isinstance(ii, (pd.Series, pd.DataFrame)):\n                            inputs[key][k][kk] = apply_to_pandas(ii)\n                        elif isinstance(ii, dict):\n                            for kkk, iii in ii.items():\n                                if isinstance(iii, (pd.Series, pd.DataFrame)):\n                                    inputs[key][k][kk][kkk] = apply_to_pandas(iii)\n\n    stock = apply_to_pandas(stock, func='sum')\n\n    for policy in policies_insulation + policies_heater:\n        attributes = [a for a in dir(policy) if not a.startswith('__') and getattr(policy, a) is not None]\n        for att in attributes:\n            item = getattr(policy, att)\n            if isinstance(item, (pd.Series, pd.DataFrame)):\n                setattr(policy, att, apply_to_pandas(item))\n            if isinstance(item, dict):\n                print(item)\n\n    return stock, policies_heater, policies_insulation, inputs\n\n\ndef select_post_inputs(parsed_inputs):\n    \"\"\"Inputs used during post-treatment but not used during the iteration.\n\n    Parameters\n    ----------\n    parsed_inputs: dict\n\n    Returns\n    -------\n    dict\n    \"\"\"\n\n    vars = ['carbon_emission', 'population', 'surface', 'embodied_energy_renovation', 'carbon_footprint_renovation',\n            'Carbon footprint construction (MtCO2)', 'Embodied energy construction (TWh PE)',\n            'health_expenditure', 'mortality_cost', 'loss_well_being', 'carbon_value_kwh']\n\n    return {key: item for key, item in parsed_inputs.items() if key in vars}\n\n\ndef get_inputs(path=None, config=None, variables=None, building_stock=None):\n    \"\"\"Initialize thermal buildings object based on input dictionnary.\n\n    Parameters\n    ----------\n    path: str, optional\n        If None do not write output.\n    config: dict, optional\n        If config is None use configuration file of Reference scenario\n    variables: list, optional\n        'buildings', 'energy_prices', 'cost_insulation', 'carbon_emission', 'carbon_value_kwh', 'health_cost'\n    building_stock\n\n    Returns\n    -------\n    dict\n    \"\"\"\n    if variables is None:\n        variables = ['buildings', 'energy_prices', 'cost_insulation', 'carbon_emission', 'carbon_value_kwh', 'health_cost']\n\n    inputs, stock, year, policies_heater, policies_insulation, taxes = config2inputs(config, building_stock=building_stock)\n    buildings, energy_prices, taxes, post_inputs, cost_heater, ms_heater, cost_insulation, ms_intensive, renovation_rate_ini, flow_built, cost_financing = initialize(\n        inputs, stock, year, taxes, path=path, config=config)\n    output = {'buildings': buildings,\n              'energy_prices': energy_prices,\n              'cost_insulation': cost_insulation,\n              'carbon_emission': post_inputs['carbon_emission'],\n              'carbon_value_kwh': post_inputs['carbon_value_kwh'],\n              'health_cost': post_inputs['health_expenditure'] + post_inputs['mortality_cost'] + post_inputs['loss_well_being'],\n              'efficiency': buildings._efficiency,\n              'performance_insulation': buildings._performance_insulation\n              }\n    output = {k: item for k, item in output.items() if k in variables}\n\n    return output\n\n\ndef initialize(inputs, stock, year, taxes, path=None, config=None, logger=None):\n    \"\"\"Create main Python objects read by model.\n\n    Parameters\n    ----------\n    inputs\n    stock\n    year\n    taxes\n    config\n    path\n    logger\n\n    Returns\n    -------\n\n    \"\"\"\n\n    if config is None:\n        config = get_config()\n\n    parsed_inputs = parse_inputs(inputs, taxes, config, stock)\n    if path is not None:\n        dump_inputs(parsed_inputs, path)\n    post_inputs = select_post_inputs(parsed_inputs)\n    if logger is None:\n        logger = create_logger(path)\n    logger.info('Creating AgentBuildings object')\n\n    if path is not None:\n        with open(os.path.join(path, 'config.json'), 'w') as fp:\n            json.dump(config, fp)\n\n    buildings = AgentBuildings(stock, parsed_inputs['surface'], parsed_inputs['ratio_surface'], parsed_inputs['efficiency'],\n                               parsed_inputs['income'], parsed_inputs['consumption_ini'], parsed_inputs['preferences'],\n                               parsed_inputs['performance_insulation'], path=path,\n                               year=year, demolition_rate=parsed_inputs['demolition_rate'],\n                               endogenous=config['endogenous'], logger=logger,\n                               remove_market_failures=config.get('remove_market_failures'),\n                               quintiles=config.get('quintiles'),\n                               detailed_mode=config.get('detailed_mode'),\n                               financing_cost=config.get('financing_cost'),\n                               debug_mode=config.get('debug_mode'))\n\n    return buildings, parsed_inputs['energy_prices'], parsed_inputs['taxes'], post_inputs, parsed_inputs['cost_heater'], parsed_inputs['ms_heater'], \\\n           parsed_inputs['cost_insulation'], parsed_inputs['ms_intensive'], parsed_inputs[\n               'renovation_rate_ini'], parsed_inputs['flow_built'], parsed_inputs.get('input_financing')\n\n\ndef stock_turnover(buildings, prices, taxes, cost_heater, cost_insulation, p_heater, p_insulation, flow_built, year,\n                   post_inputs,  ms_heater=None,  ms_insulation=None, renovation_rate_ini=None,\n                   target_freeriders=None, financing_cost=None):\n\n    buildings.logger.info('Run {}'.format(year))\n    buildings.year = year\n    buildings.add_flows([- buildings.flow_demolition()])\n    flow_obligation = buildings.flow_obligation()\n    buildings.add_flows([flow_obligation])\n\n    flow_retrofit = buildings.flow_retrofit(prices, cost_heater, cost_insulation,\n                                            policies_heater=p_heater,\n                                            policies_insulation=p_insulation,\n                                            ms_insulation=ms_insulation,\n                                            renovation_rate_ini=renovation_rate_ini,\n                                            target_freeriders=target_freeriders,\n                                            ms_heater=ms_heater,\n                                            financing_cost=financing_cost)\n    buildings.add_flows([flow_retrofit, flow_built])\n    buildings.calculate_consumption(prices, taxes)\n    buildings.logger.info('Writing output')\n    if buildings.detailed_mode:\n        stock, output = buildings.parse_output_run(post_inputs)\n    else:\n        stock = buildings.simplified_stock().rename(year)\n        output = buildings.heat_consumption_energy.rename(year) / 10 ** 9\n        output.index = output.index.map(lambda x: 'Consumption {} (TWh)'.format(x))\n\n    return buildings, stock, output\n\n\ndef res_irf(config, path):\n    \"\"\"Res-IRF model.\n\n    Parameters\n    ----------\n    config: dict\n        Scenario-specific input\n    path: str\n        Scenario-specific output path\n\n    Returns\n    -------\n    str\n        Scenario name\n    pd.DataFrame\n        Detailed results\n    \"\"\"\n    os.mkdir(path)\n    logger = create_logger(path)\n\n    try:\n        logger.info('Reading input')\n\n        inputs, stock, year, policies_heater, policies_insulation, taxes = config2inputs(config)\n        buildings, energy_prices, taxes, post_inputs, cost_heater, ms_heater, cost_insulation, ms_intensive, renovation_rate_ini, flow_built, financing_cost = initialize(\n            inputs, stock, year, taxes, path=path, config=config, logger=logger)\n\n        output, stock = pd.DataFrame(), pd.DataFrame()\n        buildings.logger.info('Calibration energy consumption {}'.format(buildings.first_year))\n        buildings.calculate_consumption(energy_prices.loc[buildings.first_year, :], taxes)\n        s, o = buildings.parse_output_run(post_inputs)\n        stock = pd.concat((stock, s), axis=1)\n        output = pd.concat((output, o), axis=1)\n\n        for year in range(config['start'] + 1, config['end']):\n            start = time()\n\n            prices = energy_prices.loc[year, :]\n            p_heater = [p for p in policies_heater if (year >= p.start) and (year < p.end)]\n            p_insulation = [p for p in policies_insulation if (year >= p.start) and (year < p.end)]\n            f_built = flow_built.loc[:, year]\n            target_freeriders = config['target_freeriders']\n\n            buildings, s, o = stock_turnover(buildings, prices, taxes, cost_heater, cost_insulation, p_heater,\n                                             p_insulation, f_built, year, post_inputs,\n                                             ms_insulation=ms_intensive, renovation_rate_ini=renovation_rate_ini,\n                                             target_freeriders=target_freeriders, ms_heater=ms_heater,\n                                             financing_cost=financing_cost)\n\n            stock = pd.concat((stock, s), axis=1)\n            stock.index.names = s.index.names\n            output = pd.concat((output, o), axis=1)\n            buildings.logger.info('Run time {}: {:,.0f} seconds.'.format(year, round(time() - start, 2)))\n\n        if path is not None:\n            buildings.logger.info('Dumping output in {}'.format(path))\n            output.round(3).to_csv(os.path.join(path, 'output.csv'))\n            stock.round(2).to_csv(os.path.join(path, 'stock.csv'))\n        if buildings.detailed_mode:\n            plot_scenario(output, stock, buildings)\n\n        return os.path.basename(os.path.normpath(path)), output, stock\n\n    except Exception as e:\n        buildings.logger.exception(e)\n        raise e\n\n\ndef cost_curve(consumption_before, consumption_saved, cost_insulation, percent=True, marginal=False):\n    \"\"\"Create cost curve.\n\n    Parameters\n    ----------\n    consumption_before\n    consumption_saved\n    cost_insulation\n    percent: bool, default True\n    marginal: bool, default False\n\n    Returns\n    -------\n\n    \"\"\"\n\n    insulation = {'Wall': (True, False, False, False), 'Floor': (False, True, False, False),\n                  'Roof': (False, False, True, False), 'Windows': (False, False, False, True)}\n    insulation = pd.MultiIndex.from_frame(pd.DataFrame(insulation))\n\n    consumption_saved = consumption_saved.loc[:, insulation]\n    cost_insulation = cost_insulation.loc[:, insulation]\n\n    cost_efficiency = cost_insulation / consumption_saved\n\n    x = consumption_saved.stack(consumption_saved.columns.names).squeeze().rename('Consumption saved')\n    y = cost_efficiency.stack(cost_efficiency.columns.names).squeeze().rename('Cost efficiency (euro/kWh/year)')\n    c = (x * y).rename('Cost (Billion euro)') / 10**9\n    df = pd.concat((x, y, c), axis=1)\n\n    # sort by marginal cost\n    df.sort_values(y.name, inplace=True)\n\n    if percent is True:\n        df[x.name] = x / consumption_before.sum()\n        # x.name = '{} (%/initial)'.format(x.name)\n    else:\n        df[x.name] /= 10**9\n        # x.name = '{} (TWh/an)'.format(x.name)\n\n    if marginal is False:\n        df['{} cumulated'.format(x.name)] = df[x.name].cumsum()\n        df['{} cumulated'.format(c.name)] = df[c.name].cumsum()\n        df.dropna(inplace=True)\n        df = df.set_index('{} cumulated'.format(x.name))['{} cumulated'.format(c.name)]\n    else:\n        df.dropna(inplace=True)\n        df[y.name] = df[y.name].round(1)\n        df = df.groupby([y.name]).agg({x.name: 'sum', y.name: 'first'})\n        df = df.set_index(x.name)[y.name]\n    return df\n\n\ndef social_planner(aggregation_archetype=None, climate=2006, smooth=False, building_stock='medium_3', freq='hour',\n                   percent=True, marginal=False):\n    \"\"\"Function used when coupling with power system model.\n\n    Parameters\n    ----------\n    aggregation_archetype\n    climate\n    smooth\n    building_stock: optional, {'medium_1', 'medium_3', 'medium_5', 'simple_1', 'simple_3', 'simple_5'}\n        Numbers of clusters + heterogeneity of u values.\n    freq: optional, {'hour', 'day', 'month', 'year'}\n    percent: bool, default True\n    marginal: bool, default\n\n    Returns\n    -------\n\n    \"\"\"\n    resirf_inputs = get_inputs(variables=['buildings', 'energy_prices', 'cost_insulation'],\n                               building_stock=os.path.join('project', 'input', 'stock', 'buildingstock_sdes2018_{}.csv'.format(building_stock)))\n    buildings = resirf_inputs['buildings']\n    energy_prices = resirf_inputs['energy_prices']\n    cost_insulation = resirf_inputs['cost_insulation']\n\n    heating_need = buildings.heating_need(freq=freq, climate=climate, smooth=smooth)\n    heating_need_class = heating_need.sum(axis=1) / (buildings.stock * reindex_mi(buildings._surface, buildings.stock.index))\n\n    insulation_class = heating_need_class.copy()\n    insulation_class[insulation_class <= 100] = 1\n    insulation_class[(insulation_class > 100) & (insulation_class <= 200)] = 2\n    insulation_class[(insulation_class > 200) & (insulation_class <= 300)] = 3\n    insulation_class[insulation_class > 300] = 4\n    insulation_class = insulation_class.astype(str).rename('Insulation')\n\n    wall_class = heating_need_class.copy()\n    wall_class[wall_class.index.get_level_values('Wall') < 1] = 1\n    wall_class[(wall_class.index.get_level_values('Wall') >= 1) & (wall_class.index.get_level_values('Wall') < 2)] = 2\n    wall_class[wall_class.index.get_level_values('Wall') >= 2] = 3\n    wall_class = wall_class.astype(str).rename('Wall class')\n\n    buildings.consumption_actual(energy_prices.loc[buildings.first_year, :])\n    heating_intensity = buildings.heating_intensity\n\n    heating_need = (heating_intensity * heating_need.T).T\n\n    output = buildings.mitigation_potential(energy_prices, cost_insulation)\n\n    consumption_saved = output['Need saved (kWh/segment)']\n\n    cost_insulation = output['Cost insulation (euro/segment)']\n    cost_insulation[consumption_saved == 0] = 0\n\n    consumption_before = output['Need before (kWh/segment)']\n\n    if aggregation_archetype is not None:\n        if 'Performance' in aggregation_archetype:\n            heating_need = buildings.add_certificate(heating_need)\n\n            consumption_saved = buildings.add_certificate(consumption_saved)\n            consumption_saved.columns = output['Need saved (kWh/segment)'].columns\n\n            cost_insulation = buildings.add_certificate(cost_insulation)\n            cost_insulation.columns = output['Cost insulation (euro/segment)'].columns\n\n            consumption_before = buildings.add_certificate(consumption_before)\n\n        if 'Energy' in aggregation_archetype:\n            heating_need = buildings.add_energy(heating_need)\n\n            consumption_saved = buildings.add_energy(consumption_saved)\n            consumption_saved.columns = output['Need saved (kWh/segment)'].columns\n\n            cost_insulation = buildings.add_energy(cost_insulation)\n            cost_insulation.columns = output['Cost insulation (euro/segment)'].columns\n\n            consumption_before = buildings.add_energy(consumption_before)\n\n        if 'Insulation' in aggregation_archetype:\n            heating_need = pd.concat((heating_need, insulation_class), axis=1).set_index('Insulation', append=True)\n\n            consumption_saved = pd.concat((consumption_saved, insulation_class), axis=1).set_index('Insulation', append=True)\n            consumption_saved.columns = output['Need saved (kWh/segment)'].columns\n\n            cost_insulation = pd.concat((cost_insulation, insulation_class), axis=1).set_index('Insulation', append=True)\n            cost_insulation.columns = output['Cost insulation (euro/segment)'].columns\n\n            consumption_before = pd.concat((consumption_before, insulation_class), axis=1).set_index('Insulation', append=True).squeeze()\n\n        if 'Wall class' in aggregation_archetype:\n            heating_need = pd.concat((heating_need, wall_class), axis=1).set_index('Wall class', append=True)\n\n            consumption_saved = pd.concat((consumption_saved, wall_class), axis=1).set_index('Wall class',\n                                                                                                   append=True)\n            consumption_saved.columns = output['Need saved (kWh/segment)'].columns\n\n            cost_insulation = pd.concat((cost_insulation, wall_class), axis=1).set_index('Wall class',\n                                                                                               append=True)\n            cost_insulation.columns = output['Cost insulation (euro/segment)'].columns\n\n            consumption_before = pd.concat((consumption_before, wall_class), axis=1).set_index('Wall class',\n                                                                                                     append=True).squeeze()\n\n    dict_cost, dict_heat = dict(), dict()\n    if aggregation_archetype is not None:\n        dict_cost = {n: cost_curve(consumption_before.loc[g.index], g, cost_insulation.loc[g.index, :], percent=percent,\n                                   marginal=marginal) for n, g in consumption_saved.groupby(aggregation_archetype)}\n        heating_need_grouped = heating_need.groupby(aggregation_archetype).sum()\n        dict_heat = {i: heating_need_grouped.loc[i, :] for i in heating_need_grouped.index}\n    else:\n        dict_cost['global'] = cost_curve(consumption_before, consumption_saved, cost_insulation, marginal=marginal,\n                                         percent=percent)\n        dict_heat['global'] = heating_need.sum()\n\n    return dict_cost, dict_heat\n\n\nif __name__ == '__main__':\n    from utils import make_plots\n    dict_cost, _ = social_planner(aggregation_archetype=None, building_stock='medium_5',\n                                  freq='hour', percent=False, marginal=True)\n    make_plots(dict_cost, 'Cost (Billion euro)')\n\n\n\n    \"\"\"buildings = get_inputs(variables=['buildings'])['buildings']\n\n    h_month = buildings.heating_need(climate=2006, smooth=False, freq='month')\n    h_year = buildings.heating_need(climate=2006, smooth=False, freq='year')\n\n    h_month = buildings.heating_need(climate=2006, smooth=False, freq='month')\n    h_day = buildings.heating_need(climate=2006, smooth=False, freq='day')\n    h_hour = buildings.heating_need(climate=2006, smooth=False, freq='hour')\"\"\"\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/project/model.py b/project/model.py
--- a/project/model.py	
+++ b/project/model.py	
@@ -267,8 +267,9 @@
     buildings.logger.info('Run {}'.format(year))
     buildings.year = year
     buildings.add_flows([- buildings.flow_demolition()])
-    flow_obligation = buildings.flow_obligation()
-    buildings.add_flows([flow_obligation])
+    if buildings.year > 2019:
+        flow_obligation = buildings.flow_obligation()
+        buildings.add_flows([flow_obligation])
 
     flow_retrofit = buildings.flow_retrofit(prices, cost_heater, cost_insulation,
                                             policies_heater=p_heater,
Index: project/building.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Copyright 2020-2021 Ecole Nationale des Ponts et Chaussées\n#\n# This file is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n#\n# Original author Lucas Vivier <vivier@centre-cired.fr>\n\nimport os\n\nimport pandas as pd\nfrom pandas import Series, DataFrame, MultiIndex, Index, IndexSlice, concat, to_numeric, unique, read_csv\nfrom numpy import exp, log, zeros, ones, append, arange, array\nfrom scipy.optimize import fsolve\nimport matplotlib.pyplot as plt\nimport logging\n\nfrom project.utils import make_plot, format_ax, save_fig, format_legend, reindex_mi, timing, get_pandas\nfrom project.input.resources import resources_data\nimport project.thermal as thermal\n\nfrom itertools import product\n\n\nclass ThermalBuildings:\n    \"\"\"ThermalBuildings classes.\n\n    Parameters:\n    ----------\n    stock: Series\n        Building stock.\n    surface: Series\n        Surface by dwelling type.\n    param: dict\n        Generic input.\n    efficiency: Series\n        Heating system efficiency.\n    income: Series\n    consumption_ini: Series\n    path: str\n    year: int, default 2018\n\n    Attributes:\n    ----------\n\n    heat_consumption_sd : Series\n        kWh by segement\n    heat_consumption : Series\n        kWh by segement\n\n    heat_consumption_calib : Series\n    heat_consumption_energy : Series\n\n    heating_intensity_tenant: dict\n        Weighted average heating intensity (%) by decile.\n    heating_intensity_avg: dict\n        Weighted average heating intensity (%).\n    energy_poverty: dict\n        Number of energy poverty dwelling.\n\n    taxes_expenditure: dict\n    energy_expenditure: dict\n    taxes_expenditure_details: dict\n\n    \"\"\"\n    def __init__(self, stock, surface, ratio_surface, efficiency, income, consumption_ini, path=None, year=2018,\n                 debug_mode=False):\n\n        self.energy_poverty = None\n        self.consumption_3uses_building, self.consumption_sd_building, self.certificate_building = Series(\n            dtype='float'), Series(dtype='float'), Series(dtype='float')\n\n        self.consumption_sd_building_choice, self.consumption_3uses_building_choice, self.certificate_building_choice = Series(\n            dtype='float'), Series(dtype='float'), Series(dtype='float')\n\n        self._debug_mode = debug_mode\n\n        if isinstance(stock, MultiIndex):\n            stock = Series(index=stock, dtype=float)\n\n        self._efficiency = efficiency\n        self._ratio_surface = ratio_surface\n        self.path = path\n        if path is not None:\n            self.path_calibration = os.path.join(path, 'calibration')\n            if not os.path.isdir(self.path_calibration):\n                os.mkdir(self.path_calibration)\n            self.path_calibration_renovation = os.path.join(self.path_calibration, 'renovation')\n            if not os.path.isdir(self.path_calibration_renovation):\n                os.mkdir(self.path_calibration_renovation)\n            self.path_static = os.path.join(path, 'static')\n            if not os.path.isdir(self.path_static):\n                os.mkdir(self.path_static)\n\n        self._consumption_ini = consumption_ini\n        self.coefficient_consumption = None\n\n        self._surface_yrs = surface\n        self._surface = surface.loc[:, year]\n\n        self._income = income\n        self._income_owner = self._income.copy()\n        self._income_owner.index.rename('Income owner', inplace=True)\n        self._income_tenant = self._income.copy()\n        self._income_tenant.index.rename('Income tenant', inplace=True)\n\n        self._residual_rate = 0.05\n        self._stock_residual = self._residual_rate * stock\n        self.stock_mobile = stock - self._stock_residual\n\n        self.first_year = year\n        self._year = year\n        # self.certificate_nb = None\n\n        # TODO only heating_intensity and calculate average in parse_output\n        self.heating_intensity_avg = None\n        # self.energy_poverty = None\n        self.heat_consumption_sd = None\n        self.heat_consumption = None\n        self.heat_consumption_calib = None\n        self.heat_consumption_energy = None\n        self.taxes_expenditure = None\n        self.energy_expenditure = None\n        self.taxes_list = []\n        self.taxes_expenditure_details = {}\n        self.stock_yrs = {}\n\n        self.stock = stock\n\n    @property\n    def year(self):\n        return self._year\n\n    @year.setter\n    def year(self, year):\n        self._year = year\n        self._surface = self._surface_yrs.loc[:, year]\n\n    @property\n    def stock(self):\n        return self._stock\n\n    @stock.setter\n    def stock(self, stock):\n        \"\"\"Update stock property.\n\n        Parameters\n        ----------\n        stock: Series\n\n        Returns\n        -------\n\n        \"\"\"\n\n        self._stock = stock\n        self.stock_mobile = stock - self._stock_residual.reindex(stock.index, fill_value=0)\n        self.surface = reindex_mi(self._surface, stock.index)\n        # self.housing_type = Series(stock.index.get_level_values('Housing type'), index=stock.index)\n\n        heating_system = Series(stock.index.get_level_values('Heating system'), index=stock.index)\n        self.energy = heating_system.str.split('-').str[0].rename('Energy')\n        self.efficiency = to_numeric(heating_system.replace(self._efficiency))\n\n        self.stock_yrs.update({self.year: self.stock})\n\n        consumption_sd, _, certificate = self.consumption_standard(stock.index)\n        self.heat_consumption_sd = self.surface * reindex_mi(consumption_sd, stock.index)\n        self.certificate = reindex_mi(certificate, stock.index)\n\n    def simplified_stock(self, energy_level=False):\n        stock = self.stock.fillna(0)\n        certificate = self.certificate.rename('Performance')\n        energy = self.energy.rename('Energy')\n        stock = concat((stock, certificate, energy), axis=1).set_index(['Performance', 'Energy'], append=True).squeeze()\n        if energy_level:\n            stock = stock.groupby(\n                ['Occupancy status', 'Income owner', 'Income tenant', 'Housing type', 'Heating system',\n                 'Energy', 'Performance']).sum()\n\n        else:\n            stock = stock.groupby(\n                ['Occupancy status', 'Income owner', 'Income tenant', 'Housing type', 'Heating system',\n                 'Performance']).sum()\n\n        return stock\n\n    def add_certificate(self, df):\n        \"\"\"Add energy performance certificate to df index.\n\n        Parameters\n        ----------\n        df\n        heating_system\n\n        Returns\n        -------\n\n        \"\"\"\n        certificate = self.certificate.rename('Performance')\n        lvl = [i for i in certificate.index.names if i in df.index.names]\n        certificate = certificate.groupby(lvl).first()\n\n        certificate = reindex_mi(certificate, df.index)\n        df = concat((df, certificate), axis=1).set_index('Performance', append=True).squeeze()\n\n        return df\n\n    def add_energy(self, df):\n        energy = self.energy.rename('Energy')\n        lvl = [i for i in energy.index.names if i in df.index.names]\n        energy = energy.groupby(lvl).first()\n        energy = reindex_mi(energy, df.index)\n        df = concat((df, energy), axis=1).set_index('Energy', append=True).squeeze()\n        return df\n\n    def heating_need(self, hourly=True, climate=None, smooth=False):\n        \"\"\"Calculate heating need of the current building stock.\n\n        Returns\n        -------\n        pd.DataFrame\n        \"\"\"\n        idx = self.stock.index\n        wall = Series(idx.get_level_values('Wall'), index=idx)\n        floor = Series(idx.get_level_values('Floor'), index=idx)\n        roof = Series(idx.get_level_values('Roof'), index=idx)\n        windows = Series(idx.get_level_values('Windows'), index=idx)\n\n        heating_need = thermal.conventional_heating_need(wall, floor, roof, windows, self._ratio_surface.copy(),\n                                                         th_bridging='Medium', vent_types='Ventilation naturelle',\n                                                         infiltration='Medium', climate=climate, hourly=hourly,\n                                                         smooth=smooth)\n\n        heating_need = (heating_need.T * self.stock * self.surface).T\n        return heating_need\n\n    def heating_consumption(self, hourly=True, climate=None, smooth=False):\n        \"\"\"Calculation consumption standard of the current building stock.\n\n        Parameters\n        ----------\n        hourly\n        climate\n        smooth\n\n        Returns\n        -------\n\n        \"\"\"\n\n        idx = self.stock.index\n        wall = Series(idx.get_level_values('Wall'), index=idx)\n        floor = Series(idx.get_level_values('Floor'), index=idx)\n        roof = Series(idx.get_level_values('Roof'), index=idx)\n        windows = Series(idx.get_level_values('Windows'), index=idx)\n        heating_system = Series(idx.get_level_values('Heating system'), index=idx).astype('object')\n        efficiency = to_numeric(heating_system.replace(self._efficiency))\n        consumption = thermal.conventional_heating_final(wall, floor, roof, windows, self._ratio_surface.copy(),\n                                                         efficiency, climate=climate, hourly=hourly,\n                                                         smooth=smooth)\n        return consumption\n\n\n    def consumption_standard(self, indexes, level_heater='Heating system'):\n        \"\"\"Pre-calculate space energy consumption based only on relevant levels.\n\n        Parameters\n        ----------\n        indexes: MultiIndex, Index\n            Index used to estimate consumption standard.\n        level_heater: {'Heating system', 'Heating system final'}, default 'Heating system'\n\n        Returns\n        -------\n\n        \"\"\"\n        levels_consumption = ['Wall', 'Floor', 'Roof', 'Windows', level_heater, 'Housing type']\n        index = indexes.to_frame().loc[:, levels_consumption].set_index(levels_consumption).index\n        index = index[~index.duplicated()]\n\n        index.rename({level_heater: 'Heating system'}, inplace=True)\n        # remove index already calculated\n        if not self.consumption_sd_building.empty:\n            temp = self.consumption_sd_building.index.intersection(index)\n            idx = index.drop(temp)\n        else:\n            idx = index\n\n        if not idx.empty:\n            wall = Series(idx.get_level_values('Wall'), index=idx)\n            floor = Series(idx.get_level_values('Floor'), index=idx)\n            roof = Series(idx.get_level_values('Roof'), index=idx)\n            windows = Series(idx.get_level_values('Windows'), index=idx)\n            heating_system = Series(idx.get_level_values('Heating system'), index=idx).astype('object')\n            efficiency = to_numeric(heating_system.replace(self._efficiency))\n\n            consumption = thermal.conventional_heating_final(wall, floor, roof, windows, self._ratio_surface.copy(),\n                                                             efficiency)\n\n            certificate, consumption_3uses = thermal.conventional_energy_3uses(wall, floor, roof, windows,\n                                                                               self._ratio_surface.copy(),\n                                                                               efficiency, idx)\n\n            self.consumption_sd_building = concat((self.consumption_sd_building, consumption))\n            self.consumption_sd_building.index = MultiIndex.from_tuples(\n                self.consumption_sd_building.index).set_names(consumption.index.names)\n            self.consumption_3uses_building = concat((self.consumption_3uses_building, consumption_3uses))\n            self.consumption_3uses_building.index = MultiIndex.from_tuples(\n                self.consumption_3uses_building.index).set_names(consumption.index.names)\n\n            self.certificate_building = concat((self.certificate_building, certificate))\n            self.certificate_building.index = MultiIndex.from_tuples(\n                self.certificate_building.index).set_names(consumption.index.names)\n\n        levels_consumption = [i for i in indexes.names if i in levels_consumption]\n\n        consumption_sd = self.consumption_sd_building.loc[index]\n        consumption_sd.index.rename({'Heating system': level_heater}, inplace=True)\n        consumption_sd = consumption_sd.reorder_levels(levels_consumption)\n        consumption_3uses = self.consumption_3uses_building.loc[index]\n        consumption_3uses.index.rename({'Heating system': level_heater}, inplace=True)\n        consumption_3uses = consumption_3uses.reorder_levels(levels_consumption)\n        certificate = self.certificate_building.loc[index]\n        certificate.index.rename({'Heating system': level_heater}, inplace=True)\n        certificate = certificate.reorder_levels(levels_consumption)\n\n        return consumption_sd, consumption_3uses, certificate\n\n    def consumption_actual(self, prices, consumption=None):\n        \"\"\"Space heating consumption based on standard space heating consumption and heating intensity (kWh/a).\n\n        Space heating consumption is in kWh/building.a\n        Equation is based on Allibe (2012).\n\n        Parameters\n        ----------\n        prices: Series\n\n        Returns\n        -------\n        Series\n        \"\"\"\n\n        if consumption is None:\n            consumption = self.heat_consumption_sd.copy()\n        else:\n            consumption = consumption.copy()\n\n        energy_bill = AgentBuildings.energy_bill(prices, consumption)\n        if isinstance(energy_bill, Series):\n            budget_share = energy_bill / reindex_mi(self._income_tenant, self.stock.index)\n            heating_intensity = -0.191 * budget_share.apply(log) + 0.1105\n            consumption *= heating_intensity\n            self.heating_intensity_avg = (self.stock * heating_intensity).sum() / self.stock.sum()\n            self.energy_poverty = (self.stock[self.stock.index.get_level_values(\n                'Income owner') == ('D1' or 'D2' or 'D3')])[budget_share >= 0.08].sum()\n        elif isinstance(energy_bill, DataFrame):\n            budget_share = (energy_bill.T / reindex_mi(self._income_tenant, self.stock.index)).T\n            heating_intensity = -0.191 * budget_share.apply(log) + 0.1105\n            consumption = heating_intensity * consumption\n\n        return consumption\n\n    def calculate_consumption(self, prices, taxes):\n        \"\"\"Calculate energy indicators.\n\n        Parameters\n        ----------\n        prices: Series\n        taxes: Series\n\n        Returns\n        -------\n\n        \"\"\"\n\n        self.heat_consumption = self.consumption_actual(prices) * self.stock\n\n        heat_consumption_energy = self.heat_consumption.groupby(self.energy).sum()\n        if self.coefficient_consumption is None:\n\n            consumption = concat((self.heat_consumption, self.energy), axis=1).groupby(\n                ['Housing type', 'Energy']).sum().iloc[:, 0] / 10**9\n\n            # considering 20% of electricity got wood stove - 50% electricity\n            electricity_wood = 0.2 * consumption[('Single-family', 'Electricity')] * 1\n            consumption[('Single-family', 'Wood fuel')] += electricity_wood\n            consumption[('Single-family', 'Electricity')] -= electricity_wood\n            consumption.groupby('Energy').sum()\n\n            self.heat_consumption.groupby('Housing type').sum() / 10**9\n\n            validation = dict()\n\n            # stock initial\n            temp = concat((self.stock, self.energy), axis=1).groupby(\n                ['Housing type', 'Energy']).sum().iloc[:, 0] / 10**3\n            temp.index = temp.index.map(lambda x: 'Stock {} {} (Thousands)'.format(x[0], x[1]))\n            validation.update(temp)\n            temp = self.stock.groupby('Housing type').sum() / 10**3\n            temp.index = temp.index.map(lambda x: 'Stock {} (Thousands)'.format(x))\n            validation.update(temp)\n            validation.update({'Stock (Thousands)': self.stock.sum() / 10**3})\n\n            # surface initial\n            temp = concat((self.stock * self.surface, self.energy), axis=1).groupby(\n                ['Housing type', 'Energy']).sum().iloc[:, 0] / 10**6\n            temp.index = temp.index.map(lambda x: 'Surface {} {} (Million m2)'.format(x[0], x[1]))\n            validation.update(temp)\n            temp = (self.stock * self.surface).groupby('Housing type').sum() / 10**6\n            temp.index = temp.index.map(lambda x: 'Surface {} (Million m2)'.format(x))\n            validation.update(temp)\n            validation.update({'Surface (Million m2)': (self.stock * self.surface).sum() / 10**6})\n\n            # heating consumption initial\n            temp = concat((self.heat_consumption, self.energy), axis=1).groupby(\n                ['Housing type', 'Energy']).sum().iloc[:, 0] / 10**9\n            temp.index = temp.index.map(lambda x: 'Consumption {} {} (TWh)'.format(x[0], x[1]))\n            validation.update(temp)\n            temp = self.heat_consumption.groupby('Housing type').sum() / 10**9\n            temp.index = temp.index.map(lambda x: 'Consumption {} (TWh)'.format(x))\n            validation.update(temp)\n            validation.update({'Consumption (TWh)': self.heat_consumption.sum() / 10**9})\n\n            self.coefficient_consumption = self._consumption_ini * 10**9 / heat_consumption_energy\n\n            temp = self.coefficient_consumption.copy()\n            temp.index = temp.index.map(lambda x: 'Coefficient calibration {} (%)'.format(x))\n            validation.update(temp)\n\n            temp = heat_consumption_energy / 10**9\n            temp.index = temp.index.map(lambda x: 'Consumption {} (TWh)'.format(x))\n            validation.update(temp)\n\n            validation = Series(validation)\n            if resources_data['data_calibration'] is not None:\n                validation = concat((validation, resources_data['data_calibration']), keys=['Calcul', 'Data'], axis=1)\n                validation['Error'] = (validation['Calcul'] - validation['Data']) / validation['Data']\n\n            if self.path is not None:\n                validation.round(2).to_csv(os.path.join(self.path_calibration, 'validation_stock.csv'))\n\n        coefficient = self.coefficient_consumption.reindex(self.energy).set_axis(self.stock.index, axis=0)\n        self.heat_consumption_calib = (coefficient * self.heat_consumption).copy()\n\n        self.heat_consumption_energy = self.heat_consumption_calib.groupby(self.energy).sum()\n\n        prices_reindex = prices.reindex(self.energy).set_axis(self.stock.index, axis=0)\n        self.energy_expenditure = prices_reindex * self.heat_consumption_calib\n\n        total_taxes = Series(0, index=prices.index)\n        for tax in taxes:\n            if self.year in tax.value.index:\n                if tax.name not in self.taxes_list:\n                    self.taxes_list += [tax.name]\n                amount = tax.value.loc[self.year, :] * heat_consumption_energy\n                self.taxes_expenditure_details[tax.name] = amount\n                total_taxes += amount\n\n        self.taxes_expenditure = total_taxes\n\n    @staticmethod\n    def energy_bill(prices, consumption, level_heater='Heating system'):\n        \"\"\"Calculate energy bill by dwelling for each stock segment (€/dwelling.a).\n\n        Parameters\n        ----------\n        prices: Series\n            Energy prices for year (€/kWh)\n        consumption: Series\n            Energy consumption by dwelling (kWh/dwelling.a)\n        level_heater\n            Heating system level to calculate the bill. Enable to calculate energy bill before or after change of\n            heating system.\n\n        Returns\n        -------\n        pd.Series\n            Energy bill by dwelling for each stock segment (€/dwelling)\n        \"\"\"\n\n        index = consumption.index\n\n        heating_system = Series(index.get_level_values(level_heater), index=index)\n        energy = heating_system.str.split('-').str[0].rename('Energy')\n\n        prices = prices.rename('Energy').reindex(energy)\n        prices.index = index\n\n        if isinstance(consumption, pd.Series):\n            # * reindex_mi(self._surface, index)\n            return reindex_mi(consumption, index) * prices\n        else:\n            # * reindex_mi(self._surface, index)\n            return (reindex_mi(consumption, index).T * prices).T\n\n\nclass AgentBuildings(ThermalBuildings):\n\n    \"\"\"Class AgentBuildings represents thermal dynamic building stock.\n\n\n    Attributes\n    ----------\n    pref_inertia:  float or Series\n\n    pref_investment_insulation: float or Series\n    pref_bill_insulation: float or Series\n    pref_subsidy_insulation: float or Series\n\n\n    cost_insulation: DataFrame\n        Cost by segment and by insulation choice (€).\n    investment_insulation: DataFrame\n        Investment realized by segment and by insulation choice (€).\n    tax_insulation: DataFrame\n        Tax by segment and by insulation choice (€).\n    certificate_jump: DataFrame\n        Number of jump of energy performance certificate.\n    retrofit_rate: dict\n\n\n    \"\"\"\n\n    def __init__(self, stock, surface, ratio_surface, efficiency, income, consumption_ini, preferences,\n                 performance_insulation, path=None, demolition_rate=0.0, year=2018,\n                 endogenous=True, number_exogenous=300000, utility_extensive='market_share',\n                 logger=None, debug_mode=False, preferences_zeros=False, calib_scale=True, detailed_mode=None,\n                 remove_market_failures=None, quintiles=None, financing_cost=True,\n                 ):\n        super().__init__(stock, surface, ratio_surface, efficiency, income, consumption_ini, path=path, year=year,\n                         debug_mode=debug_mode)\n\n        self.certificate_jump_heater = None\n        self.global_renovation = None\n        self.financing_cost = financing_cost\n        self.subsidies_count_insulation, self.subsidies_average_insulation = dict(), dict()\n        self.subsidies_count_heater, self.subsidies_average_heater = dict(), dict()\n\n        self.prepared_cost_insulation = None\n        self.certificate_jump_all = None\n        self.retrofit_with_heater = None\n        self._calib_scale = calib_scale\n        self.vta = 0.1\n        self.factor_etp = 7.44 / 10**6 # ETP/€\n        self.lifetime_insulation = 30\n        self._epc2int = {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6}\n\n        self.quintiles = quintiles\n        if detailed_mode is None:\n            detailed_mode = True\n        self.detailed_mode = detailed_mode\n\n        if logger is None:\n            logger = logging.getLogger()\n        self.logger = logger\n        self.policies = []\n\n        # {'max', 'market_share'} define how to calculate utility_extensive\n        self._utility_extensive = utility_extensive\n\n        if preferences_zeros:\n            preferences['heater'] = {k: 0 for k in preferences['heater'].keys()}\n            preferences['insulation'] = {k: 0 for k in preferences['insulation'].keys()}\n\n        if isinstance(preferences['heater']['investment'], Series):\n            self.pref_investment_heater = preferences['heater']['investment'].copy()\n        else:\n            self.pref_investment_heater = preferences['heater']['investment']\n\n        if isinstance(preferences['insulation']['investment'], Series):\n            self.pref_investment_insulation_int = preferences['insulation']['investment'].copy()\n            self.pref_investment_insulation_ext = preferences['insulation']['investment'].copy()\n        else:\n            self.pref_investment_insulation_int = preferences['insulation']['investment']\n            self.pref_investment_insulation_ext = preferences['insulation']['investment']\n\n        self.pref_subsidy_heater = preferences['heater']['subsidy']\n        if isinstance(preferences['insulation']['subsidy'], Series):\n            self.pref_subsidy_insulation_int = preferences['insulation']['subsidy'].copy()\n            self.pref_subsidy_insulation_ext = preferences['insulation']['subsidy'].copy()\n        else:\n            self.pref_subsidy_insulation_int = preferences['insulation']['subsidy']\n            self.pref_subsidy_insulation_ext = preferences['insulation']['subsidy']\n\n        if isinstance(preferences['insulation']['bill_saved'], Series):\n            self.pref_bill_heater = preferences['heater']['bill_saved'].copy()\n        else:\n            self.pref_bill_heater = preferences['heater']['bill_saved']\n\n        if isinstance(preferences['insulation']['bill_saved'], Series):\n            self.pref_bill_insulation_int = preferences['insulation']['bill_saved'].copy()\n            self.pref_bill_insulation_ext = preferences['insulation']['bill_saved'].copy()\n        else:\n            self.pref_bill_insulation_int = preferences['insulation']['bill_saved']\n            self.pref_bill_insulation_ext = preferences['insulation']['bill_saved']\n\n        self.pref_inertia = preferences['heater']['inertia']\n        self.pref_zil_int = preferences['insulation']['zero_interest_loan']\n        self.pref_zil_ext = preferences['insulation']['zero_interest_loan']\n\n        # self.discount_rate = - self.pref_investment_insulation_ext / self.pref_bill_insulation_ext\n        # self.discount_factor = (1 - (1 + self.discount_rate) ** -self.lifetime_insulation) / self.discount_rate\n\n        self.scale_int = None\n        self.scale_ext = None\n        self.calibration_scale = 'cite'\n        self.param_supply = None\n        self.capacity_utilization = None\n        self.factor_yrs = {}\n\n        self._demolition_rate = demolition_rate\n        self._demolition_total = (stock * self._demolition_rate).sum()\n        self._target_demolition = ['E', 'F', 'G']\n\n        self._choice_heater = None\n        self._probability_replacement = None\n\n        self._endogenous = endogenous\n\n        self._target_exogenous = ['F', 'G']\n        self._market_share_exogenous = None\n        self._number_exogenous = number_exogenous\n\n        choice_insulation = {'Wall': [False, True], 'Floor': [False, True], 'Roof': [False, True],\n                             'Windows': [False, True]}\n        names = list(choice_insulation.keys())\n        choice_insulation = list(product(*[i for i in choice_insulation.values()]))\n        choice_insulation.remove((False, False, False, False))\n        choice_insulation = MultiIndex.from_tuples(choice_insulation, names=names)\n\n        self._choice_insulation = choice_insulation\n        self._performance_insulation = {i: min(val, self.stock.index.get_level_values(i).min()) for i, val in\n                                        performance_insulation.items()}\n        # min of self.stock\n        self.surface_insulation = self._ratio_surface.copy()\n\n        self.constant_insulation_extensive, self.constant_insulation_intensive, self.constant_heater = None, None, None\n\n        self.cost_insulation_indiv, self.subsidies_heater_indiv, self.subsidies_insulation_indiv = None, None, None\n\n        self.certificate_jump = None\n        self.gest_nb = None\n\n        self.global_renovation_high_income, self.global_renovation_low_income = None, None\n        self.in_best, self.out_worst = None, None\n        self.bonus_best, self.bonus_worst = None, None\n        self.market_share = None\n        self.replacement_heater, self.heater_replaced = None, None\n        self.cost_heater, self.investment_heater = None, None\n        self.tax_heater = None\n        self.subsidies_details_heater, self.subsidies_heater = None, None\n\n        self.replacement_insulation, self.retrofit_rate = None, None\n        self.cost_component, self.investment_insulation = None, None\n        self.tax_insulation, self.taxed_insulation = None, None\n        self.subsidies_details_insulation, self.subsidies_insulation = None, None\n\n        self.zil_count, self.zil_loaned_avg, self.zil_loaned = None, None, None\n\n        self._share_decision_maker = stock.groupby(\n            ['Occupancy status', 'Housing type', 'Income owner', 'Income tenant']).sum().unstack(\n            ['Occupancy status', 'Income owner', 'Income tenant'])\n        self._share_decision_maker = (self._share_decision_maker.T / self._share_decision_maker.sum(axis=1)).T\n\n        self._remove_market_failures = remove_market_failures\n\n    def add_flows(self, flows):\n        \"\"\"Update stock attribute by adding flow series.\n\n        Parameters\n        ----------\n        flows: Series, list\n        \"\"\"\n        flow_total = None\n        if isinstance(flows, Series):\n            flow_total = flows\n        if isinstance(flows, list):\n            for flow in flows:\n                if flow_total is None:\n                    flow_total = flow.copy()\n                else:\n                    union = flow.index.union(flow_total.index)\n                    flow_total = flow.reindex(union, fill_value=0) + flow_total.reindex(union, fill_value=0)\n\n        union = flow_total.index.union(self.stock.index)\n        stock = flow_total.reindex(union, fill_value=0) + self.stock.reindex(union, fill_value=0)\n        assert (stock >= 0).all(), 'Stock Error: Building stock cannot be negative'\n        stock[stock < 0] = 0\n        stock = stock[stock > 0]\n        self.stock = stock\n\n    def prepare_consumption(self, choice_insulation=None, performance_insulation=None, index=None,\n                            level_heater='Heating system'):\n        \"\"\"Calculate standard energy consumption and energy performance certificate for each choice insulation for all\n        households.\n\n        Standard energy consumption only depends on building characteristics.\n\n        Returns\n        -------\n        DataFrame\n            Final consumption standard.\n        DataFrame\n            Primary consumption standard 3 uses.\n        DataFrame\n            Cerfificate.\n        \"\"\"\n\n        if index is None:\n            index = self.stock.index\n\n        if not isinstance(choice_insulation, MultiIndex):\n            choice_insulation = self._choice_insulation\n\n        # no_insulation used for specific reason\n        # no_insulation = MultiIndex.from_tuples([(False, False, False, False)], names=choice_insulation.names)\n        # choice_insulation = choice_insulation.append(no_insulation)\n        if not isinstance(performance_insulation, MultiIndex):\n            performance_insulation = self._performance_insulation\n\n        # only selecting useful levels\n        indx = index.copy()\n        indx = indx.droplevel([i for i in indx.names if i not in ['Housing type', 'Wall', 'Floor', 'Roof', 'Windows'] + [level_heater]])\n        indx = indx[~indx.duplicated()]\n\n        # remove idx already calculated\n        if not self.consumption_sd_building_choice.empty:\n            temp = self.consumption_sd_building_choice.index.intersection(indx)\n            idx = indx.drop(temp)\n        else:\n            idx = indx\n\n        if not idx.empty:\n            s = concat([Series(index=idx, dtype=float)] * len(choice_insulation), axis=1).set_axis(choice_insulation, axis=1)\n            # choice_insulation = choice_insulation.drop(no_insulation) # only for\n            s.index.rename({'Wall': 'Wall before', 'Floor': 'Floor before', 'Roof': 'Roof before', 'Windows': 'Windows before'}, inplace=True)\n            temp = s.fillna(0).stack(s.columns.names)\n            temp = temp.reset_index().drop(0, axis=1)\n            for i in ['Wall', 'Floor', 'Roof', 'Windows']:\n                # keep the info to unstack later\n                temp.loc[:, '{} bool'.format(i)] = temp.loc[:, i]\n                temp.loc[temp[i], i] = performance_insulation[i]\n                temp.loc[temp[i] == False, i] = temp.loc[temp[i] == False, '{} before'.format(i)]\n            temp = temp.astype(\n                {'Housing type': 'string', 'Wall': 'float', 'Floor': 'float', 'Roof': 'float', 'Windows': 'float',\n                 level_heater: 'string'})\n            index = MultiIndex.from_frame(temp)\n            # consumption based on insulated components\n            consumption_sd, consumption_3uses, certificate = self.consumption_standard(index, level_heater=level_heater)\n\n            rslt = dict()\n            for key, temp in {'consumption_sd': consumption_sd, 'consumption_3uses': consumption_3uses, 'certificate': certificate}.items():\n                temp = reindex_mi(temp, index).droplevel(['Wall', 'Floor', 'Roof', 'Windows']).unstack(\n                    ['{} bool'.format(i) for i in ['Wall', 'Floor', 'Roof', 'Windows']])\n                temp.index.rename({'Wall before': 'Wall', 'Floor before': 'Floor', 'Roof before': 'Roof', 'Windows before': 'Windows'},\n                                  inplace=True)\n                temp.columns.rename({'Wall bool': 'Wall', 'Floor bool': 'Floor', 'Roof bool': 'Roof', 'Windows bool': 'Windows'},\n                                    inplace=True)\n                rslt[key] = temp\n\n            if self.consumption_sd_building_choice.empty:\n                self.consumption_sd_building_choice = rslt['consumption_sd']\n                self.consumption_3uses_building_choice = rslt['consumption_3uses']\n                self.certificate_building_choice = rslt['certificate']\n            else:\n                self.consumption_sd_building_choice = concat((self.consumption_sd_building_choice, rslt['consumption_sd']))\n                self.consumption_3uses_building_choice = concat((self.consumption_3uses_building_choice, rslt['consumption_3uses']))\n                self.certificate_building_choice = concat((self.certificate_building_choice, rslt['certificate']))\n\n        consumption_sd = self.consumption_sd_building_choice.loc[indx.rename({'Heating system': level_heater})]\n        consumption_sd.index.rename({'Heating system': level_heater}, inplace=True)\n\n        primary_consumption_3uses = self.consumption_3uses_building_choice.loc[indx]\n        primary_consumption_3uses.index.rename({'Heating system': level_heater}, inplace=True)\n\n        certificate = self.certificate_building_choice.loc[indx]\n        certificate.index.rename({'Heating system': level_heater}, inplace=True)\n\n        return consumption_sd, primary_consumption_3uses, certificate\n\n    def heater_replacement(self, prices, cost_heater, policies_heater, ms_heater=None, probability_replacement=1/20,\n                           index=None):\n        \"\"\"Function returns new building stock after heater replacement.\n\n        Parameters\n        ----------\n        prices: Series\n        cost_heater: Series\n        ms_heater: DataFrame, optional\n        policies_heater: list\n        probability_replacement: float or Series, default 1/17\n        index: MultiIndex optional, default None\n\n        Returns\n        -------\n        Series\n        \"\"\"\n        if ms_heater is not None:\n            self._choice_heater = list(ms_heater.columns)\n\n        if isinstance(probability_replacement, float):\n            probability_replacement = Series(len(self._choice_heater) * [probability_replacement],\n                                                Index(self._choice_heater, name='Heating system final'))\n\n        if index is None:\n            index = self.stock.index\n            index = index.droplevel('Income tenant')\n            index = index[~index.duplicated()]\n\n        # prohibited energies can be a string or a list of strings\n        energy_regulations = [policy for policy in policies_heater if policy.policy == 'heater_regulation']\n        prohibited_energies = Series(list(array([policy.name.replace('_elimination', \"\").replace(\"_\", \" \").capitalize()\n                                             for policy in energy_regulations]).flat), index=[policy.name for policy in energy_regulations],\n                                        dtype=object)\n\n        for regulation in energy_regulations:\n            if regulation.value is not None:\n                heater = next(x for x in self._choice_heater if prohibited_energies[regulation.name] in x)\n                probability_replacement[heater] = regulation.value\n\n        self._probability_replacement = probability_replacement\n\n        list_heaters = self._choice_heater\n        for energy in prohibited_energies:\n            list_heaters = list(set(list_heaters) & set([heater for heater in self._choice_heater if energy not in heater]))\n\n        if energy_regulations:\n            choice_heater_idx = Index(list_heaters, name='Heating system final')\n        else:\n            choice_heater_idx = Index(self._choice_heater, name='Heating system final')\n\n        frame = Series(dtype=float, index=index).to_frame().dot(\n            Series(dtype=float, index=choice_heater_idx).to_frame().T)\n        cost_heater, tax_heater, subsidies_details, subsidies_total = self.apply_subsidies_heater(policies_heater,\n                                                                                                  cost_heater.copy(),\n                                                                                                  frame)\n        if self._endogenous:\n            subsidies_utility = subsidies_total.copy()\n            if 'reduced_tax' in subsidies_details.keys():\n                subsidies_utility -= subsidies_details['reduced_tax']\n            market_share = self.endogenous_market_share_heater(index, prices, subsidies_utility, cost_heater,\n                                                               ms_heater=ms_heater)\n\n        else:\n            market_share, probability_replacement = self.exogenous_market_share_heater(index, choice_heater_idx)\n\n        replacement = ((market_share * probability_replacement).T * self.stock_mobile.groupby(\n            market_share.index.names).sum()).T\n\n        stock_replacement = replacement.stack('Heating system final')\n        to_replace = replacement.sum(axis=1)\n        stock = self.stock_mobile.groupby(to_replace.index.names).sum() - to_replace\n\n        # adding heating system final equal to heating system because no switch\n        stock = concat((stock, Series(stock.index.get_level_values('Heating system'), index=stock.index,\n                                            name='Heating system final')), axis=1).set_index('Heating system final', append=True).squeeze()\n        stock = concat((stock.reorder_levels(stock_replacement.index.names), stock_replacement),\n                       axis=0, keys=[False, True], names=['Heater replacement'])\n        assert round(stock.sum() - self.stock_mobile.sum(), 0) == 0, 'Sum problem'\n\n        replaced_by = stock.droplevel('Heating system').rename_axis(index={'Heating system final': 'Heating system'})\n\n        if self.detailed_mode:\n            self.store_information_heater(cost_heater, subsidies_total, subsidies_details, replacement, tax_heater,\n                                          replaced_by)\n        else:\n            self.cost_heater = cost_heater\n\n        return stock\n\n    def apply_subsidies_heater(self, policies_heater, cost_heater, frame):\n        \"\"\"Calculate subsidies for each dwelling and each heating system.\n\n        Parameters\n        ----------\n        policies_heater: list\n        cost_heater: Series\n        frame: DataFrame\n            Index matches segments and columns heating system.\n\n        Returns\n        -------\n\n        \"\"\"\n\n        subsidies_total = DataFrame(0, index=frame.index, columns=frame.columns)\n        subsidies_details = {}\n\n        tax = self.vta\n        p = [p for p in policies_heater if 'reduced_tax' == p.policy]\n        if p:\n            tax = p[0].value\n            sub = cost_heater * (self.vta - tax)\n            subsidies_details.update({'reduced_tax': concat([sub] * frame.shape[0], keys=frame.index, axis=1).T})\n            subsidies_total += subsidies_details['reduced_tax']\n\n        tax_heater = cost_heater * tax\n        cost_heater += tax_heater\n\n        sub = None\n        for policy in policies_heater:\n            if policy.name not in self.policies:\n                self.policies += [policy.name]\n            if policy.policy == 'subsidy_target':\n                sub = policy.value.reindex(frame.columns, axis=1).fillna(0)\n                sub = reindex_mi(sub, frame.index)\n            elif policy.policy == 'subsidy_ad_volarem':\n\n                if isinstance(policy.value, (float, int)):\n                    sub = policy.value * cost_heater\n                    sub = concat([sub] * frame.shape[0], keys=frame.index, axis=1).T\n\n                if isinstance(policy.value, DataFrame):\n                    sub = policy.value * cost_heater\n                    sub = reindex_mi(sub, frame.index).fillna(0)\n\n                if isinstance(policy.value, Series):\n                    if policy.by == 'index':\n                        sub = policy.value.to_frame().dot(cost_heater.to_frame().T)\n                        sub = reindex_mi(sub, frame.index).fillna(0)\n                    elif policy.by == 'columns':\n                        sub = (policy.value * cost_heater).fillna(0).reindex(frame.columns)\n                        sub = concat([sub] * frame.shape[0], keys=frame.index, names=frame.index.names, axis=1).T\n                    else:\n                        raise NotImplemented\n                if policy.cap:\n                    sub[sub > policy.cap] = sub\n            else:\n                continue\n\n            subsidies_details[policy.name] = sub\n            subsidies_total += subsidies_details[policy.name]\n        return cost_heater, tax_heater, subsidies_details, subsidies_total\n\n    def store_information_heater(self, cost_heater, subsidies_total, subsidies_details, replacement, tax_heater,\n                                 replaced_by):\n        \"\"\"Store information yearly heater replacement.\n\n        Parameters\n        ----------\n        cost_heater: Series\n            Cost of each heating system (€).\n        subsidies_total: DataFrame\n            Total amount of eligible subsidies by dwelling and heating system (€).\n        subsidies_details: dict\n            Amount of eligible subsidies by dwelling and heating system (€).\n        replacement: DataFrame\n            Number of heating system replacement by dwelling and heating system chosen.\n        tax_heater: Series\n            VTA tax of each heating system (€).\n        replaced_by: Series\n            Dwelling updated with a new heating system.\n        \"\"\"\n        # information stored during\n        self.cost_heater = cost_heater\n        self.subsidies_heater_indiv = subsidies_total\n        self.subsidies_details_heater = subsidies_details\n        self.replacement_heater = replacement\n        self.investment_heater = replacement * cost_heater\n        self.tax_heater = replacement * tax_heater\n        self.subsidies_heater = replacement * subsidies_total\n        self.heater_replaced = replaced_by\n        for key in self.subsidies_details_heater.keys():\n            self.subsidies_details_heater[key] *= replacement\n\n        for key, sub in self.subsidies_details_heater.items():\n            mask = sub.copy()\n            mask[mask > 0] = 1\n            self.subsidies_count_heater.update({key: (replacement.fillna(0) * mask).sum().sum()})\n            self.subsidies_average_heater.update({key: sub.sum().sum() / replacement.fillna(0).sum().sum()})\n\n    def calibration_constant_heater(self, utility, ms_heater):\n        \"\"\"Constant to match the observed market-share.\n\n        Market-share is defined by initial and final heating system.\n\n        Parameters\n        ----------\n        utility: DataFrame\n        ms_heater: DataFrame\n\n        Returns\n        -------\n        DataFrame\n        \"\"\"\n\n        # removing unnecessary level\n        utility_ref = utility.droplevel(['Occupancy status']).copy()\n        utility_ref = utility_ref[~utility_ref.index.duplicated(keep='first')]\n\n        possible = reindex_mi(ms_heater, utility_ref.index)\n        utility_ref[~(possible > 0)] = float('nan')\n\n        stock = self.stock.groupby(utility_ref.index.names).sum()\n\n        # initializing constant to 0\n        constant = ms_heater.copy()\n        constant[constant > 0] = 0\n        market_share_ini, market_share_agg = None, None\n        for i in range(50):\n            constant.loc[constant['Electricity-Heat pump water'].notna(), 'Electricity-Heat pump water'] = 0\n            constant.loc[constant['Electricity-Heat pump water'].isna(), 'Electricity-Heat pump air'] = 0\n\n            utility_constant = reindex_mi(constant.reindex(utility_ref.columns, axis=1), utility.index)\n            utility = utility_ref + utility_constant\n            market_share = (exp(utility).T / exp(utility).sum(axis=1)).T\n            agg = (market_share.T * stock).T.groupby(['Housing type', 'Heating system']).sum()\n            market_share_agg = (agg.T / agg.sum(axis=1)).T\n            if i == 0:\n                market_share_ini = market_share_agg.copy()\n            constant = constant + log(ms_heater / market_share_agg)\n\n            ms_heater = ms_heater.reindex(market_share_agg.index)\n\n            if (market_share_agg.round(decimals=3) == ms_heater.round(decimals=3).fillna(0)).all().all():\n                self.logger.debug('Constant heater optim worked')\n                break\n\n        constant.loc[constant['Electricity-Heat pump water'].notna(), 'Electricity-Heat pump water'] = 0\n        constant.loc[constant['Electricity-Heat pump water'].isna(), 'Electricity-Heat pump air'] = 0\n\n        details = concat((constant.stack(), market_share_ini.stack(), market_share_agg.stack(), ms_heater.stack()),\n                            axis=1, keys=['constant', 'calcul ini', 'calcul', 'observed']).round(decimals=3)\n        if self.path is not None:\n            details.to_csv(os.path.join(self.path_calibration, 'calibration_constant_heater.csv'))\n\n        return constant\n\n    def endogenous_market_share_heater(self, index, prices, subsidies_total, cost_heater, ms_heater=None):\n\n        choice_heater = self._choice_heater\n        choice_heater_idx = Index(choice_heater, name='Heating system final')\n        energy = Series(choice_heater).str.split('-').str[0].set_axis(choice_heater_idx)\n\n        temp = pd.Series(0, index=index, dtype='float').to_frame().dot(pd.Series(0, index=choice_heater_idx, dtype='float').to_frame().T)\n        index_final = temp.stack().index\n        heat_consumption_sd, _, certificate = self.consumption_standard(index_final, level_heater='Heating system final')\n        heat_consumption_sd = reindex_mi(heat_consumption_sd.unstack('Heating system final'), index)\n        prices_re = prices.reindex(energy).set_axis(heat_consumption_sd.columns)\n        energy_bill_sd = ((heat_consumption_sd * prices_re).T * reindex_mi(self._surface, index)).T\n\n        consumption_before = self.consumption_standard(index, level_heater='Heating system')[0]\n        consumption_before = reindex_mi(consumption_before, index) * reindex_mi(self._surface, index)\n        energy_bill_before = AgentBuildings.energy_bill(prices, consumption_before)\n\n        bill_saved = - energy_bill_sd.sub(energy_bill_before, axis=0)\n        utility_bill_saving = (bill_saved.T * reindex_mi(self.pref_bill_heater, bill_saved.index)).T / 1000\n        utility_bill_saving = utility_bill_saving.loc[:, choice_heater]\n\n        certificate = reindex_mi(certificate.unstack('Heating system final'), index)\n        certificate_before = self.consumption_standard(index)[2]\n        certificate_before = reindex_mi(certificate_before, index)\n\n        self.certificate_jump_heater = - certificate.replace(self._epc2int).sub(\n            certificate_before.replace(self._epc2int), axis=0)\n\n        utility_subsidies = subsidies_total * self.pref_subsidy_heater / 1000\n\n        cost_heater = cost_heater.reindex(utility_bill_saving.columns)\n        pref_investment = reindex_mi(self.pref_investment_heater, utility_bill_saving.index).rename(None)\n        utility_investment = pref_investment.to_frame().dot(cost_heater.to_frame().T) / 1000\n\n        utility_inertia = DataFrame(0, index=utility_bill_saving.index, columns=utility_bill_saving.columns)\n        for hs in choice_heater:\n            utility_inertia.loc[\n                utility_inertia.index.get_level_values('Heating system') == hs, hs] = self.pref_inertia\n\n        utility = utility_inertia + utility_investment + utility_bill_saving + utility_subsidies\n\n        if (self.constant_heater is None) and (ms_heater is not None):\n            ms_heater.dropna(how='all', inplace=True)\n            self.constant_heater = self.calibration_constant_heater(utility, ms_heater)\n        utility_constant = reindex_mi(self.constant_heater.reindex(utility.columns, axis=1), utility.index)\n\n        utility += utility_constant\n        market_share = (exp(utility).T / exp(utility).sum(axis=1)).T\n\n        return market_share\n\n    def exogenous_market_share_heater(self, index, choice_heater_idx):\n        \"\"\"Define exogenous market-share.\n\n        Market-share is defined by _market_share_exogenous attribute.\n        Replacement\n\n        Parameters\n        ----------\n        index: MultiIndex\n        choice_heater_idx: Index\n\n        Returns\n        -------\n        DataFrame\n            Market-share by segment and possible heater choice.\n        Series\n            Probability replacement.\n        \"\"\"\n        self._market_share_exogenous = {'Wood fuel-Standard boiler': 'Wood fuel-Performance boiler',\n                                        'Wood fuel-Performance boiler': 'Wood fuel-Performance boiler',\n                                        'Oil fuel-Standard boiler': 'Oil fuel-Performance boiler',\n                                        'Oil fuel-Performance boiler': 'Oil fuel-Performance boiler',\n                                        'Natural gas-Standard boiler': 'Natural gas-Performance boiler',\n                                        'Natural gas-Performance boiler': 'Natural gas-Performance boiler',\n                                        'Electricity-Performance boiler': 'Electricity-Heat pump',\n                                        'Electricity-Heat pump': 'Electricity-Heat pump'}\n\n        market_share = Series(index=index, dtype=float).to_frame().dot(\n            Series(index=choice_heater_idx, dtype=float).to_frame().T)\n\n        for initial, final in self._market_share_exogenous.items():\n            market_share.loc[market_share.index.get_level_values('Heating system') == initial, final] = 1\n\n        to_replace = self.stock_mobile[self.certificate.isin(self._target_exogenous)]\n\n        if to_replace.sum() < self._number_exogenous:\n            self._target_exogenous = ['E', 'F', 'G']\n            to_replace = self.stock_mobile[self.certificate.isin(self._target_exogenous)]\n            if to_replace.sum() < self._number_exogenous:\n                self._target_exogenous = ['D', 'E', 'F', 'G']\n                to_replace = self.stock_mobile[self.certificate.isin(self._target_exogenous)]\n                if to_replace.sum() < self._number_exogenous:\n                    self._target_exogenous = ['C', 'D', 'E', 'F', 'G']\n                    to_replace = self.stock_mobile[self.certificate.isin(self._target_exogenous)]\n                    if to_replace.sum() < self._number_exogenous:\n                        self._number_exogenous = 0\n\n        to_replace = to_replace / to_replace.sum() * self._number_exogenous\n\n        to_replace = to_replace.groupby(index.names).sum()\n        probability_replacement = (to_replace / self.stock_mobile.groupby(index.names).sum()).fillna(0)\n        probability_replacement = probability_replacement.reindex(market_share.index)\n        return market_share, probability_replacement\n\n    def insulation_replacement(self, prices, cost_insulation_raw, ms_insulation=None, renovation_rate_ini=None,\n                               policies_insulation=None, target_freeriders=None, index=None, stock=None,\n                               supply_constraint=False, financing_cost=None):\n        \"\"\"Calculate insulation retrofit in the dwelling stock.\n\n        1. Intensive margin\n        2. Extensive margin\n        Calibrate function first year.\n\n        Consumption saving only depends on insulation work.\n        However, certificate upgrade also consider the heat\n\n        To reduce calculation time attributes are grouped.\n        Cost, subsidies and constant depends on Housing type, Occupancy status, Housing type and Insulation performance.\n\n        Parameters\n        ----------\n        prices: Series\n        cost_insulation_raw: Series\n            €/m2 of losses area by component.\n        ms_insulation: Series\n        renovation_rate_ini: Series\n        policies_insulation: list\n        target_freeriders: float\n        index: MultiIndex or Index, default None\n            Add heater replacement information compare to self.stock.\n        stock: Series, default None\n\n        Returns\n        -------\n        Series\n            Retrofit rate\n        DataFrame\n            Market-share insulation\n        \"\"\"\n        if index is None:\n            index = self.stock.index\n\n        _, _, certificate_before_heater = self.consumption_standard(index, level_heater='Heating system')\n        # index only contains building with energy performance > B\n        c_before = reindex_mi(certificate_before_heater, index)\n        index = c_before[c_before > 'B'].index\n\n        # before include the change of heating system\n        _, consumption_3uses_before, certificate_before = self.consumption_standard(index,\n                                                                                    level_heater='Heating system final')\n        certificate_before = certificate_before[certificate_before > 'B']\n        consumption_3uses_before = consumption_3uses_before.loc[certificate_before.index]\n\n        surface = reindex_mi(self._surface, index)\n\n        _, consumption_3uses, certificate = self.prepare_consumption(self._choice_insulation, index=index,\n                                                                     level_heater='Heating system final')\n        energy_saved_3uses = ((consumption_3uses_before - consumption_3uses.T) / consumption_3uses_before).T\n        energy_saved_3uses.dropna(inplace=True)\n\n        cost_insulation = self.prepare_cost_insulation(cost_insulation_raw * self.surface_insulation)\n        cost_insulation = cost_insulation.T.multiply(self._surface, level='Housing type').T\n\n        cost_insulation, tax_insulation, tax, subsidies_details, subsidies_total, condition, certificate_jump_all = self.apply_subsidies_insulation(\n            index, policies_insulation, cost_insulation, surface, certificate, certificate_before, certificate_before_heater, energy_saved_3uses)\n\n        if self._endogenous:\n\n            utility_subsidies = subsidies_total.copy()\n            zil = [p for p in policies_insulation if (p.name == 'zero_interest_loan')]\n            l = ['reduced_tax'] + [z.name for z in zil if z.policy != 'subsidy_ad_volarem']\n            for sub in l:\n                if sub in subsidies_details.keys():\n                    utility_subsidies -= subsidies_details[sub]\n\n            utility_zil = None\n            if 'zero_interest_loan' in subsidies_details:\n                if zil[0].policy != 'subsidy_ad_volarem':\n                    utility_zil = subsidies_details['zero_interest_loan'].copy()\n\n            delta_subsidies = None\n            if (self.year in [self.first_year + 1]) and (self.scale_ext is None):\n                delta_subsidies = subsidies_details['cite'].copy()\n\n            retrofit_rate, market_share = self.endogenous_retrofit(index, prices, utility_subsidies,\n                                                                   cost_insulation,\n                                                                   ms_insulation=ms_insulation,\n                                                                   renovation_rate_ini=renovation_rate_ini,\n                                                                   utility_zil=utility_zil,\n                                                                   stock=stock,\n                                                                   delta_subsidies=delta_subsidies,\n                                                                   target_freeriders=target_freeriders,\n                                                                   supply_constraint=supply_constraint,\n                                                                   financing_cost=financing_cost\n                                                                   )\n\n        else:\n            retrofit_rate, market_share = self.exogenous_retrofit(index, self._choice_insulation)\n\n        if self.detailed_mode:\n            self.store_information_insulation(certificate_jump_all, condition, cost_insulation_raw, tax, cost_insulation,\n                                              tax_insulation, subsidies_details, subsidies_total, retrofit_rate,\n                                              )\n        else:\n            self.subsidies_details_insulation = subsidies_details\n\n        return retrofit_rate, market_share\n\n    def apply_subsidies_insulation(self, index, policies_insulation, cost_insulation, surface, certificate, certificate_before,\n                                   certificate_before_heater, energy_saved_3uses):\n        \"\"\"Calculate subsidies amount for each possible insulation choice.\n\n        Parameters\n        ----------\n        policies_insulation: list\n        cost_insulation: DataFrame\n            Cost for each segment and each possible insulation choice (€).\n        surface: Series\n            Surface / dwelling for each segment (m2/dwelling).\n        certificate : DataFrame\n            Certificate by segment after insulation replacement for each possible insulation choice.\n        certificate_before : Series\n            Certificate by segment before insulation (but after heater replacement)\n        certificate_before_heater: Series\n            Certificate by segment before insulation, and before heater replacement. Useful to calculate the total\n            number of upgrade this year.\n        energy_saved_3uses: DataFrame\n            Primary conventional energy consumption saved by the insulation work (% - kWh PE/m2).\n\n        Returns\n        -------\n        cost_insulation: DataFrame\n        tax_insulation: DataFrame\n        tax : float\n        subsidies_details: dict\n        subsidies_total: DataFrame\n        condition: dict\n        certificate_jump_all: DataFrame\n        \"\"\"\n\n        def define_zil_target(certificate, certificate_before, energy_saved_3uses):\n            \"\"\"Define target.\n\n            zero_interest_loan_old is the target in terms of EPC jump.\n            zero_interest_loan_new is the requirement to be eligible to a 'global renovation' program,\n            the renovation must reduce of 35% the conventional primary energy need\n            and the resulting building must not be of G or F epc level.\n\n            Parameters\n            ----------\n            certificate\n            certificate_before\n            energy_saved_3uses\n\n            Returns\n            -------\n            target_subsidies: pd.DataFrame\n                Each cell, a gesture and a segment, is a boolean which is True if it is targeted by the policy\n\n            \"\"\"\n            energy_saved_min = 0.35\n\n            target_subsidies = {}\n            target_0 = certificate.isin(['D', 'C', 'B', 'A']).astype(int).mul(\n                certificate_before.isin(['G', 'F', 'E']).astype(int), axis=0).astype(bool)\n            target_1 = certificate.isin(['B', 'A']).astype(int).mul(certificate_before.isin(['D', 'C']).astype(int),\n                                                                    axis=0).astype(bool)\n            target_subsidies['zero_interest_loan_old'] = target_0 | target_1\n\n            target_0 = certificate.isin(['E', 'D', 'C', 'B', 'A']).astype(bool)\n            target_1 = energy_saved_3uses[energy_saved_3uses >= energy_saved_min].fillna(0).astype(bool)\n            target_subsidies['zero_interest_loan_new'] = target_0 & target_1\n\n            return target_subsidies\n\n        def defined_condition(index, certificate, certificate_before, certificate_before_heater, energy_saved_3uses):\n            \"\"\"Define condition to get subsidies or loan.\n\n            Depends on income (index) and energy performance of renovationd defined by certificate jump or\n            energy_saved_3uses.\n\n            Parameters\n            ----------\n            index: MultiIndex\n            certificate: DataFrame\n            certificate_before: Series\n            certificate_before_heater: Series\n            energy_saved_3uses: DataFrame\n\n            Returns\n            -------\n            condition: dict\n                Contains boolean DataFrame that established condition to get subsidies.\n            certificate_jump: DataFrame\n                Insulation (without account for heater replacement) allowed to jump of at least one certificate.\n            certificate_jump_all: DataFrame\n                Renovation (including heater replacement) allowed to jump of at least one certificate.\n            \"\"\"\n\n            condition = dict()\n\n            self.out_worst = (~certificate.isin(['G', 'F'])).T.multiply(certificate_before.isin(['G', 'F'])).T\n            self.out_worst = reindex_mi(self.out_worst, index).fillna(False).astype('float')\n            self.in_best = (certificate.isin(['A', 'B'])).T.multiply(~certificate_before.isin(['A', 'B'])).T\n            self.in_best = reindex_mi(self.in_best, index).fillna(False).astype('float')\n\n            condition.update({'bonus_worst': self.out_worst})\n            condition.update({'bonus_best': self.in_best})\n\n            minimum_gest_condition, global_condition = 1, 2\n            energy_condition = 0.35\n\n            certificate_jump = - certificate.replace(self._epc2int).sub(certificate_before.replace(self._epc2int),\n                                                                        axis=0)\n            certificate_jump = reindex_mi(certificate_jump, index)\n            certificate_jump_condition = certificate_jump >= minimum_gest_condition\n\n            certificate_before_heater = reindex_mi(certificate_before_heater, index)\n            certificate = reindex_mi(certificate, index)\n            certificate_jump_all = - certificate.replace(self._epc2int).sub(\n                certificate_before_heater.replace(self._epc2int),\n                axis=0)\n\n            condition.update({'certificate_jump': certificate_jump_all >= minimum_gest_condition})\n            condition.update({'global_renovation': certificate_jump_all >= global_condition})\n\n            low_income_condition = ['D1', 'D2', 'D3', 'D4']\n            if self.quintiles:\n                low_income_condition = ['C1', 'C2']\n            low_income_condition = index.get_level_values('Income owner').isin(low_income_condition)\n            low_income_condition = pd.Series(low_income_condition, index=index)\n\n            high_income_condition = ['D5', 'D6', 'D7', 'D8', 'D9', 'D10']\n            if self.quintiles:\n                high_income_condition = ['C3', 'C4', 'C5']\n            high_income_condition = index.get_level_values('Income owner').isin(high_income_condition)\n            high_income_condition = pd.Series(high_income_condition, index=index)\n\n            global_renovation_low_income = (low_income_condition * condition['global_renovation'].T).T\n            condition.update({'global_renovation_low_income': global_renovation_low_income})\n\n            global_renovation_high_income = (high_income_condition * condition['global_renovation'].T).T\n            condition.update({'global_renovation_high_income': global_renovation_high_income})\n\n            energy_condition = energy_saved_3uses >= energy_condition\n\n            condition_mpr_serenite = (reindex_mi(energy_condition, index).T * low_income_condition).T\n            condition.update({'mpr_serenite': condition_mpr_serenite})\n\n            condition_zil = define_zil_target(certificate, certificate_before, energy_saved_3uses)\n            condition.update({'zero_interest_loan': condition_zil})\n\n            return condition, certificate_jump, certificate_jump_all\n\n        subsidies_total = DataFrame(0, index=index, columns=cost_insulation.columns)\n        subsidies_details = {}\n\n        tax = self.vta\n        p = [p for p in policies_insulation if 'reduced_tax' == p.policy]\n        if p:\n            tax = p[0].value\n            subsidies_details.update({p[0].name: reindex_mi(cost_insulation * (self.vta - tax), index)})\n            subsidies_total += subsidies_details['reduced_tax']\n\n        tax_insulation = cost_insulation * tax\n        cost_insulation += tax_insulation\n\n        condition, certificate_jump, certificate_jump_all = defined_condition(index, certificate, certificate_before,\n                                                                              certificate_before_heater,\n                                                                              energy_saved_3uses)\n\n        for policy in policies_insulation:\n            if policy.name not in self.policies:\n                self.policies += [policy.name]\n\n            if policy.policy == 'subsidy_target':\n                temp = (reindex_mi(self.prepare_subsidy_insulation(policy.value),\n                                   index).T * surface).T\n                subsidies_total += temp\n\n                if policy.name in subsidies_details.keys():\n                    subsidies_details[policy.name] = subsidies_details[policy.name] + temp\n                else:\n                    subsidies_details[policy.name] = temp.copy()\n\n            elif policy.policy == 'bonus_best':\n                temp = (reindex_mi(policy.value, condition['bonus_best'].index) * condition['bonus_best'].T).T\n                subsidies_total += temp\n                if policy.name in subsidies_details.keys():\n                    subsidies_details[policy.name] = subsidies_details[policy.name] + temp\n\n                else:\n                    subsidies_details[policy.name] = temp.copy()\n\n            elif policy.policy == 'bonus_worst':\n                temp = (reindex_mi(policy.value, condition['bonus_worst'].index) * condition['bonus_worst'].T).T\n                subsidies_total += temp\n\n                if policy.name in subsidies_details.keys():\n                    subsidies_details[policy.name] = subsidies_details[policy.name] + temp\n\n                else:\n                    subsidies_details[policy.name] = temp.copy()\n\n            elif policy.policy == 'subsidy_ad_volarem':\n\n                cost = policy.cost_targeted(reindex_mi(cost_insulation, index), target_subsidies=condition.get(policy.name),\n                                            cost_included=self.cost_heater.copy())\n\n                if isinstance(policy.value, (Series, float)):\n                    temp = reindex_mi(policy.value, cost.index)\n                    subsidies_details[policy.name] = (temp * cost.T).T\n                    subsidies_total += subsidies_details[policy.name]\n                else:\n                    temp = self.prepare_subsidy_insulation(policy.value, policy=policy.policy)\n                    temp = reindex_mi(temp, cost.index)\n                    subsidies_details[policy.name] = temp * cost\n                    subsidies_total += subsidies_details[policy.name]\n                if policy.name == 'zero_interest_loan':\n                    self.zil_loaned = cost.copy()\n\n            elif policy.policy == 'zero_interest_loan':\n\n                cost = policy.cost_targeted(reindex_mi(cost_insulation, index), target_subsidies=condition.get(policy.name),\n                                            cost_included=self.cost_heater.copy())\n                subsidies_details[policy.name] = policy.value * cost\n                subsidies_total += subsidies_details[policy.name]\n                self.zil_loaned = cost.copy()\n\n        subsidies_non_cumulative = [p for p in policies_insulation if p.policy == 'subsidy_non_cumulative']\n        if subsidies_non_cumulative is not []:\n            for policy in subsidies_non_cumulative:\n                sub = (reindex_mi(policy.value, condition[policy.name].index) * condition[policy.name].T).T\n                sub = sub.astype(float)\n                for name in policy.non_cumulative:\n                    # TODO: could be a bug here when policy.non_cumulative are all there and when non cumulative alone\n                    if name in subsidies_details.keys():\n                        subsidies_total -= subsidies_details[name]\n                        comp = reindex_mi(subsidies_details[name], sub.index)\n                        temp = comp.where(comp > sub, 0)\n                        subsidies_details[name] = temp.copy()\n                        temp = sub.where(sub > comp, 0)\n                        subsidies_details[policy.name] = temp.copy()\n                        subsidies_total += subsidies_details[name] + subsidies_details[policy.name]\n\n        subsidies_cap = [p for p in policies_insulation if p.policy == 'subsidies_cap']\n        subsidies_uncaped = subsidies_total.copy()\n\n        if 'reduced_tax' in subsidies_details.keys():\n            subsidies_uncaped -= subsidies_details['reduced_tax']\n\n        zil = [p for p in policies_insulation if p.policy == 'subsidy_ad_volarem' and p.name == 'zero_interest_loan']\n        if 'zero_interest_loan' in subsidies_details.keys() and zil is []:\n            subsidies_uncaped -= subsidies_details['zero_interest_loan']\n\n        if subsidies_cap:\n            subsidies_cap = subsidies_cap[0]\n            subsidies_cap = reindex_mi(subsidies_cap.value, subsidies_uncaped.index)\n            cap = (reindex_mi(cost_insulation, index).T * subsidies_cap).T\n            over_cap = subsidies_uncaped > cap\n            subsidies_details['over_cap'] = (subsidies_uncaped - cap)[over_cap].fillna(0)\n            remaining = subsidies_details['over_cap'].copy()\n            if 'mpr_serenite' in subsidies_details.keys():\n                temp = subsidies_details['over_cap'].where(\n                    subsidies_details['over_cap'] <= subsidies_details['mpr_serenite'],\n                    subsidies_details['mpr_serenite'])\n                subsidies_details['mpr_serenite'] -= temp\n                remaining = subsidies_details['over_cap'] - temp\n                assert (subsidies_details['mpr_serenite'].values >= 0).all(), 'MPR Serenite got negative values'\n            if 'mpr' in subsidies_details.keys() and not (remaining > 0).any().any():\n                subsidies_details['mpr'] -= remaining\n                assert (subsidies_details['mpr'].values >= 0).all(), 'MPR got negative values'\n\n            subsidies_total -= subsidies_details['over_cap']\n\n        return cost_insulation, tax_insulation, tax, subsidies_details, subsidies_total, condition, certificate_jump_all\n\n    def store_information_insulation(self, certificate_jump_all, condition, cost_insulation_raw, tax, cost_insulation,\n                                     tax_insulation, subsidies_details, subsidies_total, retrofit_rate):\n\n        \"\"\"Store insulation information.\n\n        Parameters\n        ----------\n        condition: dict\n        cost_insulation_raw: Series\n            Cost of insulation for each envelope component of losses surface (€/m2).\n        tax: float\n            VTA to apply (%).\n        cost_insulation: DataFrame\n            Cost insulation for each dwelling and each insulation gesture (€).\n        tax_insulation: DataFrame\n            VTA applied to each insulation gesture cost (€).\n        subsidies_details: dict\n            Amount of subsidies for each dwelling and each insulation gesture (€).\n        subsidies_total: DataFrame\n            Total mount of subsidies for each dwelling and each insulation gesture (€).\n        retrofit_rate: Series\n        \"\"\"\n\n        # self.certificate_jump = condition['certificate_jump']\n        self.certificate_jump_all = certificate_jump_all\n        self.global_renovation = condition['global_renovation']\n        self.global_renovation_high_income = condition['global_renovation_high_income']\n        self.global_renovation_low_income = condition['global_renovation_low_income']\n        self.cost_component = cost_insulation_raw * self.surface_insulation * (1 + tax)\n        self.subsidies_details_insulation = subsidies_details\n        self.subsidies_insulation_indiv = subsidies_total\n        self.cost_insulation_indiv = cost_insulation\n        self.tax_insulation = tax_insulation\n        self.retrofit_rate = retrofit_rate\n\n    def store_information_retrofit(self, replaced_by):\n        \"\"\"Calculate and store main outputs based on yearly retrofit.\n\n        Parameters\n        ----------\n        replaced_by: DataFrame\n            Retrofitting for each dwelling and each insulation gesture.\n        \"\"\"\n\n        levels = [i for i in replaced_by.index.names if i not in ['Heater replacement', 'Heating system final']]\n        self.global_renovation_high_income = (replaced_by * self.global_renovation_high_income).sum().sum()\n        self.global_renovation_low_income = (replaced_by * self.global_renovation_low_income).sum().sum()\n        self.bonus_best = (replaced_by * self.in_best).sum().sum()\n        self.bonus_worst = (replaced_by * self.out_worst).sum().sum()\n        self.replacement_insulation = replaced_by.groupby(levels).sum()\n        self.investment_insulation = (replaced_by * self.cost_insulation_indiv).groupby(levels).sum()\n        self.taxed_insulation = (replaced_by * self.tax_insulation).groupby(levels).sum()\n        self.subsidies_insulation = (replaced_by * self.subsidies_insulation_indiv).groupby(levels).sum()\n\n        for key in self.subsidies_details_insulation.keys():\n            self.subsidies_details_insulation[key] = (replaced_by * reindex_mi(\n                self.subsidies_details_insulation[key], replaced_by.index)).groupby(levels).sum()\n\n        rslt = {}\n        l = unique(self.certificate_jump_all.values.ravel('K'))\n        for i in l:\n            rslt.update({i: ((self.certificate_jump_all == i) * replaced_by).sum(axis=1)})\n        self.certificate_jump_all = DataFrame(rslt).groupby(levels).sum()\n\n        gest = {1: [(False, False, False, True), (False, False, True, False), (False, True, False, False),\n                    (True, False, False, False)],\n                2: [(False, False, True, True), (False, True, False, True), (True, False, False, True),\n                    (True, False, True, False),\n                    (True, True, False, False), (False, True, True, False)],\n                3: [(False, True, True, True), (True, False, True, True), (True, True, False, True),\n                    (True, True, True, False)],\n                4: [(True, True, True, True)]}\n        rslt = {i: 0 for i in range(1, 6)}\n        for n, g in gest.items():\n            rslt[n] += replaced_by.loc[:, g].xs(False, level='Heater replacement').sum().sum()\n            rslt[n + 1] += replaced_by.loc[:, g].xs(True, level='Heater replacement').sum().sum()\n        self.gest_nb = Series(rslt)\n\n        self.retrofit_with_heater = replaced_by.xs(True, level='Heater replacement').sum().sum()\n\n        for key, sub in self.subsidies_details_insulation.items():\n            mask = sub.copy()\n            mask[mask > 0] = 1\n            self.subsidies_count_insulation.update({key: (replaced_by.fillna(0) * mask).sum().sum()})\n            self.subsidies_average_insulation.update({key: sub.sum().sum() / replaced_by.fillna(0).sum().sum()})\n\n            if key == 'zero_interest_loan':\n                total_loaned = (replaced_by.fillna(0) * self.zil_loaned).sum().sum()\n                self.zil_loaned_avg = total_loaned / self.zil_count\n\n    def prepare_cost_insulation(self, cost_insulation):\n        \"\"\"Constitute insulation choice set cost. Cost is equal to the sum of each individual cost component.\n\n        Parameters\n        ----------\n        cost_insulation: Series\n\n        Returns\n        -------\n        Series\n            Multiindex series. Levels are Wall, Floor, Roof and Windows and values are boolean.\n        \"\"\"\n        if self.prepared_cost_insulation is None:\n            cost = DataFrame(0, index=cost_insulation.index, columns=self._choice_insulation)\n            idx = IndexSlice\n            cost.loc[:, idx[True, :, :, :]] = (cost.loc[:, idx[True, :, :, :]].T + cost_insulation['Wall']).T\n            cost.loc[:, idx[:, True, :, :]] = (cost.loc[:, idx[:, True, :, :]].T + cost_insulation['Floor']).T\n            cost.loc[:, idx[:, :, True, :]] = (cost.loc[:, idx[:, :, True, :]].T + cost_insulation['Roof']).T\n            cost.loc[:, idx[:, :, :, True]] = (cost.loc[:, idx[:, :, :, True]].T + cost_insulation['Windows']).T\n            self.prepared_cost_insulation = cost.copy()\n            return cost\n        else:\n            # to reduce run time but doesn't seem to be very useful\n            return self.prepared_cost_insulation\n\n    def prepare_subsidy_insulation(self, subsidies_insulation, policy=None):\n        \"\"\"Constitute insulation choice set subsidies. Subsidies are equal to the sum of each individual subsidy.\n\n        Parameters\n        ----------\n        subsidies_insulation: DataFrame\n\n        Returns\n        -------\n        DataFrame\n            Multiindex columns. Levels are Wall, Floor, Roof and Windows and values are boolean.\n        \"\"\"\n\n        idx = IndexSlice\n        subsidies = {}\n        for i in self.surface_insulation.index:\n            subsidy = DataFrame(0, index=subsidies_insulation.index, columns=self._choice_insulation)\n            subsidy.loc[:, idx[True, :, :, :]] = subsidy.loc[:, idx[True, :, :, :]].add(\n                subsidies_insulation['Wall'] * self.surface_insulation.loc[i, 'Wall'], axis=0)\n            subsidy.loc[:, idx[:, True, :, :]] = subsidy.loc[:, idx[:, True, :, :]].add(\n                subsidies_insulation['Floor'] * self.surface_insulation.loc[i, 'Floor'], axis=0)\n            subsidy.loc[:, idx[:, :, True, :]] = subsidy.loc[:, idx[:, :, True, :]].add(\n                subsidies_insulation['Roof'] * self.surface_insulation.loc[i, 'Roof'], axis=0)\n            subsidy.loc[:, idx[:, :, :, True]] = subsidy.loc[:, idx[:, :, :, True]].add(\n                subsidies_insulation['Windows'] * self.surface_insulation.loc[i, 'Windows'], axis=0)\n            subsidies[i] = subsidy.copy()\n        subsidies = concat(list(subsidies.values()), axis=0, keys=self.surface_insulation.index,\n                           names=self.surface_insulation.index.names)\n\n        if policy == 'subsidy_ad_volarem':\n            # NotImplemented: ad_volarem with different subsidides rate\n            value = [v for v in subsidies_insulation.stack().unique() if v != 0][0]\n            subsidies[subsidies > 0] = value\n\n        return subsidies\n\n    def endogenous_retrofit(self, index, prices, subsidies_total, cost_insulation, ms_insulation=None,\n                            renovation_rate_ini=None, utility_zil=None, stock=None, supply_constraint=False,\n                            delta_subsidies=None, target_freeriders=0.85, financing_cost=None):\n        \"\"\"Calculate endogenous retrofit based on discrete choice model.\n\n        Utility variables are investment cost, energy bill saving, and subsidies.\n        Preferences are object attributes defined initially.\n\n        # bill saved calculated based on the new heating system\n        # certificate before work and so subsidies before the new heating system\n\n        Parameters\n        ----------\n        index: MultiIndex\n        prices: Series\n        subsidies_total: DataFrame\n        cost_insulation: DataFrame\n        ms_insulation: Series, default None\n        renovation_rate_ini: Series, default None\n        utility_zil: DataFrame, default None\n        stock: Series, default None\n        supply_constraint: bool\n        delta_subsidies: DataFrame, default None\n        target_freeriders: float, default 0.85\n\n        Returns\n        -------\n        Series\n            Retrofit rate\n        DataFrame\n            Market-share insulation\n        \"\"\"\n\n        def to_market_share(bill_saved, subsidies, investment, utility_zil=utility_zil, scale=1.0):\n\n            pref_subsidies = reindex_mi(self.pref_subsidy_insulation_int, subsidies.index).rename(None)\n            utility_subsidies = (subsidies.T * pref_subsidies).T / 1000\n\n            pref_investment = reindex_mi(self.pref_investment_insulation_int, investment.index).rename(None)\n            utility_investment = (investment.T * pref_investment).T / 1000\n\n            utility_bill_saving = (bill_saved.T * reindex_mi(self.pref_bill_insulation_int, bill_saved.index)).T / 1000\n\n            utility_intensive = utility_bill_saving + utility_investment + utility_subsidies\n\n            if utility_zil is not None:\n                utility_zil[utility_zil > 0] = self.pref_zil_int\n                utility_intensive += utility_zil\n\n            if self.constant_insulation_intensive is not None:\n                # constant = reindex_mi(self.constant_insulation_intensive, utility_intensive.index)\n                utility_intensive += self.constant_insulation_intensive\n\n            # removing floor and roof insulation for multi-family\n            if False:\n                cond1 = utility_intensive.index.get_level_values('Housing type') == 'Multi-family'\n                cond2 = (utility_intensive.columns.get_level_values('Floor') == True) | (utility_intensive.columns.get_level_values('Roof') == True)\n                utility_intensive.loc[cond1, cond2] = float('nan')\n\n            market_share = (exp(scale * utility_intensive).T / exp(scale * utility_intensive).sum(axis=1)).T\n            return market_share, utility_intensive\n\n        def retrofit_func(utility, rate_max=1.0):\n            return 1 / (1 + exp(- utility)) * rate_max\n\n        def to_retrofit_rate(bill_saved, subsidies, investment, bool_zil=None, debug_mode=self._debug_mode):\n            utility_bill_saving = reindex_mi(self.pref_bill_insulation_ext, bill_saved.index) * bill_saved / 1000\n\n            pref_subsidies = reindex_mi(self.pref_subsidy_insulation_ext, subsidies.index).rename(None)\n            utility_subsidies = (pref_subsidies * subsidies) / 1000\n\n            pref_investment = reindex_mi(self.pref_investment_insulation_ext, investment.index).rename(None)\n            utility_investment = (pref_investment * investment) / 1000\n\n            utility = utility_investment + utility_bill_saving + utility_subsidies\n\n            if bool_zil is not None:\n                utility_zil = bool_zil * self.pref_zil_ext\n                utility += utility_zil\n\n            if self.constant_insulation_extensive is not None:\n                _utility = self.add_certificate(utility.copy())\n                utility_constant = reindex_mi(self.constant_insulation_extensive, _utility.index)\n                _utility += utility_constant\n                utility = _utility.droplevel('Performance')\n\n            retrofit_rate = retrofit_func(utility)\n\n            if debug_mode and self.constant_insulation_extensive is not None:\n                levels = [l for l in self.constant_insulation_extensive.index.names if l != 'Performance']\n                df = concat((utility_investment.groupby(levels).mean(),\n                                utility_subsidies.groupby(levels).mean(),\n                                utility_bill_saving.groupby(levels).mean(),\n                                self.constant_insulation_extensive.groupby(levels).mean()), axis=1,\n                               keys=['Investment', 'Subsidies', 'Saving', 'Constant'])\n\n                if bool_zil is not None:\n                    zil_mean = utility_zil.groupby(levels).mean().rename('ZIL')\n                    df = concat((df, zil_mean), axis=1)\n\n            return retrofit_rate, utility\n\n        def impact_subsidies(scale, utility, stock, delta_subsidies, pref_subsidies, indicator='freeriders'):\n            \"\"\"Calculate freeriders due to implementation of subsidy.\n\n            Parameters\n            ----------\n            scale: int\n            utility: Series\n            stock: Series\n            delta_subsidies: Series\n            pref_subsidies: Series\n            indicator: {'freeriders', 'elasticity'}\n\n            Returns\n            -------\n            float\n            \"\"\"\n\n            retrofit = retrofit_func(utility * scale)\n            flow = (retrofit * stock).sum()\n            retrofit = flow / stock.sum()\n\n            utility_plus = (utility + pref_subsidies * delta_subsidies).dropna() * scale\n            retrofit_plus = retrofit_func(utility_plus)\n            flow_plus = (retrofit_plus * stock).sum()\n            retrofit_plus = flow_plus / stock.sum()\n\n            if indicator == 'elasticity':\n                return (retrofit_plus - retrofit) / retrofit\n\n            if indicator == 'freeriders':\n                return min(flow, flow_plus) / max(flow, flow_plus)\n\n        def calibration_intensive_fsolve(utility, stock, ms_insulation, retrofit_rate_ini):\n            def solve(constant, utility_ref, ms_insulation, flow_retrofit):\n                # constant = append(0, constant)\n                constant = Series(constant, index=utility_ref.columns)\n                constant.iloc[0] = 0\n                utility = utility_ref + constant\n                market_share = (exp(utility).T / exp(utility).sum(axis=1)).T\n                agg = (market_share.T * flow_retrofit).T\n                market_share_agg = (agg.sum() / agg.sum().sum()).reindex(ms_insulation.index)\n\n                if (market_share_agg.round(decimals=2) == ms_insulation.round(decimals=2)).all():\n                    return zeros(ms_insulation.shape[0])\n                else:\n                    return market_share_agg - ms_insulation\n\n            if 'Performance' in retrofit_rate_ini.index.names:\n                levels = [l for l in retrofit_rate_ini.index.names if l != 'Performance']\n                certificate = self.certificate.rename('Performance').groupby(\n                    [l for l in self.stock.index.names if l != 'Income tenant']).first()\n                certificate = reindex_mi(certificate, stock.index)\n                stock = concat((stock, certificate), axis=1).set_index('Performance', append=True).squeeze()\n                retrofit_rate_simple = (stock * reindex_mi(retrofit_rate_ini, stock.index)).groupby(\n                    levels).sum() / stock.groupby(levels).sum()\n            else:\n                retrofit_rate_simple = retrofit_rate_ini\n\n            probability_replacement = self._probability_replacement\n            if isinstance(probability_replacement, Series):\n                probability_replacement.index = probability_replacement.index.rename('Heating system')\n                probability_replacement = reindex_mi(probability_replacement, self._stock.index)\n\n            stock = concat((self.stock * probability_replacement,\n                               self.stock * (1 - probability_replacement)), axis=0, keys=[True, False],\n                              names=['Heater replacement'])\n            stock_single = stock.xs('Single-family', level='Housing type', drop_level=False)\n\n            flow_retrofit = stock_single * reindex_mi(retrofit_rate_simple, stock_single.index)\n\n            utility = utility.groupby([i for i in utility.index.names if i != 'Heating system final']).mean()\n            utility_ref = reindex_mi(utility, flow_retrofit.index).dropna()\n            flow_retrofit = flow_retrofit.reindex(utility_ref.index)\n\n            x0 = zeros(ms_insulation.shape[0])\n            constant = fsolve(solve, x0, args=(utility_ref, ms_insulation, flow_retrofit))\n            constant = Series(constant, index=utility_ref.columns)\n\n            utility = utility_ref + constant\n            market_share = (exp(utility).T / exp(utility).sum(axis=1)).T\n            agg = (market_share.T * flow_retrofit).T\n            market_share_agg = (agg.sum() / agg.sum().sum()).reindex(ms_insulation.index)\n            details = concat((constant, market_share_agg, ms_insulation), axis=1,\n                                keys=['constant', 'calcul', 'observed']).round(decimals=3)\n            if self.path is not None:\n                details.to_csv(os.path.join(self.path_calibration, 'calibration_constant_insulation.csv'))\n            return constant\n\n        def calibration_intensive_iteration(utility, stock, ms_insulation, retrofit_rate_ini, iteration=100,\n                                            all=True):\n            \"\"\"Calibrate alternative-specific constant to match observed market-share.\n\n            Parameters\n            ----------\n            utility: Series\n            ms_insulation: Series\n                Observed market-share.\n            retrofit_rate_ini: Series\n                Observed renovation rate.\n\n            Returns\n            -------\n            Series\n            \"\"\"\n\n            if 'Performance' in retrofit_rate_ini.index.names:\n                stock = self.add_certificate(stock)\n\n            if all:\n                flow_retrofit = stock * reindex_mi(retrofit_rate_ini, stock.index)\n                utility_ref = reindex_mi(utility, flow_retrofit.index).dropna()\n                constant = ms_insulation.reindex(utility_ref.columns, axis=0).copy()\n                constant[constant > 0] = 0\n                market_share_ini, market_share_agg = None, None\n                for i in range(iteration):\n                    _utility = (utility_ref + constant).copy()\n                    constant.iloc[0] = 0\n                    market_share = (exp(_utility).T / exp(_utility).sum(axis=1)).T\n                    agg = (market_share.T * flow_retrofit).T\n                    market_share_agg = (agg.sum() / agg.sum().sum()).reindex(ms_insulation.index)\n                    if i == 0:\n                        market_share_ini = market_share_agg.copy()\n                    constant = constant + log(ms_insulation / market_share_agg)\n\n                    if (market_share_agg.round(decimals=2) == ms_insulation.round(decimals=2)).all():\n                        self.logger.debug('Constant intensive optim worked')\n                        break\n\n                constant.iloc[0] = 0\n                nb_renovation = (stock * reindex_mi(retrofit_rate_ini, stock.index)).sum()\n                details = concat((constant, market_share_ini, market_share_agg, ms_insulation, (ms_insulation * nb_renovation) / 10**3), axis=1,\n                                 keys=['constant', 'calcul ini', 'calcul', 'observed', 'thousand']).round(decimals=3)\n                if self.path is not None:\n                    details.to_csv(os.path.join(self.path_calibration, 'calibration_constant_insulation.csv'))\n\n                return constant\n\n            else:\n                # single-family\n                stock_single = stock.xs('Single-family', level='Housing type', drop_level=False)\n                flow_retrofit = stock_single * reindex_mi(retrofit_rate_ini, stock_single.index)\n\n                utility_ref = reindex_mi(utility, flow_retrofit.index).dropna()\n\n                constant = ms_insulation.reindex(utility_ref.columns, axis=0).copy()\n                constant[constant > 0] = 0\n                market_share_ini, market_share_agg = None, None\n                for i in range(iteration):\n                    _utility = (utility_ref + constant).copy()\n                    constant.iloc[0] = 0\n                    market_share = (exp(_utility).T / exp(_utility).sum(axis=1)).T\n                    agg = (market_share.T * flow_retrofit).T\n                    market_share_agg = (agg.sum() / agg.sum().sum()).reindex(ms_insulation.index)\n                    if i == 0:\n                        market_share_ini = market_share_agg.copy()\n                    constant = constant + log(ms_insulation / market_share_agg)\n\n                    if (market_share_agg.round(decimals=2) == ms_insulation.round(decimals=2)).all():\n                        self.logger.debug('Constant intensive optim worked')\n                        break\n\n                constant.iloc[0] = 0\n                details = concat((constant, market_share_ini, market_share_agg, ms_insulation), axis=1,\n                                    keys=['constant', 'calcul ini', 'calcul', 'observed']).round(decimals=3)\n                if self.path is not None:\n                    details.to_csv(os.path.join(self.path_calibration, 'calibration_constant_insulation_single.csv'))\n                constant_insulation = constant.rename('Single-family')\n\n                # multi-family\n                ms_insulation = ms_insulation.xs(False, level='Floor', drop_level=False).xs(False, level='Roof', drop_level=False)\n                ms_insulation = ms_insulation / ms_insulation.sum()\n\n                stock_multi = stock.xs('Multi-family', level='Housing type', drop_level=False)\n                flow_retrofit = stock_multi * reindex_mi(retrofit_rate_ini, stock_multi.index)\n\n                utility_ref = reindex_mi(utility, flow_retrofit.index).dropna(how='all', axis=0).dropna(how='all', axis=1)\n\n                constant = ms_insulation.reindex(utility_ref.columns, axis=0).copy()\n                constant[constant > 0] = 0\n                market_share_ini, market_share_agg = None, None\n                for i in range(iteration):\n                    _utility = (utility_ref + constant).copy()\n                    constant.iloc[0] = 0\n                    market_share = (exp(_utility).T / exp(_utility).sum(axis=1)).T\n                    agg = (market_share.T * flow_retrofit).T\n                    market_share_agg = (agg.sum() / agg.sum().sum()).reindex(ms_insulation.index)\n                    if i == 0:\n                        market_share_ini = market_share_agg.copy()\n                    constant = constant + log(ms_insulation / market_share_agg)\n\n                    if (market_share_agg.round(decimals=2) == ms_insulation.round(decimals=2)).all():\n                        self.logger.debug('Constant intensive optim worked')\n                        break\n\n                constant.iloc[0] = 0\n                details = concat((constant, market_share_ini, market_share_agg, ms_insulation), axis=1,\n                                    keys=['constant', 'calcul ini', 'calcul', 'observed']).round(decimals=3)\n                if self.path is not None:\n                    details.to_csv(os.path.join(self.path_calibration, 'calibration_constant_insulation_multi.csv'))\n                constant = constant.rename('Multi-family')\n\n                constant = concat((constant_insulation, constant), axis=1).T\n                constant.index.names = ['Housing type']\n                return constant\n\n        def calibration_intensive(utility, stock, ms_insulation, retrofit_rate_ini, solver='iteration'):\n            if solver == 'iteration':\n                return calibration_intensive_iteration(utility, stock, ms_insulation, retrofit_rate_ini)\n            elif solver == 'fsolve':\n                return calibration_intensive_fsolve(utility, stock, ms_insulation, retrofit_rate_ini)\n\n        def calibration_constant_scale_ext(utility, stock, retrofit_rate_ini, target_freeriders, delta_subsidies,\n                                           pref_subsidies):\n            \"\"\"Simultaneously calibrate constant and scale to match freeriders and retrofit rate.\n\n            Parameters\n            ----------\n            utility\n            stock\n            retrofit_rate_ini\n            target_freeriders\n            delta_subsidies\n            pref_subsidies\n\n            Returns\n            -------\n\n            \"\"\"\n\n            def solve(x, utility_ini, stock_ini, retrofit_rate_target, freeride, delta_sub, pref_sub):\n                scale = x[-1]\n                cst = x[:-1]\n\n                # calibration constant\n                cst = Series(cst, index=retrofit_rate_target.index)\n                utility_ref = utility_ini.copy()\n                stock_ref = stock_ini.copy()\n                utility_cst = reindex_mi(cst, utility_ref.index)\n                u = (utility_ref + utility_cst).copy()\n                retrofit_rate_calc = retrofit_func(u * scale)\n                agg = (retrofit_rate_calc * stock_ref).groupby(retrofit_rate_target.index.names).sum()\n                retrofit_rate_agg = agg / stock_ref.groupby(retrofit_rate_target.index.names).sum()\n                rslt = retrofit_rate_agg - retrofit_rate_target\n\n                # calibration scale\n                calcul = impact_subsidies(scale, u, stock_ini, delta_sub, pref_sub, indicator='freeriders')\n                rslt = append(rslt, calcul - freeride)\n\n                return rslt\n\n            def solve_noscale(x, utility_ini, stock_ini, retrofit_rate_target):\n\n                # calibration constant\n                cst = Series(x, index=retrofit_rate_target.index)\n                utility_ref = utility_ini.copy()\n                stock_ref = stock_ini.copy()\n                utility_cst = reindex_mi(cst, utility_ref.index)\n                u = (utility_ref + utility_cst).copy()\n                retrofit_rate_calc = retrofit_func(u)\n                agg = (retrofit_rate_calc * stock_ref).groupby(retrofit_rate_target.index.names).sum()\n                retrofit_rate_agg = agg / stock_ref.groupby(retrofit_rate_target.index.names).sum()\n                rslt = retrofit_rate_agg - retrofit_rate_target\n\n                return rslt\n\n            if 'Performance' in retrofit_rate_ini.index.names:\n                stock = self.add_certificate(stock)\n                stock_retrofit = stock[stock.index.get_level_values('Performance') > 'B']\n                utility = self.add_certificate(utility)\n            else:\n                stock_retrofit = stock\n\n            constant = retrofit_rate_ini.copy()\n            constant[retrofit_rate_ini > 0] = 0\n            a = stock.groupby(retrofit_rate_ini.index.names).mean()\n            b = utility.groupby(retrofit_rate_ini.index.names).mean()\n            pd.concat((retrofit_rate_ini, a, b), axis=1)\n            if self._calib_scale:\n                x = append(constant.to_numpy(), 1)\n                root, infodict, ier, mess = fsolve(solve, x, args=(\n                utility, stock_retrofit, retrofit_rate_ini, target_freeriders, - delta_subsidies / 1000, pref_subsidies),\n                              full_output=True)\n                self.logger.info(mess)\n                scale = root[-1]\n                self.logger.info('Scale: {}'.format(scale))\n                constant = Series(root[:-1], index=retrofit_rate_ini.index) * scale\n            else:\n                x = constant.to_numpy()\n                root, infodict, _, _ = fsolve(solve_noscale, x, args=(utility, stock_retrofit, retrofit_rate_ini),\n                                              full_output=True)\n                scale = 1.0\n                constant = Series(root, index=retrofit_rate_ini.index) * scale\n\n            utility_constant = reindex_mi(constant, utility.index)\n            utility = utility * scale + utility_constant\n            retrofit_rate = retrofit_func(utility)\n            agg = (retrofit_rate * stock).groupby(retrofit_rate_ini.index.names).sum()\n            retrofit_rate_agg = agg / stock.groupby(retrofit_rate_ini.index.names).sum()\n\n            details = concat((constant, retrofit_rate_agg, retrofit_rate_ini, agg / 10 ** 3), axis=1,\n                                keys=['constant', 'calcul', 'observed', 'thousand']).round(decimals=3)\n            if self.path is not None:\n                details.to_csv(os.path.join(self.path_calibration, 'calibration_constant_extensive.csv'))\n\n            return constant, scale\n\n        def calculation_intensive_margin(stock, retrofit_rate_ini, bill_saved, subsidies_total, cost_insulation,\n                                         delta_subsidies, target_invest=0.2, utility_zil=utility_zil):\n            \"\"\" This function can be adapted to calibrate intensive margin on Risch 2020 result. (using target_invest)\n            However, for now just returns percentage of intesive margin difference\n\n            Parameters\n            ----------\n            stock\n            retrofit_rate_ini\n            bill_saved: DataFrame\n            subsidies_total: DataFrame\n            cost_insulation: DataFrame\n            delta_subsidies: DataFrame, policies used to calibrate the scale.\n            target_invest: float\n            utility_zil\n\n            Returns\n            -------\n\n            \"\"\"\n            if 'Performance' in retrofit_rate_ini.index.names:\n                stock = self.add_certificate(stock)\n            flow_retrofit = stock * reindex_mi(retrofit_rate_ini, stock.index)\n            flow_retrofit = flow_retrofit.droplevel('Performance').dropna()\n\n            def solve(scale, flow_retrofit, bill_saved, subsidies_total, cost_insulation, delta_subsidies,\n                      target_invest, utility_zil):\n                scale = float(scale)\n                ms_before, _ = to_market_share(bill_saved, subsidies_total, cost_insulation,\n                                               utility_zil=utility_zil, scale=scale)\n                investment_insulation_before = (cost_insulation.reindex(ms_before.index) * ms_before).sum(axis=1)\n                investment_insulation_before = (investment_insulation_before * flow_retrofit).sum() / flow_retrofit.sum()\n                new_sub = subsidies_total + delta_subsidies\n                ms_after, _ = to_market_share(bill_saved, new_sub, cost_insulation, utility_zil=utility_zil,\n                                              scale=scale)\n                investment_insulation_after = (cost_insulation.reindex(ms_after.index) * ms_after).sum(axis=1)\n                investment_insulation_after = (investment_insulation_after * flow_retrofit).sum() / flow_retrofit.sum()\n\n                delta_invest = (\n                                       investment_insulation_before - investment_insulation_after) / investment_insulation_before\n                return delta_invest - target_invest\n\n            x0 = ones(1)\n\n            \"\"\"scale = fsolve(solve, x0, args=(\n                flow_retrofit, bill_saved, subsidies_total, cost_insulation, -delta_subsidies,\n                target_invest, utility_zil))\"\"\"\n\n            return solve(1, flow_retrofit, bill_saved, subsidies_total, cost_insulation, -0.5 * delta_subsidies,\n                         target_invest, utility_zil) + target_invest\n\n        def supply_interaction(retrofit_rate, stock, investment_insulation):\n            \"\"\"NOT IMPLEMENTED YET.\n\n            Parameters\n            ----------\n            retrofit_rate\n            stock\n            investment_insulation\n\n            Returns\n            -------\n\n            \"\"\"\n            market_size = (retrofit_rate * stock * investment_insulation).sum()\n            etp_size = self.factor_etp * market_size\n\n            if self.param_supply is None:\n\n                self.capacity_utilization = etp_size / 0.8\n                self.param_supply = dict()\n                self.param_supply['a'], self.param_supply['b'], self.param_supply['c'] = self.calibration_supply()\n\n                x = arange(0, 1.05, 0.05)\n                y = self.factor_function(self.param_supply['a'], self.param_supply['b'], self.param_supply['c'], x)\n                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                ax.plot(x, y, color='black')\n                format_ax(ax, y_label='Cost factor')\n                ax.set_xlabel('Utilization rate (%)')\n                save_fig(fig, save=os.path.join(self.path_calibration, 'marginal_cost_curve.png'))\n\n                x, y_supply, y_demand = [], [], []\n                for factor in arange(0.81, 1.5, 0.05):\n                    retrofit_rate = to_retrofit_rate(bill_saved_insulation, subsidies_insulation,\n                                                     investment_insulation * factor)[0]\n                    y_demand.append((retrofit_rate * stock * investment_insulation * self.factor_etp).sum())\n                    utilization_rate = self.supply_function(self.param_supply['a'], self.param_supply['b'],\n                                                            self.param_supply['c'], factor)\n                    y_supply.append(utilization_rate * self.capacity_utilization)\n                    x.append(factor)\n\n                df = concat((Series(x), Series(y_supply)/10**3, Series(y_demand)/10**3,),\n                               axis=1).set_axis(['Cost factor', 'Supply', 'Demand'], axis=1)\n\n                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                df.plot(ax=ax, x='Cost factor', color={'Supply': 'darkorange', 'Demand': 'royalblue'})\n                format_ax(ax, y_label='Quantity (thousands of jobs)', format_y=lambda y, _: '{:.0f}'.format(y))\n                format_legend(ax)\n                save_fig(fig, save=os.path.join(self.path_calibration, 'supply_demand_inverse.png'))\n\n                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                df.plot(ax=ax, x='Supply', y='Cost factor', color='darkorange')\n                df.plot(ax=ax, x='Demand', y='Cost factor', color='royalblue')\n                format_ax(ax, y_label='Cost factor', format_y=lambda y, _: '{:.1f}'.format(y))\n                ax.set_xlabel('Quantity (thousands of jobs)')\n                format_legend(ax, labels=['Supply', 'Demand'])\n                save_fig(fig, save=os.path.join(self.path_calibration, 'supply_demand.png'))\n\n            def solve_equilibrium(factor, bill_saved_insulation, subsidies_insulation, investment_insulation, stock):\n                retrofit_rate = to_retrofit_rate(bill_saved_insulation, subsidies_insulation,\n                                                 investment_insulation * factor)[0]\n                demand = (retrofit_rate * stock * investment_insulation * self.factor_etp).sum()\n                offer = self.supply_function(self.param_supply['a'], self.param_supply['b'],\n                                             self.param_supply['c'], factor) * self.capacity_utilization\n                return demand - offer\n\n            factor_equilibrium = fsolve(solve_equilibrium, array([1]), args=(\n            bill_saved_insulation, subsidies_insulation, investment_insulation, stock))\n\n            retrofit_rate = to_retrofit_rate(bill_saved_insulation, subsidies_insulation,\n                                             investment_insulation * factor_equilibrium)[0]\n\n            self.factor = factor_equilibrium\n            if self._debug_mode:\n                self.factor_yrs.update({self.year: factor_equilibrium})\n            return retrofit_rate\n\n        cost_insulation = reindex_mi(cost_insulation, index)\n        cost_total = cost_insulation.copy()\n        if financing_cost is not None and self.financing_cost:\n            share_debt = financing_cost['share_debt'][0] + cost_insulation * financing_cost['share_debt'][1]\n            cost_debt = financing_cost['interest_rate'] * share_debt * cost_insulation * financing_cost['duration']\n            cost_saving = (financing_cost['saving_rate'] * reindex_mi(financing_cost['factor_saving_rate'], cost_insulation.index) * ((1 - share_debt) * cost_insulation).T).T * financing_cost['duration']\n            cost_financing = cost_debt + cost_saving\n\n            cost_total += cost_financing\n\n        consumption_before = self.consumption_standard(index, level_heater='Heating system final')[0]\n        consumption_before = reindex_mi(consumption_before, index) * reindex_mi(self._surface, index)\n        energy_bill_before = AgentBuildings.energy_bill(prices, consumption_before, level_heater='Heating system final')\n\n        consumption_sd = self.prepare_consumption(self._choice_insulation, index=index,\n                                                  level_heater='Heating system final')[0]\n        consumption_sd = reindex_mi(consumption_sd, index).reindex(self._choice_insulation, axis=1)\n\n        energy = pd.Series(index.get_level_values('Heating system final'), index=index).str.split('-').str[0].rename('Energy')\n        energy_prices = prices.reindex(energy).set_axis(index)\n        energy_bill_sd = (consumption_sd.T * energy_prices * reindex_mi(self._surface, index)).T\n        bill_saved = - energy_bill_sd.sub(energy_bill_before, axis=0).dropna()\n\n        # idx = (False, True, 'Owner-occupied', 'D1', 'Multi-family', 'Electricity-Performance boiler', 0.5,  0.2, 0.1, 1.6, 'Electricity-Performance boiler')\n\n        market_share, utility_intensive = to_market_share(bill_saved, subsidies_total, cost_total,\n                                                          utility_zil=utility_zil)\n\n        if self.constant_insulation_intensive is None:\n            self.logger.info('Calibration intensive')\n            self.constant_insulation_intensive = calibration_intensive(utility_intensive, stock, ms_insulation,\n                                                                       renovation_rate_ini, solver='iteration')\n            market_share, utility_intensive = to_market_share(bill_saved, subsidies_total, cost_total,\n                                                              utility_zil=utility_zil)\n\n            percentage_intensive_margin = calculation_intensive_margin(stock, renovation_rate_ini, bill_saved,\n                                                                       subsidies_total,\n                                                                       cost_insulation, delta_subsidies,\n                                                                       utility_zil=utility_zil)\n\n            if self._debug_mode:\n                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                utility_intensive.boxplot(ax=ax, fontsize=12, figsize=(8, 10))\n                plt.xticks(fontsize=7, rotation=45)\n                fig.savefig(os.path.join(self.path_calibration_renovation, 'utility_insulation_distribution.png'))\n                plt.close(fig)\n\n                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                market_share.boxplot(ax=ax, fontsize=12, figsize=(8, 10))\n                plt.xticks(fontsize=7, rotation=45)\n                fig.savefig(os.path.join(self.path_calibration_renovation, 'market_share_distribution.png'))\n                plt.close(fig)\n\n            \"\"\"scale_intensive = calibration_intensive_margin(stock, retrofit_rate_ini, bill_saved, subsidies_total,\n                                                           cost_insulation, delta_subsidies,\n                                                           target_invest=0.2, utility_zil=utility_zil)\n\n            self.constant_insulation_intensive *= scale_intensive\n            self.pref_subsidy_insulation_int *= scale_intensive\n            self.pref_investment_insulation_int *= scale_intensive\n            self.pref_bill_insulation_int *= scale_intensive\n\n            ms_after, _ = to_market_share(bill_saved, subsidies_total, cost_insulation,\n                                              utility_zil=utility_zil)\n\n            s = self.add_certificate(stock)\n            stock_single = s.xs('Single-family', level='Housing type', drop_level=False)\n            flow_retrofit = stock_single * reindex_mi(retrofit_rate_ini, stock_single.index)\n            ms = ms_after.groupby([i for i in ms_after.index.names if i != 'Heating system final']).first()\n            ms = reindex_mi(ms, flow_retrofit.index).dropna()\n            flow_retrofit = flow_retrofit.reindex(ms.index)\n            agg = (ms.T * flow_retrofit).T\n            market_share_agg_after = (agg.sum() / agg.sum().sum()).reindex(ms_insulation.index)\n\n            test = calibration_intensive_margin(stock, retrofit_rate_ini, bill_saved, subsidies_total,\n                                                           cost_insulation, delta_subsidies,\n                                                           target_invest=0.2, utility_zil=utility_zil)\n            \"\"\"\n\n        # calculating market-shares\n        if self._debug_mode:\n            s = self.add_certificate(stock)\n            stock_single = s.xs('Single-family', level='Housing type', drop_level=False)\n            flow_retrofit = stock_single * reindex_mi(renovation_rate_ini, stock_single.index)\n            ms = market_share.groupby([i for i in market_share.index.names if i != 'Heating system final']).first()\n            ms = reindex_mi(ms, flow_retrofit.index).dropna()\n            flow_retrofit = flow_retrofit.reindex(ms.index)\n            agg = (ms.T * flow_retrofit).T\n            market_share_agg = (agg.sum() / agg.sum().sum()).reindex(ms_insulation.index)\n            self.market_share = market_share_agg\n\n        # extensive margin\n        bool_zil_ext, bool_zil = None, None\n        if utility_zil is not None:\n            bool_zil = utility_zil.copy()\n            bool_zil[bool_zil > 0] = 1\n\n        bill_saved_insulation, subsidies_insulation, investment_insulation = None, None, None\n        if self._utility_extensive == 'market_share':\n            bill_saved_insulation = (bill_saved.reindex(market_share.index) * market_share).sum(axis=1)\n            subsidies_insulation = (subsidies_total.reindex(market_share.index) * market_share).sum(axis=1)\n            investment_insulation = (cost_total.reindex(market_share.index) * market_share).sum(axis=1)\n            if utility_zil is not None:\n                bool_zil_ext = (bool_zil.reindex(market_share.index) * market_share).sum(axis=1)\n        elif self._utility_extensive == 'max':\n            def rename_tuple(tuple, names):\n                idx = tuple.index\n                tuple = DataFrame([[a, b, c, d] for a, b, c, d in tuple.values])\n                tuple.columns = names\n                for i in names:\n                    tuple.loc[tuple[i] == True, i] = i\n                    tuple.loc[tuple[i] == False, i] = ''\n                return Series(list(zip(*(tuple[i] for i in names))), index=idx)\n\n            columns = utility_intensive.idxmax(axis=1)\n            \"\"\"work_umax = rename_tuple(columns, utility_intensive.columns.names)\n            utility_intensive_max = utility_intensive.max(axis=1)\"\"\"\n            bill_saved_insulation, investment_insulation, subsidies_insulation = Series(dtype=float), Series(\n                dtype=float), Series(dtype=float)\n            if utility_zil is not None:\n                bool_zil_ext = Series(dtype=float)\n\n            for c in columns.unique():\n                idx = columns.index[columns == c]\n                bill_saved_insulation = concat((bill_saved_insulation, bill_saved.loc[idx, c]), axis=0)\n                investment_insulation = concat((investment_insulation, cost_insulation.loc[idx, c]), axis=0)\n                subsidies_insulation = concat((subsidies_insulation, subsidies_total.loc[idx, c]), axis=0)\n                if utility_zil is not None:\n                    bool_zil_ext = concat((bool_zil_ext, bool_zil.loc[idx, c]), axis=0)\n\n            bill_saved_insulation.index = MultiIndex.from_tuples(bill_saved_insulation.index).set_names(\n                bill_saved.index.names)\n            investment_insulation.index = MultiIndex.from_tuples(investment_insulation.index).set_names(\n                cost_insulation.index.names)\n            subsidies_insulation.index = MultiIndex.from_tuples(subsidies_insulation.index).set_names(\n                subsidies_total.index.names)\n            if utility_zil is not None:\n                bool_zil_ext.index = MultiIndex.from_tuples(bool_zil_ext.index).set_names(\n                    bool_zil.index.names)\n\n        idx = bill_saved_insulation[bill_saved_insulation <= 0].index\n        bill_saved_insulation.drop(idx, inplace=True)\n        subsidies_insulation.drop(idx, inplace=True)\n        # More index in investment_insulation\n        investment_insulation.drop(idx, inplace=True)\n        if bool_zil_ext:\n            bool_zil_ext.drop(idx, inplace=True)\n\n        retrofit_rate, utility = to_retrofit_rate(bill_saved_insulation, subsidies_insulation, investment_insulation,\n                                                  bool_zil=bool_zil_ext)\n\n        if self.constant_insulation_extensive is None:\n            self.logger.debug('Calibration renovation rate')\n            if self._utility_extensive == 'market_share':\n                delta_subsidies_sum = (delta_subsidies.reindex(market_share.index) * market_share).sum(axis=1)\n            else:\n                raise NotImplemented\n            pref_subsidies = reindex_mi(self.pref_subsidy_insulation_ext, subsidies_insulation.index).rename(None)\n\n            # graphic showing the impact of the scale in a general case\n            if self._debug_mode:\n                x, free_riders, elasticity = [], [], []\n                for scale in arange(0.1, 5, 0.1):\n                    x.append(scale)\n                    free_riders.append(impact_subsidies(scale, utility, stock, - delta_subsidies_sum / 1000, pref_subsidies,\n                                                        indicator='freeriders'))\n                    elasticity.append(impact_subsidies(scale, utility, stock, subsidies_insulation / 1000 * 0.01, pref_subsidies,\n                                                       indicator='elasticity'))\n\n                graphs = {'Freeriders cite': free_riders}\n                for name, data in graphs.items():\n                    df = Series(data, index=Index(x, name='Scale'), name=name)\n                    fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                    df.plot(ax=ax)\n                    format_ax(ax, format_y=lambda y, _: '{:.0%}'.format(y), y_label=name)\n                    save_fig(fig, save=os.path.join(self.path_calibration, 'scale_calibration_{}.png'.format(name.lower())))\n\n            constant, scale = calibration_constant_scale_ext(utility, stock, renovation_rate_ini, target_freeriders,\n                                                             delta_subsidies_sum, pref_subsidies)\n            self.constant_insulation_extensive = constant\n\n            # graphic showing the impact of the scale\n            if self._debug_mode:\n                stock_single = stock.xs('Single-family', level='Housing type', drop_level=False)\n                stock_multi = stock.xs('Multi-family', level='Housing type', drop_level=False)\n                x_before, y_before, y_before_single, y_before_multi = [], [], [], []\n                for delta in arange(0, 2, 0.1):\n                    sub = subsidies_insulation * (1 + delta)\n                    x_before.append((sub * stock).sum() / stock.sum())\n                    rate = to_retrofit_rate(bill_saved_insulation, sub, investment_insulation)[0]\n                    y_before.append((rate * stock).sum() / stock.sum())\n                    y_before_single.append((rate * stock_single).sum() / stock_single.sum())\n                    y_before_multi.append((rate * stock_multi).sum() / stock_multi.sum())\n\n            self.scale_ext = scale\n            self.pref_subsidy_insulation_ext *= self.scale_ext\n            self.pref_investment_insulation_ext *= self.scale_ext\n            self.pref_bill_insulation_ext *= self.scale_ext\n            self.pref_zil_ext *= self.scale_ext\n\n            # graphic showing the impact of the scale\n            if self._debug_mode:\n                x_after, y_after, y_after_single, y_after_multi = [], [], [], []\n                for delta in arange(0, 2, 0.1):\n                    sub = subsidies_insulation * (1 + delta)\n                    x_after.append((sub * stock).sum() / stock.sum())\n                    rate = to_retrofit_rate(bill_saved_insulation, sub, investment_insulation)[0]\n                    y_after.append((rate * stock).sum() / stock.sum())\n                    y_after_single.append((rate * stock_single).sum() / stock_single.sum())\n                    y_after_multi.append((rate * stock_multi).sum() / stock_multi.sum())\n\n                df = concat(\n                    (Series(x_before), Series(y_before), Series(y_after), Series(y_before_single),\n                     Series(y_after_single), Series(y_before_multi),\n                     Series(y_after_multi)), axis=1)\n\n                df.columns = ['Subsidies (€)', 'Before', 'After', 'Before single', 'After single', 'Before multi',\n                              'After multi']\n                color = {'Before': 'black', 'After': 'black',\n                         'Before single': 'darkorange', 'After single': 'darkorange',\n                         'Before multi': 'royalblue', 'After multi': 'royalblue'\n                         }\n                style = ['--', '-'] * 10\n                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                df.plot(ax=ax, x='Subsidies (€)', color=color, style=style)\n                format_ax(ax, format_y=lambda y, _: '{:.0%}'.format(y), y_label='Retrofit rate')\n                format_legend(ax)\n                save_fig(fig, save=os.path.join(self.path_calibration, 'scale_effect.png'))\n\n            retrofit_rate, utility = to_retrofit_rate(bill_saved_insulation, subsidies_insulation,\n                                                      investment_insulation, bool_zil=bool_zil_ext)\n\n            impact_subsidies(1.0, utility, stock, - delta_subsidies_sum / 1000, self.pref_subsidy_insulation_ext)\n\n            # graphics showing the distribution of retrofit rate after calibration\n            if self._debug_mode:\n                r = retrofit_rate.xs(False, level='Heater replacement').rename('')\n\n                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                r.plot.box(ax=ax)\n                format_ax(ax, format_y=lambda y, _: '{:.0%}'.format(y))\n                ax.set_xlabel('')\n                ax.set_ylabel('Retrofit rate (%)')\n                save_fig(fig, save=os.path.join(self.path_calibration_renovation, 'retrofit_rate_distribution.png'))\n\n                certificate = self.certificate.groupby([l for l in self.stock.index.names if l != 'Income tenant']).first()\n                certificate = reindex_mi(certificate, r.index)\n                r.to_frame().groupby(certificate).boxplot(fontsize=12, figsize=(8, 10))\n                plt.savefig(os.path.join(self.path_calibration_renovation, 'retrofit_rate_distribution_dpe.png'))\n                plt.close()\n\n                r = retrofit_rate.rename('')\n                certificate = self.certificate.groupby([l for l in self.stock.index.names if l != 'Income tenant']).first()\n                certificate = reindex_mi(certificate, r.index)\n                temp = concat((r, certificate.rename('Performance')), axis=1).set_index('Performance', append=True)\n                temp.groupby(renovation_rate_ini.index.names).describe().to_csv(\n                    os.path.join(self.path_calibration_renovation, 'retrofit_rate_desription.csv'))\n\n                consumption_sd = self.consumption_standard(r.index)[2]\n                consumption_sd = reindex_mi(consumption_sd, index)\n\n                consumption_sd = reindex_mi(consumption_sd, r.index)\n                df = concat((consumption_sd, r), axis=1, keys=['Consumption', 'Retrofit rate'])\n\n                make_plot(df.set_index('Consumption').squeeze().sort_index(), 'Retrofit rate (%)',\n                          format_y=lambda x, _: '{:.0%}'.format(x),\n                          save=os.path.join(self.path_calibration_renovation, 'retrofit_rate_consumption_calib.png'),\n                          legend=False, integer=False)\n\n                df.reset_index('Income owner', inplace=True)\n                df['Income owner'] = df['Income owner'].replace(resources_data['colors'])\n                for i in renovation_rate_ini.index:\n                    if not i[2]:\n                        d = df.xs(i[0], level='Housing type').xs(i[1], level='Occupancy status')\n                        name = '{}_{}_{}'.format(i[0].lower(), i[1].lower(), str(i[2]).lower())\n                        fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                        d.plot.scatter(ax=ax, x='Consumption', y='Retrofit rate', c=d['Income owner'])\n                        format_ax(ax, format_y=lambda y, _: '{:.0%}'.format(y), y_label=name)\n                        save_fig(fig, save=os.path.join(self.path_calibration_renovation, 'retrofit_rate_{}_calib.png'.format(name)))\n\n            # file concatenating all calibration results\n            scale = Series(self.scale_ext, index=['Scale'])\n            constant_ext = self.constant_insulation_extensive.copy()\n            constant_ext.index = constant_ext.index.to_flat_index()\n            constant_int = self.constant_insulation_intensive.copy()\n            constant_int.index = constant_int.index.to_flat_index()\n            if isinstance(constant_int, DataFrame):\n                constant_int = constant_int.stack(constant_int.columns.names)\n\n            r = self.add_certificate(retrofit_rate)\n            s = self.add_certificate(stock)\n            flow_retrofit = r * s\n            retrofit_rate_mean = flow_retrofit.sum() / s.sum()\n            retrofit_rate_mean = Series(retrofit_rate_mean, index=['Retrofit rate mean (%)'])\n            retrofit_calibrated = flow_retrofit.groupby(renovation_rate_ini.index.names).sum() / s.groupby(renovation_rate_ini.index.names).sum()\n            retrofit_calibrated.index = retrofit_calibrated.index.to_flat_index()\n            flow_retrofit = flow_retrofit.droplevel('Performance')\n            flow_insulation = (flow_retrofit * market_share.T).T.sum()\n            flow_insulation_agg, name = list(), ''\n            for i in flow_insulation.index.names:\n                flow_insulation_agg.append(flow_insulation.xs(True, level=i).sum())\n                name = '{}{},'.format(name, i)\n            name = Series('', index=[name])\n            flow_insulation_agg = Series(flow_insulation_agg, index=flow_insulation.index.names)\n            flow_insulation.index = flow_insulation.index.to_flat_index()\n            flow_insulation_sum = Series(flow_insulation.sum(), index=['Replacement insulation'])\n            ms_calibrated = flow_insulation / flow_insulation.sum()\n            ms_calibrated.index = ms_calibrated.index.to_flat_index()\n            percentage_intensive_margin = Series(percentage_intensive_margin,\n                                                    index=['Percentage intensive margin'])\n            result = concat((scale, constant_ext, retrofit_rate_mean, retrofit_calibrated, flow_insulation_sum,\n                                flow_insulation_agg, name, constant_int, flow_insulation, ms_calibrated,\n                                percentage_intensive_margin), axis=0)\n            if self.path is not None:\n                result.to_csv(os.path.join(self.path_calibration, 'result_calibration.csv'))\n\n        return retrofit_rate, market_share\n\n    @staticmethod\n    def exogenous_retrofit(index, choice_insulation):\n        \"\"\"Format retrofit rate and market share for each segment.\n\n        Global retrofit and retrofit rate to match exogenous numbers.\n        Retrofit all heating system replacement dwelling.\n\n        Parameters\n        ----------\n        index: MultiIndex\n        choice_insulation: MultiIndex\n\n        Returns\n        -------\n        Series\n            Retrofit rate by segment.\n        DataFrame\n            Market-share by segment and insulation choice.\n        \"\"\"\n\n        retrofit_rate = concat([Series(1, dtype=float, index=index)], keys=[True], names=['Heater replacement'])\n\n        market_share = DataFrame(0, index=index, columns=choice_insulation)\n        market_share.loc[:, (True, True, True, True)] = 1\n\n        return retrofit_rate, market_share\n\n    def remove_market_failures(self):\n        \"\"\"NotImplemented\n\n        Returns\n        -------\n\n        \"\"\"\n        if self.constant_insulation_extensive is not None:\n\n            if self._remove_market_failures['landlord']:\n                c = self.constant_insulation_extensive.copy()\n                c = c.reset_index('Occupancy status')\n                c = c[c['Occupancy status'] == 'Owner-occupied'].drop('Occupancy status', axis=1).squeeze()\n                c = concat((c, c, c), axis=0, keys=['Owner-occupied', 'Privately rented', 'Social housing'], names=['Occupancy status'])\n                c = c.reorder_levels(self.constant_insulation_extensive.index.names)\n                self.constant_insulation_extensive = c\n\n            if self._remove_market_failures['multi-family']:\n                c = self.constant_insulation_extensive.copy()\n                c = c.reset_index('Housing type')\n                c = c[c['Housing type'] == 'Single-family'].drop('Housing type', axis=1).squeeze()\n                c = concat((c, c, c), axis=0, keys=['Single-family', 'Multi-family'], names=['Housing type'])\n                c = c.reorder_levels(self.constant_insulation_extensive.index.names)\n                self.constant_insulation_extensive = c\n\n            if self._remove_market_failures['credit constraint']:\n                self.pref_bill_insulation_int = pd.Series(self.pref_bill_insulation_int.loc['D10'], index=self.pref_bill_insulation_int.index)\n                self.pref_bill_insulation_ext = pd.Series(self.pref_bill_insulation_ext.loc['D10'], index=self.pref_bill_insulation_ext.index)\n\n    def flow_retrofit(self, prices, cost_heater, cost_insulation, policies_heater=None, policies_insulation=None,\n                      ms_heater=None, ms_insulation=None, renovation_rate_ini=None, target_freeriders=None,\n                      supply_constraint=False, financing_cost=None\n                      ):\n        \"\"\"Compute heater replacement and insulation retrofit.\n\n        1. Heater replacement based on current stock segment.\n        2. Knowing heater replacement (and new heating system) calculating retrofit rate by segment and market\n        share by segment.\n        3. Then, managing inflow and outflow.\n\n        Parameters\n        ----------\n        prices: Series\n        cost_heater: Series\n        ms_heater: DataFrame\n        cost_insulation\n        ms_insulation: Series\n        renovation_rate_ini: Series\n        policies_heater: list\n            List of policies for heating system.\n        policies_insulation: list\n            List of policies for insulation.\n        target_freeriders: float, default None\n            Number of freeriders in calibration year for the income tax credit.\n        supply_constraint: bool, default False\n        financing_cost: optional, dict\n\n        Returns\n        -------\n        Series\n        \"\"\"\n\n        if self._remove_market_failures is not None:\n            self.remove_market_failures()\n\n        stock = self.heater_replacement(prices, cost_heater, policies_heater, ms_heater=ms_heater)\n\n        self.logger.debug('Agents: {:,.0f}'.format(stock.shape[0]))\n        stock_existing = stock.xs(True, level='Existing', drop_level=False)\n        retrofit_rate, market_share = self.insulation_replacement(prices, cost_insulation,\n                                                                  ms_insulation=ms_insulation,\n                                                                  renovation_rate_ini=renovation_rate_ini,\n                                                                  policies_insulation=policies_insulation,\n                                                                  target_freeriders=target_freeriders,\n                                                                  index=stock_existing.index, stock=stock_existing,\n                                                                  supply_constraint=supply_constraint,\n                                                                  financing_cost=financing_cost)\n\n        flow_only_heater = (1 - retrofit_rate.reindex(stock.index).fillna(0)) * stock\n        flow_only_heater = flow_only_heater.xs(True, level='Heater replacement', drop_level=False).unstack('Heating system final')\n        flow_only_heater_sum = flow_only_heater.sum().sum()\n\n        flow = (retrofit_rate * stock).dropna()\n        replacement_sum = flow.sum().sum()\n\n        replaced_by = (flow * market_share.T).T\n\n        assert round(replaced_by.sum().sum(), 0) == round(replacement_sum, 0), 'Sum problem'\n\n\n        only_heater = (stock - flow.reindex(stock.index, fill_value=0)).xs(True, level='Heater replacement')\n        certificate_jump = self.certificate_jump_heater.stack()\n        rslt = {}\n        l = unique(certificate_jump)\n        for i in l:\n            rslt.update({i: ((certificate_jump == i) * only_heater).sum()})\n        self.certificate_jump_heater = Series(rslt).sort_index()\n        if self.detailed_mode:\n            self.store_information_retrofit(replaced_by)\n\n        # removing heater replacement level\n        replaced_by = replaced_by.groupby(\n            [c for c in replaced_by.index.names if c != 'Heater replacement']).sum()\n        flow_only_heater = flow_only_heater.groupby(\n            [c for c in flow_only_heater.index.names if c != 'Heater replacement']).sum()\n        # TODO perhaps can be optimized\n\n        share = (self.stock_mobile.unstack('Income tenant').T / self.stock_mobile.unstack('Income tenant').sum(axis=1)).T\n        temp = concat([replaced_by] * share.shape[1], keys=share.columns, names=share.columns.names, axis=1)\n        share = reindex_mi(share, temp.columns, axis=1)\n        share = reindex_mi(share, temp.index)\n        replaced_by = (share * temp).stack('Income tenant').dropna()\n        assert round(replaced_by.sum().sum(), 0) == round(replacement_sum, 0), 'Sum problem'\n\n        share = (self.stock_mobile.unstack('Income tenant').T / self.stock_mobile.unstack('Income tenant').sum(axis=1)).T\n        temp = concat([flow_only_heater] * share.shape[1], keys=share.columns, names=share.columns.names, axis=1)\n        share = reindex_mi(share, temp.columns, axis=1)\n        share = reindex_mi(share, temp.index)\n        flow_only_heater = (share * temp).stack('Income tenant').dropna()\n        assert round(flow_only_heater.sum().sum(), 0) == round(flow_only_heater_sum, 0), 'Sum problem'\n\n        flow_only_heater = flow_only_heater.stack('Heating system final')\n        to_replace_only_heater = - flow_only_heater.droplevel('Heating system final')\n\n        flow_replaced_by = flow_only_heater.droplevel('Heating system')\n        flow_replaced_by.index = flow_replaced_by.index.rename('Heating system', level='Heating system final')\n        flow_replaced_by = flow_replaced_by.reorder_levels(to_replace_only_heater.index.names)\n\n        flow_only_heater = pd.concat((to_replace_only_heater, flow_replaced_by), axis=0)\n        flow_only_heater = flow_only_heater.groupby(flow_only_heater.index.names).sum()\n\n        assert round(flow_only_heater.sum(), 0) == 0, 'Sum problem'\n\n        to_replace = replaced_by.droplevel('Heating system final').sum(axis=1).copy()\n        to_replace = to_replace.groupby(to_replace.index.names).sum()\n        assert round(to_replace.sum(), 0) == round(replacement_sum, 0), 'Sum problem'\n\n        replaced_by = replaced_by.droplevel('Heating system').rename_axis(\n            index={'Heating system final': 'Heating system'})\n\n        replaced_by.index.set_names(\n            {'Wall': 'Wall before', 'Roof': 'Roof before', 'Floor': 'Floor before', 'Windows': 'Windows before'},\n            inplace=True)\n        replaced_by.columns.set_names(\n            {'Wall': 'Wall after', 'Roof': 'Roof after', 'Floor': 'Floor after', 'Windows': 'Windows after'},\n            inplace=True)\n        replaced_by = replaced_by.stack(replaced_by.columns.names).rename('Data')\n\n        replaced_by = replaced_by[replaced_by > 0]\n\n        replaced_by = replaced_by.reset_index()\n\n        for component in ['Wall', 'Floor', 'Roof', 'Windows']:\n            replaced_by[component] = replaced_by['{} before'.format(component)]\n            replaced_by.loc[replaced_by['{} after'.format(component)], component] = self._performance_insulation[component]\n\n        replaced_by.drop(\n            ['Wall before', 'Wall after', 'Roof before', 'Roof after', 'Floor before', 'Floor after', 'Windows before',\n             'Windows after'], axis=1, inplace=True)\n\n        replaced_by = replaced_by.set_index(self.stock.index.names).loc[:, 'Data']\n        replaced_by = replaced_by.groupby(replaced_by.index.names).sum()\n\n        to_replace = to_replace.reorder_levels(replaced_by.index.names)\n        flow_only_heater = flow_only_heater.reorder_levels(replaced_by.index.names)\n        flow_retrofit = concat((-to_replace, replaced_by, flow_only_heater), axis=0)\n        flow_retrofit = flow_retrofit.groupby(flow_retrofit.index.names).sum()\n\n        assert round(flow_retrofit.sum(), 0) == 0, 'Sum problem'\n\n        return flow_retrofit\n\n    def flow_obligation(self, design='raw'):\n        {'G': 2020, 'F': 2021}\n        if design == 'raw':\n            idx = self.certificate.loc[self.certificate == 'G'].index\n            temp = idx.to_frame()\n            for i in self._performance_insulation.keys():\n                temp[i] = self._performance_insulation[i]\n            flow_to_replace = - self.stock.loc[idx]\n            flow_replaced_by = self.stock.loc[idx].copy()\n            idx_replace_by = pd.MultiIndex.from_frame(temp)\n            flow_replaced_by.index = idx_replace_by\n\n            assert abs(flow_to_replace.sum().round(0)) == abs(flow_replaced_by.sum().round(0)), 'Sum problem'\n\n            flow_obligation = concat((flow_to_replace, flow_replaced_by), axis=0)\n\n            return flow_obligation\n\n\n\n\n    def flow_demolition(self):\n        \"\"\"Demolition of E, F and G buildings based on their share in the mobile stock.\n\n        Returns\n        -------\n        Series\n        \"\"\"\n        self.logger.info('Demolition')\n        stock_demolition = self.stock_mobile[self.certificate.isin(self._target_demolition)]\n        if stock_demolition.sum() < self._demolition_total:\n            self._target_demolition = ['G', 'F', 'E', 'D']\n            stock_demolition = self.stock_mobile[self.certificate.isin(self._target_demolition)]\n            if stock_demolition.sum() < self._demolition_total:\n                self._target_demolition = ['G', 'F', 'E', 'D', 'C']\n                stock_demolition = self.stock_mobile[self.certificate.isin(self._target_demolition)]\n\n        stock_demolition = stock_demolition / stock_demolition.sum()\n        flow_demolition = (stock_demolition * self._demolition_total).dropna()\n        return flow_demolition.reorder_levels(self.stock.index.names)\n\n    def health_cost(self, param, stock=None):\n        if stock is None:\n            stock = self.simplified_stock()\n\n        health_cost_type = {'health_expenditure': 'Health expenditure (Billion euro)',\n                            'mortality_cost': 'Social cost of mortality (Billion euro)',\n                            'loss_well_being': 'Loss of well-being (Billion euro)'}\n        health_cost = dict()\n        for key, item in health_cost_type.items():\n            health_cost[item] = (stock * reindex_mi(param[key], stock.index)).sum() / 10 ** 9\n\n        health_cost_total = Series(health_cost).sum()\n        return health_cost_total, health_cost\n\n    def parse_output_run(self, inputs):\n        \"\"\"Parse output.\n\n        Renovation : envelope\n        Retrofit : envelope and/or heating system\n\n        Parameters\n        ----------\n        inputs: dict\n            Exogenous data for post-treatment.\n            'carbon_emission'\n            'population'\n            'surface'\n            'embodied_energy_renovation'\n            'carbon_footprint_renovation'\n            'Carbon footprint construction (MtCO2)'\n            'health_expenditure', 'mortality_cost', 'loss_well_being'\n            'Embodied energy construction (TWh PE)'\n\n        Returns\n        -------\n\n        \"\"\"\n\n        stock = self.simplified_stock()\n\n        output = dict()\n        output['Consumption standard (TWh)'] = (self.heat_consumption_sd * self.stock).sum() / 10 ** 9\n\n        consumption = self.heat_consumption_calib\n        output['Consumption (TWh)'] = consumption.sum() / 10 ** 9\n\n        temp = consumption.groupby(self.energy).sum()\n        temp.index = temp.index.map(lambda x: 'Consumption {} (TWh)'.format(x))\n        output.update(temp.T / 10 ** 9)\n\n        temp = consumption.groupby('Existing').sum()\n        temp.rename(index={True: 'Existing', False: 'New'}, inplace=True)\n        temp.index = temp.index.map(lambda x: 'Consumption {} (TWh)'.format(x))\n        output.update(temp.T / 10 ** 9)\n\n        temp = consumption.groupby(self.certificate).sum()\n        temp.index = temp.index.map(lambda x: 'Consumption {} (TWh)'.format(x))\n        output.update(temp.T / 10 ** 9)\n\n        c = self.add_energy(consumption)\n        emission = reindex_mi(inputs['carbon_emission'].T.rename_axis('Energy', axis=0), c.index).loc[:,\n                   self.year] * c\n\n        output['Emission (MtCO2)'] = emission.sum() / 10 ** 12\n\n        temp = emission.groupby('Existing').sum()\n        temp.rename(index={True: 'Existing', False: 'New'}, inplace=True)\n        temp.index = temp.index.map(lambda x: 'Emission {} (MtCO2)'.format(x))\n        output.update(temp.T / 10 ** 12)\n\n        temp = emission.groupby('Energy').sum()\n        temp.index = temp.index.map(lambda x: 'Emission {} (MtCO2)'.format(x))\n        output.update(temp.T / 10 ** 12)\n\n        output['Stock (Million)'] = stock.sum() / 10 ** 6\n\n        output['Surface (Million m2)'] = (self.stock * self.surface).sum() / 10 ** 6\n        output['Surface (m2/person)'] = (\n                    output['Surface (Million m2)'] / (inputs['population'].loc[self.year] / 10 ** 6))\n\n        output['Consumption standard (kWh/m2)'] = (output['Consumption standard (TWh)'] * 10 ** 9) / (\n                output['Surface (Million m2)'] * 10 ** 6)\n        output['Consumption (kWh/m2)'] = (output['Consumption (TWh)'] * 10 ** 9) / (\n                output['Surface (Million m2)'] * 10 ** 6)\n\n        output['Heating intensity (%)'] = self.heating_intensity_avg\n\n        output['Energy poverty (Million)'] = self.energy_poverty / 10 ** 6\n\n        temp = self.stock.groupby(self.certificate).sum()\n        temp.index = temp.index.map(lambda x: 'Stock {} (Million)'.format(x))\n        output.update(temp.T / 10 ** 6)\n        try:\n            output['Stock efficient (Million)'] = output['Stock A (Million)'] + output['Stock B (Million)']\n        except KeyError:\n            output['Stock efficient (Million)'] = output['Stock B (Million)']\n\n        output['Stock low-efficient (Million)'] = output['Stock F (Million)'] + output['Stock G (Million)']\n\n        if self.year > self.first_year:\n            temp = self.retrofit_rate.dropna(how='all')\n            temp = temp.groupby([i for i in temp.index.names if i not in ['Heating system final']]).mean()\n            t = temp.xs(False, level='Heater replacement')\n\n            s_temp = self.stock\n            s_temp = s_temp.groupby([i for i in s_temp.index.names if i != 'Income tenant']).sum()\n\n            # Weighted average with stock to calculate real retrofit rate\n            output['Renovation rate (%)'] = ((t * s_temp).sum() / s_temp.sum())\n            t_grouped = (t * s_temp).groupby(['Housing type', 'Occupancy status']).sum() / s_temp.groupby(\n                ['Housing type',\n                 'Occupancy status']).sum()\n            t_grouped.index = t_grouped.index.map(lambda x: 'Renovation rate {} - {} (%)'.format(x[0], x[1]))\n            output.update(t_grouped.T)\n\n            \"\"\"output['Non-weighted retrofit rate (%)'] = t.mean()\n            t = t.groupby(['Housing type', 'Occupancy status']).mean()\n            t.index = t.index.map(lambda x: 'Non-weighted retrofit rate {} - {} (%)'.format(x[0], x[1]))\n            output.update(t.T)\n            \n            output['Non-weighted retrofit rate w/ heater (%)'] = t.mean()\n            t = t.groupby(['Housing type', 'Occupancy status']).mean()\n            t.index = t.index.map(lambda x: 'Non-weighted retrofit rate heater {} - {} (%)'.format(x[0], x[1]))\n            output.update(t.T)\n            \"\"\"\n\n            t = temp.xs(True, level='Heater replacement')\n            s_temp = self.stock\n            s_temp = s_temp.groupby([i for i in s_temp.index.names if i != 'Income tenant']).sum()\n            output['Renovation rate w/ heater (%)'] = ((t * s_temp).sum() / s_temp.sum())\n\n            t_grouped = (t * s_temp).groupby(['Housing type', 'Occupancy status']).sum() / s_temp.groupby(\n                ['Housing type',\n                 'Occupancy status']).sum()\n            t_grouped.index = t_grouped.index.map(lambda x: 'Renovation rate heater {} - {} (%)'.format(x[0], x[1]))\n            output.update(t_grouped.T)\n\n            temp = self.gest_nb.copy()\n            temp.index = temp.index.map(lambda x: 'Renovation types {} (Thousand households)'.format(x))\n            output['Renovation (Thousand households)'] = temp.sum() / 10 ** 3\n            output['Renovation with heater replacement (Thousand households)'] = self.retrofit_with_heater / 10 ** 3\n            output['Replacement renovation (Thousand)'] = (self.gest_nb * self.gest_nb.index).sum() / 10 ** 3\n            output.update(temp.T / 10 ** 3)\n            output['Replacement total (Thousand)'] = output['Replacement renovation (Thousand)'] - output[\n                'Renovation with heater replacement (Thousand households)'] + self.replacement_heater.sum().sum() / 10 ** 3\n\n            output['Retrofit (Thousand households)'] = output['Renovation (Thousand households)'] - output[\n                'Renovation with heater replacement (Thousand households)'] + self.replacement_heater.sum().sum() / 10 ** 3\n\n            # output['Renovation (Thousand households)'] = self.certificate_jump.sum().sum() / 10 ** 3\n            # We need them by income for freeriders ratios per income deciles\n\n            # TODO: optimizing: only need certificate_jump summed or by index by not dataframe\n\n            temp = self.certificate_jump_all.sum().squeeze().sort_index()\n            temp = temp[temp.index.dropna()]\n            o = {}\n            for i in temp.index.union(self.certificate_jump_heater.index):\n                t_renovation = 0\n                if i in temp.index:\n                    t_renovation = temp.loc[i]\n                    o['Renovation {} EPC (Thousand households)'.format(i)] = t_renovation / 10 ** 3\n                t_heater = 0\n                if i in self.certificate_jump_heater.index:\n                    t_heater = self.certificate_jump_heater.loc[i]\n                o['Retrofit {} EPC (Thousand households)'.format(i)] = (t_renovation + t_heater) / 10 ** 3\n            o = Series(o).sort_index(ascending=False)\n\n            output['Renovation >= 1 EPC (Thousand households)'] = self.certificate_jump_all.loc[:,\n                                                     [i for i in self.certificate_jump_all.columns if\n                                                      i > 0]].sum().sum() / 10 ** 3\n            output['Retrofit >= 1 EPC (Thousand households)'] = sum([o['Retrofit {} EPC (Thousand households)'.format(i)] for i in temp.index.unique() if i >=1])\n\n            output.update(o.T)\n            # output['Retrofit rate {} EPC (%)'.format(i)] = temp.sum() / stock.sum()\n\n            # output['Efficient retrofits (Thousand)'] = Series(self.efficient_renovation_yrs) / 10**3\n            output['Global renovation high income (Thousand households)'] = self.global_renovation_high_income / 10 ** 3\n            output['Global renovation low income (Thousand households)'] = self.global_renovation_low_income / 10 ** 3\n            output['Global renovation (Thousand households)'] = output['Global renovation high income (Thousand households)'] + output['Global renovation low income (Thousand households)']\n            output['Bonus best renovation (Thousand households)'] = self.bonus_best / 10 ** 3\n            output['Bonus worst renovation (Thousand households)'] = self.bonus_worst / 10 ** 3\n            output['Percentage of global renovation (% households)'] = output['Global renovation (Thousand households)'] / output[\n                'Renovation (Thousand households)']\n            output['Percentage of bonus best renovation (% households)'] = output['Bonus best renovation (Thousand households)'] / output[\n                'Renovation (Thousand households)']\n            output['Percentage of bonus worst renovation (% households)'] = output['Bonus worst renovation (Thousand households)'] / output[\n                'Renovation (Thousand households)']\n\n            temp = self.certificate_jump_all.sum(axis=1)\n            t = temp.groupby('Income owner').sum()\n            t.index = t.index.map(lambda x: 'Renovation {} (Thousand households)'.format(x))\n            output.update(t.T / 10 ** 3)\n\n            # for replacement output need to be presented by technologies (what is used) and by agent (who change)\n            temp = self.replacement_heater.sum()\n            output['Replacement heater (Thousand households)'] = temp.sum() / 10 ** 3\n            t = temp.copy()\n            t.index = t.index.map(lambda x: 'Replacement heater {} (Thousand households)'.format(x))\n            output.update((t / 10 ** 3).T)\n\n            \"\"\"\n            # summing accoridng to heating system beafore instead of final \n            temp = self.replacement_heater.sum(axis=1) \n            t = temp.groupby(['Heating system', 'Housing type']).sum()\n            t.index = t.index.map(lambda x: 'Replacement heater {} {} (Thousand households)'.format(x[0], x[1]))\n            output.update((t / 10 ** 3).T)\n            \"\"\"\n\n            t = self.replacement_heater.groupby('Housing type').sum().loc['Multi-family']\n            t.index = t.index.map(lambda x: 'Replacement heater Multi-family {} (Thousand households)'.format(x))\n            output.update((t / 10 ** 3).T)\n\n            t = self.replacement_heater.groupby('Housing type').sum().loc['Single-family']\n            t.index = t.index.map(lambda x: 'Replacement heater Single-family {} (Thousand households)'.format(x))\n            output.update((t / 10 ** 3).T)\n\n            temp = self.replacement_insulation.sum(axis=1)\n            output['Replacement insulation (Thousand households)'] = temp.sum() / 10 ** 3\n            t = temp.groupby(['Housing type', 'Occupancy status']).sum()\n            t.index = t.index.map(lambda x: 'Replacement insulation {} - {} (Thousand households)'.format(x[0], x[1]))\n            output.update((t / 10 ** 3).T)\n            t = temp.groupby('Income owner').sum()\n            t.index = t.index.map(lambda x: 'Replacement insulation {} (Thousand households)'.format(x))\n            output.update(t.T / 10 ** 3)\n\n            \"\"\"t.index = t.index.str.replace('Thousand', '%')\n            s = stock.groupby(['Housing type', 'Occupancy status']).sum()\n            s.index = s.index.map(lambda x: 'Replacement insulation {} - {} (%)'.format(x[0], x[1]))\n            t = t / s\n            output.update(t.T)\"\"\"\n            o = {}\n            for i in ['Wall', 'Floor', 'Roof', 'Windows']:\n                temp = self.replacement_insulation.xs(True, level=i, axis=1).sum(axis=1)\n                o['Replacement {} (Thousand households)'.format(i)] = temp.sum() / 10 ** 3\n\n                cost = self.cost_component.loc[:, i]\n                t = reindex_mi(cost, temp.index) * temp\n                surface = reindex_mi(inputs['surface'].loc[:, self.year], t.index)\n                o['Investment {} (Billion euro)'.format(i)] = (t * surface).sum() / 10 ** 9\n\n                surface = reindex_mi(inputs['surface'].loc[:, self.year], temp.index)\n                o['Embodied energy {} (TWh PE)'.format(i)] = (temp * surface *\n                                                                   inputs['embodied_energy_renovation'][\n                                                                       i]).sum() / 10 ** 9\n                o['Carbon footprint {} (MtCO2)'.format(i)] = (temp * surface *\n                                                                   inputs['carbon_footprint_renovation'][\n                                                                       i]).sum() / 10 ** 9\n            output['Replacement insulation (Thousand)'] = sum(\n                [o['Replacement {} (Thousand households)'.format(i)] for i in\n                 ['Wall', 'Floor', 'Roof', 'Windows']])\n\n            o = Series(o).sort_index(ascending=False)\n            output.update(o.T)\n\n            output['Embodied energy renovation (TWh PE)'] = output['Embodied energy Wall (TWh PE)'] + output[\n                'Embodied energy Floor (TWh PE)'] + output['Embodied energy Roof (TWh PE)'] + output[\n                                                                'Embodied energy Windows (TWh PE)']\n\n            output['Embodied energy construction (TWh PE)'] = inputs['Embodied energy construction (TWh PE)'].loc[\n                self.year]\n            output['Embodied energy (TWh PE)'] = output['Embodied energy renovation (TWh PE)'] + output[\n                'Embodied energy construction (TWh PE)']\n\n            output['Carbon footprint renovation (MtCO2)'] = output['Carbon footprint Wall (MtCO2)'] + output[\n                'Carbon footprint Floor (MtCO2)'] + output['Carbon footprint Roof (MtCO2)'] + output[\n                                                                'Carbon footprint Windows (MtCO2)']\n\n            output['Carbon footprint construction (MtCO2)'] = inputs['Carbon footprint construction (MtCO2)'].loc[\n                self.year]\n            output['Carbon footprint (MtCO2)'] = output['Carbon footprint renovation (MtCO2)'] + output[\n                'Carbon footprint construction (MtCO2)']\n\n            temp = self.investment_heater.sum()\n            output['Investment heater (Billion euro)'] = temp.sum() / 10 ** 9\n            temp.index = temp.index.map(lambda x: 'Investment {} (Billion euro)'.format(x))\n            output.update(temp.T / 10 ** 9)\n            investment_heater = self.investment_heater.sum(axis=1)\n\n            # representative insulation investment: weighted average with number of insulation actions as weights\n            if False:\n                investment_insulation_repr = DataFrame(self.investment_insulation_repr_yrs)\n                gest = DataFrame({year: item.sum(axis=1) for year, item in replacement_insulation.items()})\n                gest = reindex_mi(gest, investment_insulation_repr.index)\n                temp = gest * investment_insulation_repr\n\n                t = temp.groupby('Income owner').sum() / gest.groupby('Income owner').sum()\n                t.index = t.index.map(lambda x: 'Investment per insulation action {} (euro)'.format(x))\n                output.update(t.T)\n\n                t = temp.groupby(['Housing type', 'Occupancy status']).sum() / gest.groupby(['Housing type',\n                                                                                             'Occupancy status']).sum()\n                t.index = t.index.map(lambda x: 'Investment per insulation action {} - {} (euro)'.format(x[0], x[1]))\n                output.update(t.T)\n\n            investment_insulation = self.investment_insulation.sum(axis=1)\n            output['Investment insulation (Billion euro)'] = investment_insulation.sum() / 10 ** 9\n\n            index = investment_heater.index.union(investment_insulation.index)\n            investment_total = investment_heater.reindex(index, fill_value=0) + investment_insulation.reindex(index,\n                                                                                                              fill_value=0)\n            output['Investment total (Billion euro)'] = investment_total.sum() / 10 ** 9\n            temp = investment_total.groupby('Income owner').sum()\n            temp.index = temp.index.map(lambda x: 'Investment total {} (Billion euro)'.format(x))\n            output.update(temp.T / 10 ** 9)\n            temp = investment_total.groupby(['Housing type', 'Occupancy status']).sum()\n            temp.index = temp.index.map(lambda x: 'Investment total {} - {} (Billion euro)'.format(x[0], x[1]))\n            output.update(temp.T / 10 ** 9)\n\n            subsidies_heater = self.subsidies_heater.sum(axis=1)\n            output['Subsidies heater (Billion euro)'] = subsidies_heater.sum() / 10 ** 9\n\n            subsidies_insulation = self.subsidies_insulation.sum(axis=1)\n            output['Subsidies insulation (Billion euro)'] = subsidies_insulation.sum() / 10 ** 9\n\n            index = subsidies_heater.index.union(subsidies_insulation.index)\n            subsidies_total = subsidies_heater.reindex(index, fill_value=0) + subsidies_insulation.reindex(index,\n                                                                                                           fill_value=0)\n            output['Subsidies total (Billion euro)'] = subsidies_total.sum() / 10 ** 9\n            temp = subsidies_total.groupby('Income owner').sum()\n            temp.index = temp.index.map(lambda x: 'Subsidies total {} (Million euro)'.format(x))\n            output.update(temp.T / 10 ** 6)\n            temp = subsidies_total.groupby(['Housing type', 'Occupancy status']).sum()\n            temp.index = temp.index.map(lambda x: 'Subsidies total {} - {} (Million euro)'.format(x[0], x[1]))\n            output.update(temp.T / 10 ** 6)\n\n            subsidies, subsidies_count, sub_count = None, None, None\n            for gest, subsidies_details in {'heater': self.subsidies_details_heater,\n                                            'insulation': self.subsidies_details_insulation}.items():\n                if gest == 'heater':\n                    sub_count = Series(self.subsidies_count_heater)\n                elif gest == 'insulation':\n                    sub_count = Series(self.subsidies_count_insulation)\n\n                subsidies_details = Series({k: i.sum().sum() for k, i in subsidies_details.items()}, dtype='float64')\n\n                for i in subsidies_details.index:\n                    output['{} {} (Thousand)'.format(i.capitalize().replace('_', ' '), gest)] = sub_count[i] / 10**3\n                    output['{} {} (Billion euro)'.format(i.capitalize().replace('_', ' '), gest)] = \\\n                    subsidies_details.loc[i] / 10 ** 9\n                if subsidies is None:\n                    subsidies = subsidies_details.copy()\n                    subsidies_count = sub_count.copy()\n                else:\n                    subsidies = concat((subsidies, subsidies_details), axis=0)\n                    subsidies_count = concat((subsidies_count, sub_count))\n\n                subsidies = subsidies.groupby(subsidies.index).sum()\n                subsidies_count = subsidies_count.groupby(subsidies_count.index).sum()\n                for i in subsidies.index:\n                    output['{} (Thousand)'.format(i.capitalize().replace('_', ' '))] = subsidies_count.loc[i] / 10 ** 3\n                    output['{} (Billion euro)'.format(i.capitalize().replace('_', ' '))] = subsidies.loc[i] / 10 ** 9\n            # output['Zero interest loan headcount'] = self.zil_count\n            # output['Zero interest loan average amount'] = self.zil_loaned_avg\n            taxes_expenditures = self.taxes_expenditure_details\n            taxes_expenditures = DataFrame(taxes_expenditures).sum()\n            taxes_expenditures.index = taxes_expenditures.index.map(\n                lambda x: '{} (Billion euro)'.format(x.capitalize().replace('_', ' ').replace('Cee', 'Cee tax')))\n            output.update((taxes_expenditures / 10 ** 9).T)\n            output['Taxes expenditure (Billion euro)'] = taxes_expenditures.sum() / 10 ** 9\n\n            energy_expenditure = self.energy_expenditure\n            output['Energy expenditures (Billion euro)'] = energy_expenditure.sum() / 10 ** 9\n            temp = energy_expenditure.groupby('Income tenant').sum()\n            temp.index = temp.index.map(lambda x: 'Energy expenditures {} (Billion euro)'.format(x))\n            output.update(temp.T / 10 ** 9)\n\n            output['VTA heater (Billion euro)'] = self.tax_heater.sum().sum() / 10 ** 9\n\n            output['VTA insulation (Billion euro)'] = self.taxed_insulation.sum().sum() / 10 ** 9\n            output['VTA (Billion euro)'] = output['VTA heater (Billion euro)'] + output['VTA insulation (Billion euro)']\n\n            output['Investment total HT (Billion euro)'] = output['Investment total (Billion euro)'] - output[\n                'VTA (Billion euro)']\n\n            output['Carbon value (Billion euro)'] = (self.heat_consumption_energy * inputs['carbon_value_kwh'].loc[\n                                                                                         self.year,\n                                                                                         :]).sum() / 10 ** 9\n\n            output['Health cost (Billion euro)'], o = self.health_cost(inputs)\n            output.update(o)\n\n            output['Income state (Billion euro)'] = output['VTA (Billion euro)'] + output[\n                'Taxes expenditure (Billion euro)']\n            output['Expenditure state (Billion euro)'] = output['Subsidies heater (Billion euro)'] + output[\n                'Subsidies insulation (Billion euro)']\n            output['Balance state (Billion euro)'] = output['Income state (Billion euro)'] - output[\n                'Expenditure state (Billion euro)']\n\n            levels = ['Occupancy status', 'Income owner', 'Housing type']\n            for level in levels:\n                temp = subsidies_total.groupby(level).sum() / investment_total.groupby(level).sum()\n                temp.index = temp.index.map(lambda x: 'Share subsidies {} (%)'.format(x))\n                output.update(temp.T)\n\n            output['Investment total HT / households (Thousand euro)'] = output['Investment total HT (Billion euro)'] * 10**6 / (output['Retrofit (Thousand households)'] * 10**3)\n            output['Investment total / households (Thousand euro)'] = output['Investment total (Billion euro)'] * 10**6 / (output['Retrofit (Thousand households)'] * 10**3)\n            output['Investment insulation / households (Thousand euro)'] = output['Investment insulation (Billion euro)'] * 10**6 / (output['Renovation (Thousand households)'] * 10**3)\n\n        output = Series(output).rename(self.year)\n        stock = stock.rename(self.year)\n        return stock, output\n\n    @staticmethod\n    def find_best_option(criteria, dict_df, func='max'):\n        \"\"\"Find best option (columns), and returns\n\n        Parameters\n        ----------\n        criteria: DataFrame\n            Find for each index the column based on criteria values.\n        dict_df: dict\n            Dataframe to return.\n        func\n\n        Returns\n        -------\n        DataFrame\n        \"\"\"\n        dict_ds = {key: Series(dtype=float) for key in dict_df.keys()}\n        dict_ds.update({'criteria': Series(dtype=float)})\n\n        columns = None\n        if func == 'max':\n            columns = criteria.idxmax(axis=1)\n        elif func == 'min':\n            columns = criteria.idxmin(axis=1)\n\n        for c in columns.unique():\n            idx = columns.index[columns == c]\n            for key in dict_df.keys():\n                dict_ds[key] = concat((dict_ds[key], dict_df[key].loc[idx, c]), axis=0)\n            dict_ds['criteria'] = concat((dict_ds['criteria'], criteria.loc[idx, c]), axis=0)\n        for key in dict_df.keys():\n            dict_ds[key].index = MultiIndex.from_tuples(dict_ds[key].index).set_names(\n                dict_df[key].index.names)\n        dict_ds['criteria'].index = MultiIndex.from_tuples(dict_ds['criteria'].index).set_names(criteria.index.names)\n        dict_ds['columns'] = columns\n\n        return concat(dict_ds, axis=1)\n\n    def mitigation_potential(self, prices, cost_insulation_raw, carbon_emission=None, carbon_value=None, health_cost=None,\n                             index=None):\n        \"\"\"Function returns bill saved and cost for buildings stock retrofit.\n\n        Not implemented yet but should be able to calculate private and social indicator.\n        Make cost abatement cost graphs, payback period graphs.\n\n        Parameters\n        ----------\n        index\n        prices\n        cost_insulation_raw\n        carbon_emission\n        carbon_value\n        health_cost\n\n        Returns\n        -------\n\n        \"\"\"\n        # carbon_emission = inputs['carbon_emission']\n        # carbon_value = inputs['carbon_value_kwh']\n\n        output = dict()\n\n        if index is None:\n            index = self.stock.index\n\n        consumption_before = self.consumption_standard(index)[0]\n        consumption_after, _, certificate_after = self.prepare_consumption(self._choice_insulation, index=index)\n        consumption_saved = (consumption_before - consumption_after.T).T\n\n        consumption_before = reindex_mi(consumption_before, index)\n        consumption_after = reindex_mi(consumption_after, index)\n        consumption_saved = reindex_mi(consumption_saved, index)\n\n        consumption_actual_before = self.consumption_actual(prices.loc[self.year, :], consumption_before)\n        consumption_actual_after = self.consumption_actual(prices.loc[self.year, :], consumption_after)\n        consumption_actual_saved = (consumption_actual_before - consumption_actual_after.T).T\n\n        consumption_before = (reindex_mi(self._surface, index) * consumption_before.T).T\n        consumption_after = (reindex_mi(self._surface, index) * consumption_after.T).T\n        consumption_saved = (reindex_mi(self._surface, index) * consumption_saved.T).T\n\n        consumption_actual_before = (reindex_mi(self._surface, index) * consumption_actual_before.T).T\n        consumption_actual_after = (reindex_mi(self._surface, index) * consumption_actual_after.T).T\n        consumption_actual_saved = (reindex_mi(self._surface, index) * consumption_actual_saved.T).T\n\n        output.update({'Stock (dwellings/segment)': self.stock,\n                       'Surface (m2/segment)': self.stock * reindex_mi(self._surface, index),\n                       'Consumption before (kWh/dwelling)': consumption_before,\n                       'Consumption before (kWh/segment)': consumption_before * self.stock,\n                       'Consumption actual before (kWh/dwelling)': consumption_actual_before,\n                       'Consumption actual before (kWh/segment)': consumption_actual_before * self.stock,\n                       'Consumption actual after (kWh/dwelling)': consumption_actual_after,\n                       'Consumption actual after (kWh/segment)': (consumption_actual_after.T * self.stock).T,\n                       'Consumption saved (kWh/dwelling)': consumption_saved,\n                       'Consumption saved (kWh/segment)': (consumption_saved.T * self.stock).T,\n                       'Consumption actual saved (kWh/dwelling)': consumption_actual_saved,\n                       'Consumption actual saved (kWh/segment)': (consumption_actual_saved.T * self.stock).T\n                       })\n\n        consumption_saved_agg = (self.stock * consumption_saved.T).T\n        consumption_actual_saved_agg = (self.stock * consumption_actual_saved.T).T\n\n        if carbon_emission is not None:\n            c = self.add_energy(consumption_actual_before)\n            emission_before = reindex_mi(carbon_emission.T.rename_axis('Energy', axis=0), c.index).loc[:,\n                              self.year] * c\n\n            c = self.add_energy(consumption_actual_after)\n            emission_after = (reindex_mi(carbon_emission.T.rename_axis('Energy', axis=0), c.index).loc[:,\n                              self.year] * c.T).T\n\n            emission_saved = - emission_after.sub(emission_before, axis=0).dropna()\n\n            output.update({'Emission before (gCO2/dwelling)': emission_before,\n                           'Emission after (gCO2/dwelling)': emission_after,\n                           'Emission saved (gCO2/dwelling)': emission_saved,\n                           })\n\n            if carbon_value is not None:\n                c = self.add_energy(consumption_actual_before)\n                emission_value_before = reindex_mi(carbon_value.T.rename_axis('Energy', axis=0), c.index).loc[:,\n                                        self.year] * c\n\n                c = self.add_energy(consumption_actual_after)\n                emission_value_after = (reindex_mi(carbon_value.T.rename_axis('Energy', axis=0), c.index).loc[:,\n                                        self.year] * c.T).T\n\n                emission_value_saved = - emission_value_after.sub(emission_value_before, axis=0).dropna()\n\n                output.update({'Emission value before (euro/dwelling)': emission_value_before,\n                               'Emission value after (euro/dwelling)': emission_value_after,\n                               'Emission value saved (euro/dwelling)': emission_value_saved\n                               })\n\n        cost_insulation = self.prepare_cost_insulation(cost_insulation_raw * self.surface_insulation)\n        cost_insulation = reindex_mi(cost_insulation, index)\n        potential_cost_insulation = (reindex_mi(self._surface, index) * cost_insulation.T).T\n\n        output.update({'Cost insulation (euro/dwelling)': potential_cost_insulation,\n                       'Cost insulation (euro/segment)': (potential_cost_insulation.T * self.stock).T\n                       })\n\n        index = self.stock.index\n        energy = pd.Series(index.get_level_values('Heating system'), index=index).str.split('-').str[0].rename('Energy')\n        energy_prices = prices.loc[self.year, :].reindex(energy).set_axis(index)\n\n        bill_before = consumption_before * energy_prices\n        bill_after = (consumption_after.T * energy_prices).T\n        bill_saved = - bill_after.sub(bill_before, axis=0).dropna()\n\n        output.update({'Bill before (euro/dwelling)': bill_before,\n                       'Bill after (euro/dwelling)': bill_after,\n                       'Bill saved (euro/dwelling)': bill_saved\n                       })\n\n        discount_rate, lifetime = 0.05, 30\n        discount_factor = (1 - (1 + discount_rate) ** -lifetime) / discount_rate\n        npv = bill_saved * discount_factor - potential_cost_insulation\n\n        out = AgentBuildings.find_best_option(npv, {'bill_saved': bill_saved,\n                                                    'cost': potential_cost_insulation,\n                                                    'consumption_saved': consumption_saved,\n                                                    'consumption_saved_agg': consumption_saved_agg,\n                                                    'consumption_actual_saved_agg': consumption_actual_saved_agg\n                                                    })\n        output.update({'Best NPV': out})\n\n        out = AgentBuildings.find_best_option(consumption_saved_agg, {'bill_saved': bill_saved,\n                                                                      'cost': potential_cost_insulation,\n                                                                      'consumption_saved': consumption_saved,\n                                                                      'consumption_saved_agg': consumption_saved_agg,\n                                                                      'consumption_actual_saved_agg': consumption_actual_saved_agg})\n\n        output.update({'Max consumption saved': out})\n        return output\n\n\n    def calibration_exogenous(self, energy_prices, taxes, path_heater=None, path_insulation_int=None,\n                              path_insulation_ext=None, scale=1.19651508552344):\n        \"\"\"Function calibrating buildings object with exogenous data.\n\n        Parameters\n        ----------\n        energy_prices: Series\n            Energy prices for year y. Index are energy carriers {'Electricity', 'Natural gas', 'Oil fuel', 'Wood fuel'}.\n        taxes: Series\n            Energy taxes for year y.\n        \"\"\"\n        # calibration energy consumption first year\n        self.calculate_consumption(energy_prices.loc[self.first_year, :], taxes)\n\n        # calibration flow retrofit second year\n        self.year = 2019\n\n        if path_heater is not None:\n            calibration_constant_heater = read_csv(path_heater, index_col=[0, 1, 2]).squeeze()\n        else:\n            calibration_constant_heater = get_pandas('project/input/calibration/calibration_constant_heater.csv',\n                                                     lambda x: pd.read_csv(x, index_col=[0, 1, 2]).squeeze())\n        self.constant_heater = calibration_constant_heater.unstack('Heating system final')\n        self._choice_heater = list(self.constant_heater.columns)\n\n        if path_insulation_int is not None:\n            calibration_constant_insulation = read_csv(path_insulation_int, index_col=[0, 1, 2, 3]).squeeze()\n        else:\n            calibration_constant_insulation = get_pandas('project/input/calibration/calibration_constant_insulation.csv',\n                                                         lambda x: pd.read_csv(x, index_col=[0, 1, 2, 3]).squeeze())\n        self.constant_insulation_intensive = calibration_constant_insulation\n\n        if path_insulation_ext is not None:\n            calibration_constant_extensive = read_csv(path_insulation_ext, index_col=[0, 1, 2, 3]).squeeze()\n        else:\n            calibration_constant_extensive = get_pandas('project/input/calibration/calibration_constant_extensive.csv',\n                                                         lambda x: pd.read_csv(x, index_col=[0, 1, 2, 3]).squeeze())\n        self.constant_insulation_extensive = calibration_constant_extensive.dropna()\n\n        self.scale_ext = scale\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/project/building.py b/project/building.py
--- a/project/building.py	
+++ b/project/building.py	
@@ -1180,6 +1180,8 @@
         if index is None:
             index = self.stock.index
 
+        surface = reindex_mi(self._surface, index)
+
         _, _, certificate_before_heater = self.consumption_standard(index, level_heater='Heating system')
         # index only contains building with energy performance > B
         c_before = reindex_mi(certificate_before_heater, index)
@@ -1191,8 +1193,6 @@
         certificate_before = certificate_before[certificate_before > 'B']
         consumption_3uses_before = consumption_3uses_before.loc[certificate_before.index]
 
-        surface = reindex_mi(self._surface, index)
-
         _, consumption_3uses, certificate = self.prepare_consumption(self._choice_insulation, index=index,
                                                                      level_heater='Heating system final')
         energy_saved_3uses = ((consumption_3uses_before - consumption_3uses.T) / consumption_3uses_before).T
@@ -1224,10 +1224,10 @@
 
             retrofit_rate, market_share = self.endogenous_retrofit(index, prices, utility_subsidies,
                                                                    cost_insulation,
+                                                                   stock=stock,
                                                                    ms_insulation=ms_insulation,
                                                                    renovation_rate_ini=renovation_rate_ini,
                                                                    utility_zil=utility_zil,
-                                                                   stock=stock,
                                                                    delta_subsidies=delta_subsidies,
                                                                    target_freeriders=target_freeriders,
                                                                    supply_constraint=supply_constraint,
@@ -1517,7 +1517,6 @@
 
     def store_information_insulation(self, certificate_jump_all, condition, cost_insulation_raw, tax, cost_insulation,
                                      tax_insulation, subsidies_details, subsidies_total, retrofit_rate):
-
         """Store insulation information.
 
         Parameters
@@ -2224,8 +2223,6 @@
         energy_bill_sd = (consumption_sd.T * energy_prices * reindex_mi(self._surface, index)).T
         bill_saved = - energy_bill_sd.sub(energy_bill_before, axis=0).dropna()
 
-        # idx = (False, True, 'Owner-occupied', 'D1', 'Multi-family', 'Electricity-Performance boiler', 0.5,  0.2, 0.1, 1.6, 'Electricity-Performance boiler')
-
         market_share, utility_intensive = to_market_share(bill_saved, subsidies_total, cost_total,
                                                           utility_zil=utility_zil)
 
@@ -2293,6 +2290,10 @@
             self.market_share = market_share_agg
 
         # extensive margin
+
+        # flow_obligation
+
+
         bool_zil_ext, bool_zil = None, None
         if utility_zil is not None:
             bool_zil = utility_zil.copy()
@@ -2635,7 +2636,6 @@
 
         assert round(replaced_by.sum().sum(), 0) == round(replacement_sum, 0), 'Sum problem'
 
-
         only_heater = (stock - flow.reindex(stock.index, fill_value=0)).xs(True, level='Heater replacement')
         certificate_jump = self.certificate_jump_heater.stack()
         rslt = {}
@@ -2719,9 +2719,9 @@
         return flow_retrofit
 
     def flow_obligation(self, design='raw'):
-        {'G': 2020, 'F': 2021}
+        agenda = {'G': 2020, 'F': 2021}
         if design == 'raw':
-            idx = self.certificate.loc[self.certificate == 'G'].index
+            idx = self.certificate.loc[self.certificate.isin(['F', 'G'])].index
             temp = idx.to_frame()
             for i in self._performance_insulation.keys():
                 temp[i] = self._performance_insulation[i]
@@ -2733,12 +2733,10 @@
             assert abs(flow_to_replace.sum().round(0)) == abs(flow_replaced_by.sum().round(0)), 'Sum problem'
 
             flow_obligation = concat((flow_to_replace, flow_replaced_by), axis=0)
+            flow_obligation = flow_obligation.groupby(flow_obligation.index.names).sum()
 
             return flow_obligation
 
-
-
-
     def flow_demolition(self):
         """Demolition of E, F and G buildings based on their share in the mobile stock.
 
Index: project/input/config/test/config.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\n  \"Reference\": {\n    \"end\": 2031,\n    \"debug_mode\": false,\n    \"detailed_mode\": true,\n    \"prices_constant\": false,\n    \"taxes_constant\": false,\n    \"demolition_rate\": 0.0035,\n    \"construction\": true,\n    \"income_rate\": 0.012,\n    \"start\": 2018,\n    \"endogenous\": true,\n    \"supply_constraint\": false,\n    \"exogenous_detailed\": {\n      \"number\": 0\n    },\n    \"target_freeriders\": 0.7,\n    \"preferences_zeros\": false,\n    \"building_stock\": \"project/input/stock/buildingstock_sdes2018_simple_1.csv\",\n    \"population\": \"project/input/population.csv\",\n    \"renovation_rate_ini\": \"project/input/revealed_data/renovation_rate_ini.csv\",\n    \"insulation_extensive\": \"project/input/revealed_data/extensive_margin_insulation.csv\",\n    \"ms_heater\": \"project/input/revealed_data/market_share_heater.csv\",\n    \"ms_heater_built\": \"project/input/revealed_data/market_share_heater_built.csv\",\n    \"ms_insulation\": \"project/input/revealed_data/market_share_insulation.csv\",\n    \"cost_heater\": \"project/input/cost_heater.csv\",\n    \"cost_insulation\": \"project/input/cost_insulation.csv\",\n    \"cost_factor\": 1,\n    \"efficiency\": \"project/input/efficiency.csv\",\n    \"energy_prices\": \"project/input/energy_prices_ht.csv\",\n    \"prices_factor\": 1,\n    \"energy_taxes\": \"project/input/energy_taxes.csv\",\n    \"carbon_emission\": \"project/input/policies/carbon_emission.csv\",\n    \"health_cost\": \"project/input/policies/health_cost.csv\",\n    \"carbon_value\": \"project/input/policies/carbon_value.csv\",\n    \"policies\": {\n      \"mpr\": {\n        \"start\": 2021,\n        \"end\": 2051,\n        \"heater\": \"project/input/policies/mpr_heater.csv\",\n        \"insulation\": \"project/input/policies/mpr_insulation.csv\",\n        \"global_retrofit\": null,\n        \"bonus\": \"project/input/policies/mpr_bonus.csv\"\n      },\n      \"mpr_serenite\": {\n        \"start\": 2019,\n        \"end\": 2051,\n        \"insulation\": \"project/input/policies/mpr_serenite.csv\",\n        \"cap\": \"project/input/policies/mpr_serenite_cap.csv\"\n      },\n      \"cee\": {\n        \"start\": 2019,\n        \"end\": 2051,\n        \"heater\": \"project/input/policies/cee_heater.csv\",\n        \"insulation\": \"project/input/policies/cee_insulation.csv\",\n        \"policy\": \"subsidy_targeted\",\n        \"tax\": \"project/input/policies/cee_tax.csv\"\n      },\n      \"cap\": {\n        \"start\": 2019,\n        \"end\": 2051,\n        \"insulation\": \"project/input/policies/subsidies_cap.csv\"\n      },\n      \"carbon_tax\": {\n        \"start\": 2019,\n        \"end\": 2051,\n        \"tax\": \"project/input/policies/carbon_tax.csv\",\n        \"emission\": \"project/input/policies/carbon_tax_emission.csv\"\n      },\n      \"cite\": {\n        \"start\": 2019,\n        \"end\": 2021,\n        \"heater\": \"project/input/policies/cite_heater.csv\",\n        \"insulation\": \"project/input/policies/cite_insulation.csv\",\n        \"cap\": 4800\n      },\n      \"reduced_tax\": {\n        \"start\": 2019,\n        \"end\": 2051,\n        \"value\": 0.055\n      },\n      \"zero_interest_loan\": {\n        \"new\": true,\n        \"start\": 2019,\n        \"end\": 2019,\n        \"value\": 0.0917729,\n        \"ad_volarem\": true,\n        \"min\": 5000,\n        \"max\": \"project/input/policies/zil_max.csv\"\n      }\n    },\n    \"footprint\": {\n      \"Traditional material\": 1.0,\n      \"Bio material\": 0.0,\n      \"construction\": \"project/input/footprint_construction.csv\",\n      \"renovation\": \"project/input/footprint_renovation.csv\"\n    },\n    \"quintiles\": false,\n    \"pop_housing\": null,\n    \"share_multi_family\": null,\n    \"surface_built\": null,\n    \"remove_market_failures\": {\n      \"landlord\": false,\n      \"multi-family\": false,\n      \"credit constraint\": false\n    },\n    \"financing_cost\": true\n  }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/project/input/config/test/config.json b/project/input/config/test/config.json
--- a/project/input/config/test/config.json	
+++ b/project/input/config/test/config.json	
@@ -1,6 +1,6 @@
 {
   "Reference": {
-    "end": 2031,
+    "end": 2022,
     "debug_mode": false,
     "detailed_mode": true,
     "prices_constant": false,
