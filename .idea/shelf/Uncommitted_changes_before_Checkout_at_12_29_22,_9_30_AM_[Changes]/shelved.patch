Index: project/building.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Copyright 2020-2021 Ecole Nationale des Ponts et Chaussées\n#\n# This file is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n#\n# Original author Lucas Vivier <vivier@centre-cired.fr>\n\nimport os\nfrom typing import Union, Any\n\nimport pandas as pd\nfrom pandas import Series, DataFrame, MultiIndex, Index, IndexSlice, concat, to_numeric, unique, read_csv\nfrom numpy import exp, log, zeros, ones, append, arange, array\nfrom scipy.optimize import fsolve\nimport matplotlib.pyplot as plt\nimport logging\nfrom copy import deepcopy\n\nfrom project.utils import make_plot, format_ax, save_fig, format_legend, reindex_mi, timing, get_pandas\nfrom project.input.resources import resources_data\nimport project.thermal as thermal\n\nfrom itertools import product\n\n\nclass ThermalBuildings:\n    \"\"\"ThermalBuildings classes.\n\n    Parameters:\n    ----------\n    stock: Series\n        Building stock.\n    surface: Series\n        Surface by dwelling type.\n    ratio_surface: dict\n        Losses area of each envelop component\n    efficiency: Series\n        Heating system efficiency.\n    income: Series\n        Average income value by income class.\n    consumption_ini: Series\n    path: str, optional\n    year: int, default: 2018\n    debug_mode: bool, default: False\n\n    Attributes:\n    ----------\n\n    \"\"\"\n\n    def __init__(self, stock, surface, ratio_surface, efficiency, income, consumption_ini, path=None, year=2018,\n                 debug_mode=False):\n\n        self._debug_mode = debug_mode\n\n        if isinstance(stock, MultiIndex):\n            stock = Series(index=stock, dtype=float)\n\n        self._efficiency = efficiency\n        self._ratio_surface = ratio_surface\n        self.path = path\n        if path is not None:\n            self.path_calibration = os.path.join(path, 'calibration')\n            if not os.path.isdir(self.path_calibration):\n                os.mkdir(self.path_calibration)\n            self.path_calibration_renovation = os.path.join(self.path_calibration, 'renovation')\n            if not os.path.isdir(self.path_calibration_renovation):\n                os.mkdir(self.path_calibration_renovation)\n\n        self._consumption_ini = consumption_ini\n        self.coefficient_consumption = None\n\n        self._surface_yrs = surface\n        self._surface = surface.loc[:, year]\n\n        self._income = income\n        self._income_owner = self._income.copy()\n        self._income_owner.index.rename('Income owner', inplace=True)\n        self._income_tenant = self._income.copy()\n        self._income_tenant.index.rename('Income tenant', inplace=True)\n\n        self._residual_rate = 0.05\n        self._stock_residual = self._residual_rate * stock\n        self.stock_mobile = stock - self._stock_residual\n\n        self.first_year = year\n        self._year = year\n\n        # TODO only heating_intensity and calculate average in parse_output\n        self.energy_poverty, self.heating_intensity = None, None\n        self.consumption_3uses_building, self.consumption_sd_building, self.certificate_building = Series(\n            dtype='float'), Series(dtype='float'), Series(dtype='float')\n        self.consumption_sd_building_choice, self.consumption_3uses_building_choice, self.certificate_building_choice = Series(\n            dtype='float'), Series(dtype='float'), Series(dtype='float')\n\n        self.heating_intensity_avg = None\n        self.heat_consumption_sd = None\n        self.heat_consumption = None\n        self.heat_consumption_calib = None\n        self.heat_consumption_energy = None\n        self.taxes_expenditure = None\n        self.energy_expenditure = None\n        self.taxes_list = []\n        self.taxes_expenditure_details = {}\n        self.stock_yrs = {}\n\n        self.stock = stock\n\n    @property\n    def year(self):\n        return self._year\n\n    @year.setter\n    def year(self, year):\n        self._year = year\n        self._surface = self._surface_yrs.loc[:, year]\n\n    @property\n    def stock(self):\n        return self._stock\n\n    @stock.setter\n    def stock(self, stock):\n        \"\"\"Update stock property.\n\n        Parameters\n        ----------\n        stock: Series\n\n        Returns\n        -------\n\n        \"\"\"\n\n        self._stock = stock\n        self.stock_mobile = stock - self._stock_residual.reindex(stock.index, fill_value=0)\n        self.surface = reindex_mi(self._surface, stock.index)\n        # self.housing_type = Series(stock.index.get_level_values('Housing type'), index=stock.index)\n\n        heating_system = Series(stock.index.get_level_values('Heating system'), index=stock.index)\n        self.energy = heating_system.str.split('-').str[0].rename('Energy')\n        self.efficiency = to_numeric(heating_system.replace(self._efficiency))\n\n        self.stock_yrs.update({self.year: self.stock})\n\n        consumption_sd, _, certificate = self.consumption_standard(stock.index)\n        self.heat_consumption_sd = self.surface * reindex_mi(consumption_sd, stock.index)\n        self.certificate = reindex_mi(certificate, stock.index)\n\n    def simplified_stock(self, energy_level=False):\n        stock = self.stock.fillna(0)\n        certificate = self.certificate.rename('Performance')\n        energy = self.energy.rename('Energy')\n        stock = concat((stock, certificate, energy), axis=1).set_index(['Performance', 'Energy'], append=True).squeeze()\n        if energy_level:\n            stock = stock.groupby(\n                ['Occupancy status', 'Income owner', 'Income tenant', 'Housing type', 'Heating system',\n                 'Energy', 'Performance']).sum()\n\n        else:\n            stock = stock.groupby(\n                ['Occupancy status', 'Income owner', 'Income tenant', 'Housing type', 'Heating system',\n                 'Performance']).sum()\n\n        return stock\n\n    def add_certificate(self, df):\n        \"\"\"Add energy performance certificate to df index.\n\n        Parameters\n        ----------\n        df\n        heating_system\n\n        Returns\n        -------\n\n        \"\"\"\n        certificate = self.certificate.rename('Performance')\n        lvl = [i for i in certificate.index.names if i in df.index.names]\n        certificate = certificate.groupby(lvl).first()\n\n        certificate = reindex_mi(certificate, df.index)\n        df = concat((df, certificate), axis=1).set_index('Performance', append=True).squeeze()\n\n        return df\n\n    def add_energy(self, df):\n        energy = self.energy.rename('Energy')\n        lvl = [i for i in energy.index.names if i in df.index.names]\n        energy = energy.groupby(lvl).first()\n        energy = reindex_mi(energy, df.index)\n        df = concat((df, energy), axis=1).set_index('Energy', append=True).squeeze()\n        return df\n\n    def heating_need(self, climate=2006, smooth=False, freq='year', hourly_profile=None, marginal=False):\n        \"\"\"Calculate heating need of the current building stock.\n\n        Returns\n        -------\n        pd.DataFrame\n        \"\"\"\n        idx = self.stock.index\n        wall = Series(idx.get_level_values('Wall'), index=idx)\n        floor = Series(idx.get_level_values('Floor'), index=idx)\n        roof = Series(idx.get_level_values('Roof'), index=idx)\n        windows = Series(idx.get_level_values('Windows'), index=idx)\n\n        heating_need = thermal.conventional_heating_need(wall, floor, roof, windows, self._ratio_surface.copy(),\n                                                         th_bridging='Medium', vent_types='Ventilation naturelle',\n                                                         infiltration='Medium', climate=climate,\n                                                         smooth=smooth, freq=freq, hourly_profile=hourly_profile,\n                                                         marginal=marginal)\n\n        if marginal:\n            heating_need = (heating_need.T * self.surface).T\n\n        heating_need = (heating_need.T * self.stock * self.surface).T\n        return heating_need\n\n    def heating_consumption(self, freq='year', climate=None, smooth=False, marginal=False, temp_int=None):\n        \"\"\"Calculation consumption standard of the current building stock.\n\n        Parameters\n        ----------\n        freq\n        climate\n        smooth\n\n        Returns\n        -------\n\n        \"\"\"\n\n        idx = self.stock.index\n        wall = Series(idx.get_level_values('Wall'), index=idx)\n        floor = Series(idx.get_level_values('Floor'), index=idx)\n        roof = Series(idx.get_level_values('Roof'), index=idx)\n        windows = Series(idx.get_level_values('Windows'), index=idx)\n        heating_system = Series(idx.get_level_values('Heating system'), index=idx).astype('object')\n        efficiency = to_numeric(heating_system.replace(self._efficiency))\n        consumption = thermal.conventional_heating_final(wall, floor, roof, windows, self._ratio_surface.copy(),\n                                                         efficiency, climate=climate, freq=freq, smooth=smooth,\n                                                         marginal=marginal, temp_int=temp_int)\n        return consumption\n\n    def consumption_standard(self, indexes, level_heater='Heating system'):\n        \"\"\"Pre-calculate space energy consumption based only on relevant levels.\n\n        Parameters\n        ----------\n        indexes: MultiIndex, Index\n            Index used to estimate consumption standard.\n        level_heater: {'Heating system', 'Heating system final'}, default 'Heating system'\n\n        Returns\n        -------\n\n        \"\"\"\n        levels_consumption = ['Wall', 'Floor', 'Roof', 'Windows', level_heater, 'Housing type']\n        index = indexes.to_frame().loc[:, levels_consumption].set_index(levels_consumption).index\n        index = index[~index.duplicated()]\n\n        index.rename({level_heater: 'Heating system'}, inplace=True)\n        # remove index already calculated\n        if not self.consumption_sd_building.empty:\n            temp = self.consumption_sd_building.index.intersection(index)\n            idx = index.drop(temp)\n        else:\n            idx = index\n\n        if not idx.empty:\n            wall = Series(idx.get_level_values('Wall'), index=idx)\n            floor = Series(idx.get_level_values('Floor'), index=idx)\n            roof = Series(idx.get_level_values('Roof'), index=idx)\n            windows = Series(idx.get_level_values('Windows'), index=idx)\n            heating_system = Series(idx.get_level_values('Heating system'), index=idx).astype('object')\n            efficiency = to_numeric(heating_system.replace(self._efficiency))\n\n            consumption = thermal.conventional_heating_final(wall, floor, roof, windows, self._ratio_surface.copy(),\n                                                             efficiency)\n\n            certificate, consumption_3uses = thermal.conventional_energy_3uses(wall, floor, roof, windows,\n                                                                               self._ratio_surface.copy(),\n                                                                               efficiency, idx)\n\n            self.consumption_sd_building = concat((self.consumption_sd_building, consumption))\n            self.consumption_sd_building.index = MultiIndex.from_tuples(\n                self.consumption_sd_building.index).set_names(consumption.index.names)\n            self.consumption_3uses_building = concat((self.consumption_3uses_building, consumption_3uses))\n            self.consumption_3uses_building.index = MultiIndex.from_tuples(\n                self.consumption_3uses_building.index).set_names(consumption.index.names)\n\n            self.certificate_building = concat((self.certificate_building, certificate))\n            self.certificate_building.index = MultiIndex.from_tuples(\n                self.certificate_building.index).set_names(consumption.index.names)\n\n        levels_consumption = [i for i in indexes.names if i in levels_consumption]\n\n        consumption_sd = self.consumption_sd_building.loc[index]\n        consumption_sd.index.rename({'Heating system': level_heater}, inplace=True)\n        consumption_sd = consumption_sd.reorder_levels(levels_consumption)\n        consumption_3uses = self.consumption_3uses_building.loc[index]\n        consumption_3uses.index.rename({'Heating system': level_heater}, inplace=True)\n        consumption_3uses = consumption_3uses.reorder_levels(levels_consumption)\n        certificate = self.certificate_building.loc[index]\n        certificate.index.rename({'Heating system': level_heater}, inplace=True)\n        certificate = certificate.reorder_levels(levels_consumption)\n\n        return consumption_sd, consumption_3uses, certificate\n\n    def consumption_actual(self, prices, consumption=None):\n        \"\"\"Space heating consumption based on standard space heating consumption and heating intensity (kWh/a).\n\n        Space heating consumption is in kWh/building.a\n        Equation is based on Allibe (2012).\n\n        Parameters\n        ----------\n        prices: Series\n        consumption: Series or None, default None\n\n        Returns\n        -------\n        Series\n        \"\"\"\n\n        if consumption is None:\n            consumption = self.heat_consumption_sd.copy()\n        else:\n            consumption = consumption.copy()\n\n        energy_bill = AgentBuildings.energy_bill(prices, consumption)\n        if isinstance(energy_bill, Series):\n            budget_share = energy_bill / reindex_mi(self._income_tenant, self.stock.index)\n            heating_intensity = thermal.heat_intensity(budget_share)\n            self.heating_intensity = heating_intensity\n            consumption *= heating_intensity\n            self.heating_intensity_avg = (self.stock * heating_intensity).sum() / self.stock.sum()\n            self.energy_poverty = (self.stock[self.stock.index.get_level_values(\n                'Income owner') == ('D1' or 'D2' or 'D3')])[budget_share >= 0.08].sum()\n        elif isinstance(energy_bill, DataFrame):\n            budget_share = (energy_bill.T / reindex_mi(self._income_tenant, self.stock.index)).T\n            heating_intensity = thermal.heat_intensity(budget_share)\n            consumption = heating_intensity * consumption\n\n        return consumption\n\n    def calculate_consumption(self, prices, taxes):\n        \"\"\"Calculate energy indicators.\n\n        Parameters\n        ----------\n        prices: Series\n        taxes: Series\n\n        Returns\n        -------\n\n        \"\"\"\n\n        self.heat_consumption = self.consumption_actual(prices) * self.stock\n\n        heat_consumption_energy = self.heat_consumption.groupby(self.energy).sum()\n        if self.coefficient_consumption is None:\n\n            consumption = concat((self.heat_consumption, self.energy), axis=1).groupby(\n                ['Housing type', 'Energy']).sum().iloc[:, 0] / 10**9\n\n            # considering 20% of electricity got wood stove - 50% electricity\n            electricity_wood = 0.2 * consumption[('Single-family', 'Electricity')] * 1\n            consumption[('Single-family', 'Wood fuel')] += electricity_wood\n            consumption[('Single-family', 'Electricity')] -= electricity_wood\n            consumption.groupby('Energy').sum()\n\n            self.heat_consumption.groupby('Housing type').sum() / 10**9\n\n            validation = dict()\n\n            # stock initial\n            temp = concat((self.stock, self.energy), axis=1).groupby(\n                ['Housing type', 'Energy']).sum().iloc[:, 0] / 10**3\n            temp.index = temp.index.map(lambda x: 'Stock {} {} (Thousands)'.format(x[0], x[1]))\n            validation.update(temp)\n            temp = self.stock.groupby('Housing type').sum() / 10**3\n            temp.index = temp.index.map(lambda x: 'Stock {} (Thousands)'.format(x))\n            validation.update(temp)\n            validation.update({'Stock (Thousands)': self.stock.sum() / 10**3})\n\n            # surface initial\n            temp = concat((self.stock * self.surface, self.energy), axis=1).groupby(\n                ['Housing type', 'Energy']).sum().iloc[:, 0] / 10**6\n            temp.index = temp.index.map(lambda x: 'Surface {} {} (Million m2)'.format(x[0], x[1]))\n            validation.update(temp)\n            temp = (self.stock * self.surface).groupby('Housing type').sum() / 10**6\n            temp.index = temp.index.map(lambda x: 'Surface {} (Million m2)'.format(x))\n            validation.update(temp)\n            validation.update({'Surface (Million m2)': (self.stock * self.surface).sum() / 10**6})\n\n            # heating consumption initial\n            temp = concat((self.heat_consumption, self.energy), axis=1).groupby(\n                ['Housing type', 'Energy']).sum().iloc[:, 0] / 10**9\n            temp.index = temp.index.map(lambda x: 'Consumption {} {} (TWh)'.format(x[0], x[1]))\n            validation.update(temp)\n            temp = self.heat_consumption.groupby('Housing type').sum() / 10**9\n            temp.index = temp.index.map(lambda x: 'Consumption {} (TWh)'.format(x))\n            validation.update(temp)\n            validation.update({'Consumption (TWh)': self.heat_consumption.sum() / 10**9})\n\n            self.coefficient_consumption = self._consumption_ini * 10**9 / heat_consumption_energy\n\n            temp = self.coefficient_consumption.copy()\n            temp.index = temp.index.map(lambda x: 'Coefficient calibration {} (%)'.format(x))\n            validation.update(temp)\n\n            temp = heat_consumption_energy / 10**9\n            temp.index = temp.index.map(lambda x: 'Consumption {} (TWh)'.format(x))\n            validation.update(temp)\n\n            validation = Series(validation)\n            if resources_data['data_calibration'] is not None:\n                validation = concat((validation, resources_data['data_calibration']), keys=['Calcul', 'Data'], axis=1)\n                validation['Error'] = (validation['Calcul'] - validation['Data']) / validation['Data']\n\n            if self.path is not None:\n                validation.round(2).to_csv(os.path.join(self.path_calibration, 'validation_stock.csv'))\n\n        coefficient = self.coefficient_consumption.reindex(self.energy).set_axis(self.stock.index, axis=0)\n        self.heat_consumption_calib = (coefficient * self.heat_consumption).copy()\n\n        self.heat_consumption_energy = self.heat_consumption_calib.groupby(self.energy).sum()\n\n        prices_reindex = prices.reindex(self.energy).set_axis(self.stock.index, axis=0)\n        self.energy_expenditure = prices_reindex * self.heat_consumption_calib\n\n        total_taxes = Series(0, index=prices.index)\n        for tax in taxes:\n            if self.year in tax.value.index:\n                if tax.name not in self.taxes_list:\n                    self.taxes_list += [tax.name]\n                amount = tax.value.loc[self.year, :] * heat_consumption_energy\n                self.taxes_expenditure_details[tax.name] = amount\n                total_taxes += amount\n\n        self.taxes_expenditure = total_taxes\n\n    @staticmethod\n    def energy_bill(prices, consumption, level_heater='Heating system'):\n        \"\"\"Calculate energy bill by dwelling for each stock segment (€/dwelling.a).\n\n        Parameters\n        ----------\n        prices: Series\n            Energy prices for year (€/kWh)\n        consumption: Series\n            Energy consumption by dwelling (kWh/dwelling.a)\n        level_heater\n            Heating system level to calculate the bill. Enable to calculate energy bill before or after change of\n            heating system.\n\n        Returns\n        -------\n        pd.Series\n            Energy bill by dwelling for each stock segment (€/dwelling)\n        \"\"\"\n\n        index = consumption.index\n\n        heating_system = Series(index.get_level_values(level_heater), index=index)\n        energy = heating_system.str.split('-').str[0].rename('Energy')\n\n        prices = prices.rename('Energy').reindex(energy)\n        prices.index = index\n\n        if isinstance(consumption, pd.Series):\n            # * reindex_mi(self._surface, index)\n            return reindex_mi(consumption, index) * prices\n        else:\n            # * reindex_mi(self._surface, index)\n            return (reindex_mi(consumption, index).T * prices).T\n\n    def optimal_temperature(self, prices):\n\n        def func(temp, consumption, index):\n            consumption_temp = self.heating_consumption(temp_int=temp).loc[index] * self.surface.loc[index]\n            return consumption - consumption_temp\n\n        consumption_actual = self.consumption_actual(prices)\n        consumption_sd = self.heating_consumption(temp_int=None) * self.surface\n\n        temp_optimal = {}\n        for i, v in consumption_actual.iteritems():\n            temp_optimal.update({i: fsolve(func, 19, args=(consumption_actual.loc[i], i))[0]})\n        temp_optimal = pd.Series(temp_optimal)\n\n        temp = concat((consumption_actual, consumption_sd, temp_optimal), axis=1,\n                      keys=['actual', 'conventional', 'temp optimal'])\n\n        return temp_optimal\n\n\nclass AgentBuildings(ThermalBuildings):\n\n    \"\"\"Class AgentBuildings represents thermal dynamic building stock.\n\n    Parameters:\n    ----------\n    stock: Series\n        Building stock.\n    surface: Series\n        Surface by dwelling type.\n    ratio_surface: dict\n        Losses area of each envelop component\n    efficiency: Series\n        Heating system efficiency.\n    income: Series\n        Average income value by income class.\n    consumption_ini: Series\n    preferences: dict\n    performance_insulation: dict\n    path: str, optional\n    year: int, default: 2018\n    debug_mode: bool, default: False\n    demolition_rate: float, default 0.0\n    endogenous: bool, default True\n    number_exogenous: float or int, default 300000\n    insulation_representative: {'market_share', 'max}\n    logger: default\n    debug_mode: bool, default False\n        Detailed output.\n    calib_scale: bool, default True\n    detailed_mode: None\n    quintiles: bool or None, default None\n    financing_cost: bool, default True\n\n    Attributes\n    ----------\n    \"\"\"\n\n    def __init__(self, stock, surface, ratio_surface, efficiency, income, consumption_ini, preferences,\n                 performance_insulation, path=None, year=2018, demolition_rate=0.0,\n                 endogenous=True, number_exogenous=300000, insulation_representative='market_share',\n                 logger=None, debug_mode=False, calib_scale=True, detailed_mode=None,\n                 quintiles=None, financing_cost=True,\n                 ):\n        super().__init__(stock, surface, ratio_surface, efficiency, income, consumption_ini, path=path, year=year,\n                         debug_mode=debug_mode)\n\n        self.constant_test = None\n        self.certif_jump_all = None\n        self.in_global_renovation_low_income = None\n        self.in_global_renovation_high_income = None\n        self.certificate_jump_heater = None\n        self.global_renovation = None\n        self.financing_cost = financing_cost\n        self.subsidies_count_insulation, self.subsidies_average_insulation = dict(), dict()\n        self.subsidies_count_heater, self.subsidies_average_heater = dict(), dict()\n\n        self.prepared_cost_insulation = None\n        self.certif_jump_all = None\n        self.retrofit_with_heater = None\n        self._calib_scale = calib_scale\n        self.vta = 0.1\n        self.lifetime_insulation = 30\n        self._epc2int = {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6}\n\n        self.quintiles = quintiles\n        if detailed_mode is None:\n            detailed_mode = True\n        self.detailed_mode = detailed_mode\n\n        if logger is None:\n            logger = logging.getLogger()\n        self.logger = logger\n        self.policies = []\n\n        # {'max', 'market_share'} define how to calculate utility_extensive\n        self._insulation_representative = insulation_representative\n\n        self.preferences_heater = deepcopy(preferences['heater'])\n        self.preferences_insulation_int = deepcopy(preferences['insulation'])\n        self.preferences_insulation_ext = deepcopy(preferences['insulation'])\n\n        def monetary_unit(pref_dict):\n            for key in pref_dict.keys():\n                if key != 'investment':\n                    pref_dict[key] = pref_dict[key] / abs(pref_dict['investment'])\n            pref_dict['investment'] = -1\n\n        # monetary_unit(self.preferences_heater)\n        # monetary_unit(self.preferences_insulation_int)\n        # monetary_unit(self.preferences_insulation_ext)\n\n\n        # self.discount_rate = - self.pref_investment_insulation_ext / self.pref_bill_insulation_ext\n        # self.discount_factor = (1 - (1 + self.discount_rate) ** -self.lifetime_insulation) / self.discount_rate\n\n        self.scale_int = None\n        self.scale_ext = None\n        self.calibration_scale = 'cite'\n        self.param_supply = None\n        self.capacity_utilization = None\n        self.factor_yrs = {}\n\n        self._demolition_rate = demolition_rate\n        self._demolition_total = (stock * self._demolition_rate).sum()\n        self._target_demolition = ['E', 'F', 'G']\n\n        self._choice_heater = None\n        self._probability_replacement = None\n\n        self._endogenous = endogenous\n\n        self._target_exogenous = ['F', 'G']\n        self._market_share_exogenous = None\n        self._number_exogenous = number_exogenous\n\n        choice_insulation = {'Wall': [False, True], 'Floor': [False, True], 'Roof': [False, True],\n                             'Windows': [False, True]}\n        names = list(choice_insulation.keys())\n        choice_insulation = list(product(*[i for i in choice_insulation.values()]))\n        choice_insulation.remove((False, False, False, False))\n        choice_insulation = MultiIndex.from_tuples(choice_insulation, names=names)\n        self._choice_insulation = choice_insulation\n        self._performance_insulation = {i: min(val, self.stock.index.get_level_values(i).min()) for i, val in\n                                        performance_insulation.items()}\n        # min of self.stock\n        self.surface_insulation = self._ratio_surface.copy()\n\n        self.constant_insulation_extensive, self.constant_insulation_intensive, self.constant_heater = None, None, None\n\n        self.cost_insulation_indiv, self.subsidies_heater_indiv, self.subsidies_insulation_indiv = None, None, None\n\n        self.certificate_jump = None\n        self.gest_nb = None\n\n        self.global_renovation_high_income, self.global_renovation_low_income = None, None\n        self.in_best, self.out_worst = None, None\n        self.bonus_best, self.bonus_worst = None, None\n        self.market_share = None\n        self.replacement_heater, self.heater_replaced = None, None\n        self.cost_heater, self.investment_heater = None, None\n        self.tax_heater = None\n        self.subsidies_details_heater, self.subsidies_heater = None, None\n\n        self.replacement_insulation, self.retrofit_rate = None, None\n        self.cost_component, self.investment_insulation = None, None\n        self.tax_insulation, self.taxed_insulation = None, None\n        self.subsidies_details_insulation, self.subsidies_insulation = None, None\n\n        self.zil_count, self.zil_loaned_avg, self.zil_loaned = None, None, None\n\n        self._share_decision_maker = stock.groupby(\n            ['Occupancy status', 'Housing type', 'Income owner', 'Income tenant']).sum().unstack(\n            ['Occupancy status', 'Income owner', 'Income tenant'])\n        self._share_decision_maker = (self._share_decision_maker.T / self._share_decision_maker.sum(axis=1)).T\n\n    @property\n    def year(self):\n        return self._year\n\n    @year.setter\n    def year(self, year):\n        self._year = year\n        self._surface = self._surface_yrs.loc[:, year]\n\n        self.bonus_best, self.bonus_worst = 0, 0\n        self.global_renovation_high_income, self.global_renovation_low_income = 0, 0\n        self.replacement_insulation = None\n\n    def add_flows(self, flows):\n        \"\"\"Update stock attribute by adding flow series.\n\n        Parameters\n        ----------\n        flows: Series, list\n        \"\"\"\n        flow_total = None\n        if isinstance(flows, Series):\n            flow_total = flows\n        if isinstance(flows, list):\n            for flow in flows:\n                if flow_total is None:\n                    flow_total = flow.copy()\n                else:\n                    union = flow.index.union(flow_total.index)\n                    flow_total = flow.reindex(union, fill_value=0) + flow_total.reindex(union, fill_value=0)\n\n        union = flow_total.index.union(self.stock.index)\n        stock = flow_total.reindex(union, fill_value=0) + self.stock.reindex(union, fill_value=0)\n\n        assert (stock >= 0).all(), 'Stock Error: Building stock cannot be negative'\n        # stock[stock < 0] = 0\n        stock = stock[stock > 10**-4]\n        self.stock = stock\n\n    def prepare_consumption(self, choice_insulation=None, performance_insulation=None, index=None,\n                            level_heater='Heating system'):\n        \"\"\"Calculate standard energy consumption and energy performance certificate for each choice insulation for all\n        households.\n\n        Standard energy consumption only depends on building characteristics.\n\n        Returns\n        -------\n        DataFrame\n            Final consumption standard.\n        DataFrame\n            Primary consumption standard 3 uses.\n        DataFrame\n            Cerfificate.\n        \"\"\"\n\n        if index is None:\n            index = self.stock.index\n\n        if not isinstance(choice_insulation, MultiIndex):\n            choice_insulation = self._choice_insulation\n\n        if not isinstance(performance_insulation, MultiIndex):\n            performance_insulation = self._performance_insulation\n\n        # only selecting useful levels\n        indx = index.copy()\n        indx = indx.droplevel([i for i in indx.names if i not in ['Housing type', 'Wall', 'Floor', 'Roof', 'Windows'] + [level_heater]])\n        indx = indx[~indx.duplicated()]\n\n        # remove idx already calculated\n        if not self.consumption_sd_building_choice.empty:\n            temp = self.consumption_sd_building_choice.index.intersection(indx)\n            idx = indx.drop(temp)\n        else:\n            idx = indx\n\n        if not idx.empty:\n            s = concat([Series(index=idx, dtype=float)] * len(choice_insulation), axis=1).set_axis(choice_insulation, axis=1)\n            # choice_insulation = choice_insulation.drop(no_insulation) # only for\n            s.index.rename({'Wall': 'Wall before', 'Floor': 'Floor before', 'Roof': 'Roof before', 'Windows': 'Windows before'}, inplace=True)\n            temp = s.fillna(0).stack(s.columns.names)\n            temp = temp.reset_index().drop(0, axis=1)\n            for i in ['Wall', 'Floor', 'Roof', 'Windows']:\n                # keep the info to unstack later\n                temp.loc[:, '{} bool'.format(i)] = temp.loc[:, i]\n                temp.loc[temp[i], i] = performance_insulation[i]\n                temp.loc[temp[i] == False, i] = temp.loc[temp[i] == False, '{} before'.format(i)]\n            temp = temp.astype(\n                {'Housing type': 'string', 'Wall': 'float', 'Floor': 'float', 'Roof': 'float', 'Windows': 'float',\n                 level_heater: 'string'})\n            index = MultiIndex.from_frame(temp)\n            # consumption based on insulated components\n            consumption_sd, consumption_3uses, certificate = self.consumption_standard(index, level_heater=level_heater)\n\n            rslt = dict()\n            for key, temp in {'consumption_sd': consumption_sd, 'consumption_3uses': consumption_3uses, 'certificate': certificate}.items():\n                temp = reindex_mi(temp, index).droplevel(['Wall', 'Floor', 'Roof', 'Windows']).unstack(\n                    ['{} bool'.format(i) for i in ['Wall', 'Floor', 'Roof', 'Windows']])\n                temp.index.rename({'Wall before': 'Wall', 'Floor before': 'Floor', 'Roof before': 'Roof', 'Windows before': 'Windows'},\n                                  inplace=True)\n                temp.columns.rename({'Wall bool': 'Wall', 'Floor bool': 'Floor', 'Roof bool': 'Roof', 'Windows bool': 'Windows'},\n                                    inplace=True)\n                rslt[key] = temp\n\n            if self.consumption_sd_building_choice.empty:\n                self.consumption_sd_building_choice = rslt['consumption_sd']\n                self.consumption_3uses_building_choice = rslt['consumption_3uses']\n                self.certificate_building_choice = rslt['certificate']\n            else:\n                self.consumption_sd_building_choice = concat((self.consumption_sd_building_choice, rslt['consumption_sd']))\n                self.consumption_3uses_building_choice = concat((self.consumption_3uses_building_choice, rslt['consumption_3uses']))\n                self.certificate_building_choice = concat((self.certificate_building_choice, rslt['certificate']))\n\n        consumption_sd = self.consumption_sd_building_choice.loc[indx.rename({'Heating system': level_heater})]\n        consumption_sd.index.rename({'Heating system': level_heater}, inplace=True)\n\n        primary_consumption_3uses = self.consumption_3uses_building_choice.loc[indx]\n        primary_consumption_3uses.index.rename({'Heating system': level_heater}, inplace=True)\n\n        certificate = self.certificate_building_choice.loc[indx]\n        certificate.index.rename({'Heating system': level_heater}, inplace=True)\n\n        return consumption_sd, primary_consumption_3uses, certificate\n\n    def heater_replacement(self, stock, prices, cost_heater, policies_heater, ms_heater=None,\n                           probability_replacement=1/20):\n        \"\"\"Function returns new building stock after heater replacement.\n\n        Parameters\n        ----------\n        prices: Series\n        cost_heater: Series\n        ms_heater: DataFrame, optional\n        policies_heater: list\n        probability_replacement: float or Series, default 1/17\n        index: MultiIndex optional, default None\n\n        Returns\n        -------\n        Series\n        \"\"\"\n\n        if ms_heater is not None:\n            self._choice_heater = list(ms_heater.columns)\n\n        if isinstance(probability_replacement, float):\n            probability_replacement = Series(len(self._choice_heater) * [probability_replacement],\n                                                Index(self._choice_heater, name='Heating system final'))\n\n        index = stock.index\n\n        # prohibited energies can be a string or a list of strings\n        energy_regulations = [policy for policy in policies_heater if policy.policy == 'heater_regulation']\n        prohibited_energies = Series(list(array([policy.name.replace('_elimination', \"\").replace(\"_\", \" \").capitalize()\n                                             for policy in energy_regulations]).flat), index=[policy.name for policy in energy_regulations],\n                                        dtype=object)\n\n        for regulation in energy_regulations:\n            if regulation.value is not None:\n                heater = next(x for x in self._choice_heater if prohibited_energies[regulation.name] in x)\n                probability_replacement[heater] = regulation.value\n\n        self._probability_replacement = probability_replacement\n\n        list_heaters = self._choice_heater\n        for energy in prohibited_energies:\n            list_heaters = list(set(list_heaters) & set([heater for heater in self._choice_heater if energy not in heater]))\n\n        if energy_regulations:\n            choice_heater_idx = Index(list_heaters, name='Heating system final')\n        else:\n            choice_heater_idx = Index(self._choice_heater, name='Heating system final')\n\n        frame = Series(dtype=float, index=index).to_frame().dot(\n            Series(dtype=float, index=choice_heater_idx).to_frame().T)\n        cost_heater, tax_heater, subsidies_details, subsidies_total = self.apply_subsidies_heater(policies_heater,\n                                                                                                  cost_heater.copy(),\n                                                                                                  frame)\n        if self._endogenous:\n            subsidies_utility = subsidies_total.copy()\n            if 'reduced_tax' in subsidies_details.keys():\n                subsidies_utility -= subsidies_details['reduced_tax']\n            market_share = self.endogenous_market_share_heater(index, prices, subsidies_utility, cost_heater,\n                                                               ms_heater=ms_heater)\n\n        else:\n            market_share, probability_replacement = self.exogenous_market_share_heater(index, choice_heater_idx)\n\n        replacement = ((market_share * probability_replacement).T * stock).T\n\n        stock_replacement = replacement.stack('Heating system final')\n        to_replace = replacement.sum(axis=1)\n\n        stock = stock - to_replace\n\n        # adding heating system final equal to heating system because no switch\n        stock = concat((stock, Series(stock.index.get_level_values('Heating system'), index=stock.index,\n                                            name='Heating system final')), axis=1).set_index('Heating system final', append=True).squeeze()\n        stock = concat((stock.reorder_levels(stock_replacement.index.names), stock_replacement),\n                       axis=0, keys=[False, True], names=['Heater replacement'])\n        assert round(stock.sum() - self.stock_mobile.sum(), 0) == 0, 'Sum problem'\n\n        replaced_by = stock.droplevel('Heating system').rename_axis(index={'Heating system final': 'Heating system'})\n\n        if self.detailed_mode:\n            self.store_information_heater(cost_heater, subsidies_total, subsidies_details, replacement, tax_heater,\n                                          replaced_by)\n        else:\n            self.cost_heater = cost_heater\n\n        return stock\n\n    def apply_subsidies_heater(self, policies_heater, cost_heater, frame):\n        \"\"\"Calculate subsidies for each dwelling and each heating system.\n\n        Parameters\n        ----------\n        policies_heater: list\n        cost_heater: Series\n        frame: DataFrame\n            Index matches segments and columns heating system.\n\n        Returns\n        -------\n\n        \"\"\"\n\n        subsidies_total = DataFrame(0, index=frame.index, columns=frame.columns)\n        subsidies_details = {}\n\n        tax = self.vta\n        p = [p for p in policies_heater if 'reduced_tax' == p.policy]\n        if p:\n            tax = p[0].value\n            sub = cost_heater * (self.vta - tax)\n            subsidies_details.update({'reduced_tax': concat([sub] * frame.shape[0], keys=frame.index, axis=1).T})\n            subsidies_total += subsidies_details['reduced_tax']\n\n        tax_heater = cost_heater * tax\n        cost_heater += tax_heater\n\n        sub = None\n        for policy in policies_heater:\n            if policy.name not in self.policies and policy.policy in ['subsidy_target', 'subsidy_non_cumulative', 'subsidy_ad_volarem', 'subsidies_cap']:\n                self.policies += [policy.name]\n            if policy.policy == 'subsidy_target':\n                sub = policy.value.reindex(frame.columns, axis=1).fillna(0)\n                sub = reindex_mi(sub, frame.index)\n            elif policy.policy == 'subsidy_ad_volarem':\n\n                if isinstance(policy.value, (float, int)):\n                    sub = policy.value * cost_heater\n                    sub = concat([sub] * frame.shape[0], keys=frame.index, axis=1).T\n\n                if isinstance(policy.value, DataFrame):\n                    sub = policy.value * cost_heater\n                    sub = reindex_mi(sub, frame.index).fillna(0)\n\n                if isinstance(policy.value, Series):\n                    if policy.by == 'index':\n                        sub = policy.value.to_frame().dot(cost_heater.to_frame().T)\n                        sub = reindex_mi(sub, frame.index).fillna(0)\n                    elif policy.by == 'columns':\n                        sub = (policy.value * cost_heater).fillna(0).reindex(frame.columns)\n                        sub = concat([sub] * frame.shape[0], keys=frame.index, names=frame.index.names, axis=1).T\n                    else:\n                        raise NotImplemented\n                if policy.cap:\n                    sub[sub > policy.cap] = sub\n            else:\n                continue\n\n            subsidies_details[policy.name] = sub\n            subsidies_total += subsidies_details[policy.name]\n        return cost_heater, tax_heater, subsidies_details, subsidies_total\n\n    def store_information_heater(self, cost_heater, subsidies_total, subsidies_details, replacement, tax_heater,\n                                 replaced_by):\n        \"\"\"Store information yearly heater replacement.\n\n        Parameters\n        ----------\n        cost_heater: Series\n            Cost of each heating system (€).\n        subsidies_total: DataFrame\n            Total amount of eligible subsidies by dwelling and heating system (€).\n        subsidies_details: dict\n            Amount of eligible subsidies by dwelling and heating system (€).\n        replacement: DataFrame\n            Number of heating system replacement by dwelling and heating system chosen.\n        tax_heater: Series\n            VTA tax of each heating system (€).\n        replaced_by: Series\n            Dwelling updated with a new heating system.\n        \"\"\"\n        # information stored during\n        self.cost_heater = cost_heater\n        self.subsidies_heater_indiv = subsidies_total\n        self.subsidies_details_heater = subsidies_details\n        self.replacement_heater = replacement\n        self.investment_heater = replacement * cost_heater\n        self.tax_heater = replacement * tax_heater\n        self.subsidies_heater = replacement * subsidies_total\n        self.heater_replaced = replaced_by\n        for key in self.subsidies_details_heater.keys():\n            self.subsidies_details_heater[key] *= replacement\n\n        for key, sub in self.subsidies_details_heater.items():\n            mask = sub.copy()\n            mask[mask > 0] = 1\n            self.subsidies_count_heater.update({key: (replacement.fillna(0) * mask).sum().sum()})\n            self.subsidies_average_heater.update({key: sub.sum().sum() / replacement.fillna(0).sum().sum()})\n\n    def calibration_constant_heater(self, utility, ms_heater):\n        \"\"\"Constant to match the observed market-share.\n\n        Market-share is defined by initial and final heating system.\n\n        Parameters\n        ----------\n        utility: DataFrame\n        ms_heater: DataFrame\n\n        Returns\n        -------\n        DataFrame\n        \"\"\"\n\n        # removing unnecessary level\n        utility_ref = utility.droplevel(['Occupancy status']).copy()\n        utility_ref = utility_ref[~utility_ref.index.duplicated(keep='first')]\n\n        possible = reindex_mi(ms_heater, utility_ref.index)\n        utility_ref[~(possible > 0)] = float('nan')\n\n        stock = self.stock.groupby(utility_ref.index.names).sum()\n\n        # initializing constant to 0\n        constant = ms_heater.copy()\n        constant[constant > 0] = 0\n        market_share_ini, market_share_agg = None, None\n        for i in range(50):\n            constant.loc[constant['Electricity-Heat pump water'].notna(), 'Electricity-Heat pump water'] = 0\n            constant.loc[constant['Electricity-Heat pump water'].isna(), 'Electricity-Heat pump air'] = 0\n\n            utility_constant = reindex_mi(constant.reindex(utility_ref.columns, axis=1), utility.index)\n            utility = utility_ref + utility_constant\n            market_share = (exp(utility).T / exp(utility).sum(axis=1)).T\n            agg = (market_share.T * stock).T.groupby(['Housing type', 'Heating system']).sum()\n            market_share_agg = (agg.T / agg.sum(axis=1)).T\n            if i == 0:\n                market_share_ini = market_share_agg.copy()\n            constant = constant + log(ms_heater / market_share_agg)\n\n            ms_heater = ms_heater.reindex(market_share_agg.index)\n\n            if (market_share_agg.round(decimals=3) == ms_heater.round(decimals=3).fillna(0)).all().all():\n                self.logger.debug('Constant heater optim worked')\n                break\n\n        constant.loc[constant['Electricity-Heat pump water'].notna(), 'Electricity-Heat pump water'] = 0\n        constant.loc[constant['Electricity-Heat pump water'].isna(), 'Electricity-Heat pump air'] = 0\n\n        details = concat((constant.stack(), market_share_ini.stack(), market_share_agg.stack(), ms_heater.stack()),\n                         axis=1, keys=['constant', 'calcul ini', 'calcul', 'observed']).round(decimals=3)\n        if self.path is not None:\n            details.to_csv(os.path.join(self.path_calibration, 'calibration_constant_heater.csv'))\n\n        return constant\n\n    def endogenous_market_share_heater(self, index, prices, subsidies_total, cost_heater, ms_heater=None):\n\n        choice_heater = self._choice_heater\n        choice_heater_idx = Index(choice_heater, name='Heating system final')\n        energy = Series(choice_heater).str.split('-').str[0].set_axis(choice_heater_idx)\n\n        temp = pd.Series(0, index=index, dtype='float').to_frame().dot(pd.Series(0, index=choice_heater_idx, dtype='float').to_frame().T)\n        index_final = temp.stack().index\n        heat_consumption_sd, _, certificate = self.consumption_standard(index_final, level_heater='Heating system final')\n        heat_consumption_sd = reindex_mi(heat_consumption_sd.unstack('Heating system final'), index)\n        prices_re = prices.reindex(energy).set_axis(heat_consumption_sd.columns)\n        energy_bill_sd = ((heat_consumption_sd * prices_re).T * reindex_mi(self._surface, index)).T\n\n        consumption_before = self.consumption_standard(index, level_heater='Heating system')[0]\n        consumption_before = reindex_mi(consumption_before, index) * reindex_mi(self._surface, index)\n        energy_bill_before = AgentBuildings.energy_bill(prices, consumption_before)\n\n        bill_saved = - energy_bill_sd.sub(energy_bill_before, axis=0)\n        utility_bill_saving = (bill_saved.T * reindex_mi(self.preferences_heater['bill_saved'], bill_saved.index)).T / 1000\n        utility_bill_saving = utility_bill_saving.loc[:, choice_heater]\n\n        certificate = reindex_mi(certificate.unstack('Heating system final'), index)\n        certificate_before = self.consumption_standard(index)[2]\n        certificate_before = reindex_mi(certificate_before, index)\n\n        self.certificate_jump_heater = - certificate.replace(self._epc2int).sub(\n            certificate_before.replace(self._epc2int), axis=0)\n\n        utility_subsidies = subsidies_total * self.preferences_heater['subsidy'] / 1000\n\n        cost_heater = cost_heater.reindex(utility_bill_saving.columns)\n        pref_investment = reindex_mi(self.preferences_heater['investment'], utility_bill_saving.index).rename(None)\n        utility_investment = pref_investment.to_frame().dot(cost_heater.to_frame().T) / 1000\n\n        utility_inertia = DataFrame(0, index=utility_bill_saving.index, columns=utility_bill_saving.columns)\n        for hs in choice_heater:\n            utility_inertia.loc[\n                utility_inertia.index.get_level_values('Heating system') == hs, hs] = self.preferences_heater['inertia']\n\n        utility = utility_inertia + utility_investment + utility_bill_saving + utility_subsidies\n\n        if (self.constant_heater is None) and (ms_heater is not None):\n            ms_heater.dropna(how='all', inplace=True)\n            self.constant_heater = self.calibration_constant_heater(utility, ms_heater)\n        utility_constant = reindex_mi(self.constant_heater.reindex(utility.columns, axis=1), utility.index)\n\n        utility += utility_constant\n        market_share = (exp(utility).T / exp(utility).sum(axis=1)).T\n\n        return market_share\n\n    def exogenous_market_share_heater(self, index, choice_heater_idx):\n        \"\"\"Define exogenous market-share.\n\n        Market-share is defined by _market_share_exogenous attribute.\n        Replacement\n\n        Parameters\n        ----------\n        index: MultiIndex\n        choice_heater_idx: Index\n\n        Returns\n        -------\n        DataFrame\n            Market-share by segment and possible heater choice.\n        Series\n            Probability replacement.\n        \"\"\"\n        self._market_share_exogenous = {'Wood fuel-Standard boiler': 'Wood fuel-Performance boiler',\n                                        'Wood fuel-Performance boiler': 'Wood fuel-Performance boiler',\n                                        'Oil fuel-Standard boiler': 'Oil fuel-Performance boiler',\n                                        'Oil fuel-Performance boiler': 'Oil fuel-Performance boiler',\n                                        'Natural gas-Standard boiler': 'Natural gas-Performance boiler',\n                                        'Natural gas-Performance boiler': 'Natural gas-Performance boiler',\n                                        'Electricity-Performance boiler': 'Electricity-Heat pump',\n                                        'Electricity-Heat pump': 'Electricity-Heat pump'}\n\n        market_share = Series(index=index, dtype=float).to_frame().dot(\n            Series(index=choice_heater_idx, dtype=float).to_frame().T)\n\n        for initial, final in self._market_share_exogenous.items():\n            market_share.loc[market_share.index.get_level_values('Heating system') == initial, final] = 1\n\n        to_replace = self.stock_mobile[self.certificate.isin(self._target_exogenous)]\n\n        if to_replace.sum() < self._number_exogenous:\n            self._target_exogenous = ['E', 'F', 'G']\n            to_replace = self.stock_mobile[self.certificate.isin(self._target_exogenous)]\n            if to_replace.sum() < self._number_exogenous:\n                self._target_exogenous = ['D', 'E', 'F', 'G']\n                to_replace = self.stock_mobile[self.certificate.isin(self._target_exogenous)]\n                if to_replace.sum() < self._number_exogenous:\n                    self._target_exogenous = ['C', 'D', 'E', 'F', 'G']\n                    to_replace = self.stock_mobile[self.certificate.isin(self._target_exogenous)]\n                    if to_replace.sum() < self._number_exogenous:\n                        self._number_exogenous = 0\n\n        to_replace = to_replace / to_replace.sum() * self._number_exogenous\n\n        to_replace = to_replace.groupby(index.names).sum()\n        probability_replacement = (to_replace / self.stock_mobile.groupby(index.names).sum()).fillna(0)\n        probability_replacement = probability_replacement.reindex(market_share.index)\n        return market_share, probability_replacement\n\n    def insulation_replacement(self, stock, prices, cost_insulation_raw, ms_insulation=None, renovation_rate_ini=None,\n                               policies_insulation=None, target_freeriders=None, financing_cost=None):\n        \"\"\"Calculate insulation retrofit in the dwelling stock.\n\n        1. Intensive margin\n        2. Extensive margin\n        Calibrate function first year.\n\n        Consumption saving only depends on insulation work.\n        However, certificate upgrade also consider the heat\n\n        To reduce calculation time attributes are grouped.\n        Cost, subsidies and constant depends on Housing type, Occupancy status, Housing type and Insulation performance.\n\n        Parameters\n        ----------\n        financing_cost\n        stock: Series\n        prices: Series\n        cost_insulation_raw: Series\n            €/m2 of losses area by component.\n        ms_insulation: Series\n        renovation_rate_ini: Series\n        policies_insulation: list\n        target_freeriders: float\n\n        Returns\n        -------\n        Series\n            Retrofit rate\n        DataFrame\n            Market-share insulation\n        \"\"\"\n\n        index = stock.index\n\n        _, _, certificate_before_heater = self.consumption_standard(index, level_heater='Heating system')\n        # index only contains building with energy performance > B\n        c_before = reindex_mi(certificate_before_heater, index)\n        index = c_before[c_before > 'B'].index\n\n        # before include the change of heating system\n        _, consumption_3uses_before, certificate_before = self.consumption_standard(index,\n                                                                                    level_heater='Heating system final')\n        certificate_before = certificate_before[certificate_before > 'B']\n        consumption_3uses_before = consumption_3uses_before.loc[certificate_before.index]\n\n        surface = reindex_mi(self._surface, index)\n\n        _, consumption_3uses, certificate = self.prepare_consumption(self._choice_insulation, index=index,\n                                                                     level_heater='Heating system final')\n        energy_saved_3uses = ((consumption_3uses_before - consumption_3uses.T) / consumption_3uses_before).T\n        energy_saved_3uses.dropna(inplace=True)\n\n        cost_insulation = self.prepare_cost_insulation(cost_insulation_raw * self.surface_insulation)\n        cost_insulation = cost_insulation.T.multiply(self._surface, level='Housing type').T\n\n        cost_insulation, tax_insulation, tax, subsidies_details, subsidies_total, condition, certificate_jump_all = self.apply_subsidies_insulation(\n            index, policies_insulation, cost_insulation, surface, certificate, certificate_before, certificate_before_heater, energy_saved_3uses)\n\n        if self.detailed_mode:\n            self.store_information_insulation(certificate_jump_all, condition, cost_insulation_raw, tax, cost_insulation,\n                                              tax_insulation, subsidies_details, subsidies_total)\n        else:\n            self.subsidies_details_insulation = subsidies_details\n\n        if self._endogenous:\n            if 'reduced_tax' in subsidies_details.keys():\n                subsidies_total -= subsidies_details['reduced_tax']\n\n            delta_subsidies = None\n            if (self.year in [self.first_year + 1]) and (self.scale_ext is None):\n                delta_subsidies = subsidies_details['cite'].copy()\n\n            retrofit_rate, market_share = self.endogenous_retrofit(stock, prices, subsidies_total,\n                                                                   cost_insulation,\n                                                                   ms_insulation=ms_insulation,\n                                                                   renovation_rate_ini=renovation_rate_ini,\n                                                                   delta_subsidies=delta_subsidies,\n                                                                   target_freeriders=target_freeriders,\n                                                                   financing_cost=financing_cost)\n            self.retrofit_rate, self.market_share = retrofit_rate, market_share\n\n        else:\n            retrofit_rate, market_share = self.exogenous_retrofit(index, self._choice_insulation)\n\n        return retrofit_rate, market_share\n\n    def apply_subsidies_insulation(self, index, policies_insulation, cost_insulation, surface, certificate,\n                                   certificate_before, certificate_before_heater, energy_saved_3uses):\n        \"\"\"Calculate subsidies amount for each possible insulation choice.\n\n\n        Parameters\n        ----------\n        index\n        policies_insulation: list\n        cost_insulation: DataFrame\n            Cost for each segment and each possible insulation choice (€).\n        surface: Series\n            Surface / dwelling for each segment (m2/dwelling).\n        certificate : DataFrame\n            Certificate by segment after insulation replacement for each possible insulation choice.\n        certificate_before : Series\n            Certificate by segment before insulation (but after heater replacement)\n        certificate_before_heater: Series\n            Certificate by segment before insulation, and before heater replacement. Useful to calculate the total\n            number of upgrade this year.\n        energy_saved_3uses: DataFrame\n            Primary conventional energy consumption saved by the insulation work (% - kWh PE/m2).\n\n        Returns\n        -------\n        cost_insulation: DataFrame\n        tax_insulation: DataFrame\n        tax : float\n        subsidies_details: dict\n        subsidies_total: DataFrame\n        condition: dict\n        certificate_jump_all: DataFrame\n        \"\"\"\n\n        def defined_condition(index_segments, certif, certif_before, certif_before_heater, saved_3uses):\n            \"\"\"Define condition to get subsidies or loan.\n\n            Depends on income (index) and energy performance of renovationd defined by certificate jump or\n            energy_saved_3uses.\n\n            Parameters\n            ----------\n            index_segments: MultiIndex\n            certif: DataFrame\n            certif_before: Series\n            certif_before_heater: Series\n            saved_3uses: DataFrame\n\n            Returns\n            -------\n            condition: dict\n                Contains boolean DataFrame that established condition to get subsidies.\n            certificate_jump: DataFrame\n                Insulation (without account for heater replacement) allowed to jump of at least one certificate.\n            certificate_jump_all: DataFrame\n                Renovation (including heater replacement) allowed to jump of at least one certificate.\n            \"\"\"\n\n            def define_zil_target(certif, certif_before, saved_3uses):\n                \"\"\"Define target (households and insulation work) that can get zil.\n\n                Zero_interest_loan_old is the target in terms of EPC jump.\n                zero_interest_loan_new is the requirement to be eligible to a 'global renovation' program,\n                the renovation must reduce of 35% the conventional primary energy need\n                and the resulting building must not be of G or F epc level.\n\n                Parameters\n                ----------\n                certif\n                certif_before\n                saved_3uses\n\n                Returns\n                -------\n                target_subsidies: pd.DataFrame\n                    Each cell, a gesture and a segment, is a boolean which is True if it is targeted by the policy\n\n                \"\"\"\n                energy_saved_min = 0.35\n\n                target_subsidies = {}\n                target_0 = certif.isin(['D', 'C', 'B', 'A']).astype(int).mul(\n                    certif_before.isin(['G', 'F', 'E']).astype(int), axis=0).astype(bool)\n                target_1 = certif.isin(['B', 'A']).astype(int).mul(certif_before.isin(['D', 'C']).astype(int),\n                                                                   axis=0).astype(bool)\n                target_subsidies['zero_interest_loan_old'] = target_0 | target_1\n\n                target_0 = certif.isin(['E', 'D', 'C', 'B', 'A']).astype(bool)\n                target_1 = saved_3uses[saved_3uses >= energy_saved_min].fillna(0).astype(bool)\n                target_subsidies['zero_interest_loan_new'] = target_0 & target_1\n\n                return target_subsidies\n\n            condition_target = dict()\n\n            self.out_worst = (~certif.isin(['G', 'F'])).T.multiply(certif_before.isin(['G', 'F'])).T\n            self.out_worst = reindex_mi(self.out_worst, index_segments).fillna(False).astype('float')\n            self.in_best = (certif.isin(['A', 'B'])).T.multiply(~certif_before.isin(['A', 'B'])).T\n            self.in_best = reindex_mi(self.in_best, index_segments).fillna(False).astype('float')\n\n            condition_target.update({'bonus_worst': self.out_worst})\n            condition_target.update({'bonus_best': self.in_best})\n\n            minimum_gest_condition, global_condition = 1, 2\n            energy_condition = 0.35\n\n            certificate_jump = - certif.replace(self._epc2int).sub(certif_before.replace(self._epc2int),\n                                                                   axis=0)\n            certificate_jump = reindex_mi(certificate_jump, index_segments)\n            certificate_jump_condition = certificate_jump >= minimum_gest_condition\n\n            certif_before_heater = reindex_mi(certif_before_heater, index_segments)\n            certif = reindex_mi(certif, index_segments)\n            certificate_jump_all = - certif.replace(self._epc2int).sub(\n                certif_before_heater.replace(self._epc2int),\n                axis=0)\n\n            condition_target.update({'certificate_jump': certificate_jump_all >= minimum_gest_condition})\n            condition_target.update({'global_renovation': certificate_jump_all >= global_condition})\n\n            low_income_condition = ['D1', 'D2', 'D3', 'D4']\n            if self.quintiles:\n                low_income_condition = ['C1', 'C2']\n            low_income_condition = index_segments.get_level_values('Income owner').isin(low_income_condition)\n            low_income_condition = pd.Series(low_income_condition, index=index_segments)\n\n            high_income_condition = ['D5', 'D6', 'D7', 'D8', 'D9', 'D10']\n            if self.quintiles:\n                high_income_condition = ['C3', 'C4', 'C5']\n            high_income_condition = index_segments.get_level_values('Income owner').isin(high_income_condition)\n            high_income_condition = pd.Series(high_income_condition, index=index_segments)\n\n            global_renovation_low_income = (low_income_condition * condition_target['global_renovation'].T).T\n            condition_target.update({'global_renovation_low_income': global_renovation_low_income})\n\n            global_renovation_high_income = (high_income_condition * condition_target['global_renovation'].T).T\n            condition_target.update({'global_renovation_high_income': global_renovation_high_income})\n\n            energy_condition = saved_3uses >= energy_condition\n\n            condition_mpr_serenite = (reindex_mi(energy_condition, index_segments).T * low_income_condition).T\n            condition_target.update({'mpr_serenite': condition_mpr_serenite})\n\n            condition_zil = define_zil_target(certif, certif_before, saved_3uses)\n            condition_target.update({'zero_interest_loan': condition_zil})\n\n            return condition_target, certificate_jump, certificate_jump_all\n\n        def apply_regulation(idx_target, idx_replace, level):\n            \"\"\"Apply regulation by replacing utility specific constant.\n\n\n            Example removing the split incentive between landlord and tenant.\n\n            Parameters\n            ----------\n            idx_target: str\n                Index to replace. Example: 'Privately rented'.\n            idx_replace: str\n                Index replaced by. Example: 'Owner-occupied'.\n            level: str\n                Level to look for index. Example: 'Occupancy status'\n\n            \"\"\"\n            temp = self.constant_insulation_extensive.copy()\n            temp = temp.drop(temp[temp.index.get_level_values(level) == idx_target].index)\n            t = temp[temp.index.get_level_values(level) == idx_replace]\n            t.rename(index={idx_replace: idx_target}, inplace=True)\n            temp = pd.concat((temp, t)).loc[self.constant_insulation_extensive.index]\n            self.constant_insulation_extensive = temp.copy()\n\n        subsidies_total = DataFrame(0, index=index, columns=cost_insulation.columns)\n        subsidies_details = {}\n\n        tax = self.vta\n        p = [p for p in policies_insulation if 'reduced_tax' == p.policy]\n        if p:\n            tax = p[0].value\n            subsidies_details.update({p[0].name: reindex_mi(cost_insulation * (self.vta - tax), index)})\n            subsidies_total += subsidies_details['reduced_tax']\n\n        tax_insulation = cost_insulation * tax\n        cost_insulation += tax_insulation\n\n        condition, certificate_jump, certificate_jump_all = defined_condition(index, certificate, certificate_before,\n                                                                              certificate_before_heater,\n                                                                              energy_saved_3uses)\n\n        for policy in policies_insulation:\n            if policy.name not in self.policies and policy.policy in ['subsidy_target', 'subsidy_non_cumulative', 'subsidy_ad_volarem', 'subsidies_cap']:\n                self.policies += [policy.name]\n\n            if policy.policy == 'subsidy_target':\n                temp = (reindex_mi(self.prepare_subsidy_insulation(policy.value),\n                                   index).T * surface).T\n                subsidies_total += temp\n\n                if policy.name in subsidies_details.keys():\n                    subsidies_details[policy.name] = subsidies_details[policy.name] + temp\n                else:\n                    subsidies_details[policy.name] = temp.copy()\n\n            elif policy.policy == 'bonus_best':\n                temp = (reindex_mi(policy.value, condition['bonus_best'].index) * condition['bonus_best'].T).T\n                subsidies_total += temp\n                if policy.name in subsidies_details.keys():\n                    subsidies_details[policy.name] = subsidies_details[policy.name] + temp\n\n                else:\n                    subsidies_details[policy.name] = temp.copy()\n\n            elif policy.policy == 'bonus_worst':\n                temp = (reindex_mi(policy.value, condition['bonus_worst'].index) * condition['bonus_worst'].T).T\n                subsidies_total += temp\n\n                if policy.name in subsidies_details.keys():\n                    subsidies_details[policy.name] = subsidies_details[policy.name] + temp\n\n                else:\n                    subsidies_details[policy.name] = temp.copy()\n\n            elif policy.policy == 'subsidy_ad_volarem':\n\n                cost = policy.cost_targeted(reindex_mi(cost_insulation, index), target_subsidies=condition.get(policy.name),\n                                            cost_included=self.cost_heater.copy())\n\n                if isinstance(policy.value, (Series, float)):\n                    temp = reindex_mi(policy.value, cost.index)\n                    subsidies_details[policy.name] = (temp * cost.T).T\n                    subsidies_total += subsidies_details[policy.name]\n                else:\n                    temp = self.prepare_subsidy_insulation(policy.value, policy=policy.policy)\n                    temp = reindex_mi(temp, cost.index)\n                    subsidies_details[policy.name] = temp * cost\n                    subsidies_total += subsidies_details[policy.name]\n                if policy.name == 'zero_interest_loan':\n                    self.zil_loaned = cost.copy()\n\n            elif policy.policy == 'zero_interest_loan':\n\n                cost = policy.cost_targeted(reindex_mi(cost_insulation, index), target_subsidies=condition.get(policy.name),\n                                            cost_included=self.cost_heater.copy())\n                subsidies_details[policy.name] = policy.value * cost\n                subsidies_total += subsidies_details[policy.name]\n                self.zil_loaned = cost.copy()\n\n        subsidies_non_cumulative = [p for p in policies_insulation if p.policy == 'subsidy_non_cumulative']\n        if subsidies_non_cumulative is not []:\n            for policy in subsidies_non_cumulative:\n                sub = (reindex_mi(policy.value, condition[policy.name].index) * condition[policy.name].T).T\n                sub = sub.astype(float)\n                for name in policy.non_cumulative:\n                    # TODO: could be a bug here when policy.non_cumulative are all there and when non cumulative alone\n                    if name in subsidies_details.keys():\n                        subsidies_total -= subsidies_details[name]\n                        comp = reindex_mi(subsidies_details[name], sub.index)\n                        temp = comp.where(comp > sub, 0)\n                        subsidies_details[name] = temp.copy()\n                        temp = sub.where(sub > comp, 0)\n                        subsidies_details[policy.name] = temp.copy()\n                        subsidies_total += subsidies_details[name] + subsidies_details[policy.name]\n\n        subsidies_cap = [p for p in policies_insulation if p.policy == 'subsidies_cap']\n        subsidies_uncaped = subsidies_total.copy()\n\n        if 'reduced_tax' in subsidies_details.keys():\n            subsidies_uncaped -= subsidies_details['reduced_tax']\n\n        zil = [p for p in policies_insulation if p.policy == 'subsidy_ad_volarem' and p.name == 'zero_interest_loan']\n        if 'zero_interest_loan' in subsidies_details.keys() and zil is []:\n            subsidies_uncaped -= subsidies_details['zero_interest_loan']\n\n        if subsidies_cap:\n            subsidies_cap = subsidies_cap[0]\n            subsidies_cap = reindex_mi(subsidies_cap.value, subsidies_uncaped.index)\n            cap = (reindex_mi(cost_insulation, index).T * subsidies_cap).T\n            over_cap = subsidies_uncaped > cap\n            subsidies_details['over_cap'] = (subsidies_uncaped - cap)[over_cap].fillna(0)\n            remaining = subsidies_details['over_cap'].copy()\n            if 'mpr_serenite' in subsidies_details.keys():\n                temp = subsidies_details['over_cap'].where(\n                    subsidies_details['over_cap'] <= subsidies_details['mpr_serenite'],\n                    subsidies_details['mpr_serenite'])\n                subsidies_details['mpr_serenite'] -= temp\n                remaining = subsidies_details['over_cap'] - temp\n                assert (subsidies_details['mpr_serenite'].values >= 0).all(), 'MPR Serenite got negative values'\n            if 'mpr' in subsidies_details.keys() and not (remaining > 0).any().any():\n                subsidies_details['mpr'] -= remaining\n                assert (subsidies_details['mpr'].values >= 0).all(), 'MPR got negative values'\n\n            subsidies_total -= subsidies_details['over_cap']\n\n        regulation = [p for p in policies_insulation if p.policy == 'regulation']\n        if 'landlord' in [p.name for p in regulation]:\n            apply_regulation('Privately rented', 'Owner-occupied', 'Occupancy status')\n        if 'multi_family' in [p.name for p in regulation]:\n            apply_regulation('Multi-family', 'Single-family', 'Housing type')\n\n        return cost_insulation, tax_insulation, tax, subsidies_details, subsidies_total, condition, certificate_jump_all\n\n    def store_information_insulation(self, certificate_jump_all, condition, cost_insulation_raw, tax, cost_insulation,\n                                     tax_insulation, subsidies_details, subsidies_total):\n        \"\"\"Store insulation information.\n\n        Parameters\n        ----------\n        certificate_jump_all\n        condition: dict\n        cost_insulation_raw: Series\n            Cost of insulation for each envelope component of losses surface (€/m2).\n        tax: float\n            VTA to apply (%).\n        cost_insulation: DataFrame\n            Cost insulation for each dwelling and each insulation gesture (€).\n        tax_insulation: DataFrame\n            VTA applied to each insulation gesture cost (€).\n        subsidies_details: dict\n            Amount of subsidies for each dwelling and each insulation gesture (€).\n        subsidies_total: DataFrame\n            Total mount of subsidies for each dwelling and each insulation gesture (€).\n        retrofit_rate: Series\n        \"\"\"\n\n        # self.certificate_jump = condition['certificate_jump']\n        self.certif_jump_all = certificate_jump_all\n        self.global_renovation = condition['global_renovation']\n        self.in_global_renovation_high_income = condition['global_renovation_high_income']\n        self.in_global_renovation_low_income = condition['global_renovation_low_income']\n        self.cost_component = cost_insulation_raw * self.surface_insulation * (1 + tax)\n        self.subsidies_details_insulation = subsidies_details\n        self.subsidies_insulation_indiv = subsidies_total\n        self.cost_insulation_indiv = cost_insulation\n        self.tax_insulation = tax_insulation\n\n    def store_information_retrofit(self, replaced_by):\n        \"\"\"Calculate and store main statistics based on yearly retrofit.\n\n        Parameters\n        ----------\n        replaced_by: DataFrame\n            Retrofit flow for each dwelling (index) and each insulation gesture (columns).\n            Dwelling must be defined with 'Heating system final' and 'Heater replacement'.\n        \"\"\"\n\n        levels = [i for i in replaced_by.index.names if i not in ['Heater replacement', 'Heating system final']]\n        if 'Heater replacement' not in replaced_by.index.names:\n            replaced_by = concat([replaced_by], keys=[False], names=['Heater replacement'])\n        if 'Heating system final' not in replaced_by.index.names:\n            temp = replaced_by.reset_index('Heating system')\n            temp['Heating system final'] = temp['Heating system']\n            replaced_by = temp.set_index(['Heating system', 'Heating system final'], append=True).squeeze()\n\n        replaced_by.index = replaced_by.index.reorder_levels(self.in_global_renovation_high_income.index.names)\n\n        self.global_renovation_high_income += (replaced_by * self.in_global_renovation_high_income).sum().sum()\n        self.global_renovation_low_income += (replaced_by * self.in_global_renovation_low_income).sum().sum()\n        self.bonus_best += (replaced_by * self.in_best).sum().sum()\n        self.bonus_worst += (replaced_by * self.out_worst).sum().sum()\n        if self.replacement_insulation is None:\n            self.replacement_insulation = replaced_by.groupby(levels).sum()\n            self.investment_insulation = (replaced_by * self.cost_insulation_indiv).groupby(levels).sum()\n            self.taxed_insulation = (replaced_by * self.tax_insulation).groupby(levels).sum()\n            self.subsidies_insulation = (replaced_by * self.subsidies_insulation_indiv).groupby(levels).sum()\n\n            for key in self.subsidies_details_insulation.keys():\n                self.subsidies_details_insulation[key] = (replaced_by * reindex_mi(\n                    self.subsidies_details_insulation[key], replaced_by.index)).groupby(levels).sum()\n\n            rslt = {}\n            l = unique(self.certif_jump_all.values.ravel('K'))\n            for i in l:\n                rslt.update({i: ((self.certif_jump_all == i) * replaced_by).sum(axis=1)})\n            self.certificate_jump_all = DataFrame(rslt).groupby(levels).sum()\n\n            gest = {1: [(False, False, False, True), (False, False, True, False), (False, True, False, False),\n                        (True, False, False, False)],\n                    2: [(False, False, True, True), (False, True, False, True), (True, False, False, True),\n                        (True, False, True, False),\n                        (True, True, False, False), (False, True, True, False)],\n                    3: [(False, True, True, True), (True, False, True, True), (True, True, False, True),\n                        (True, True, True, False)],\n                    4: [(True, True, True, True)]}\n            rslt = {i: 0 for i in range(1, 6)}\n            for n, g in gest.items():\n                rslt[n] += replaced_by.loc[:, g].xs(False, level='Heater replacement').sum().sum()\n                rslt[n + 1] += replaced_by.loc[:, g].xs(True, level='Heater replacement').sum().sum()\n            self.gest_nb = Series(rslt)\n\n            self.retrofit_with_heater = replaced_by.xs(True, level='Heater replacement').sum().sum()\n\n            for key, sub in self.subsidies_details_insulation.items():\n                mask = sub.copy()\n                mask[mask > 0] = 1\n                self.subsidies_count_insulation[key] = (replaced_by.fillna(0) * mask).sum().sum()\n                self.subsidies_average_insulation[key] = sub.sum().sum() / replaced_by.fillna(0).sum().sum()\n\n                \"\"\"if key == 'zero_interest_loan':\n                    total_loaned = (replaced_by.fillna(0) * self.zil_loaned).sum().sum()\n                    self.zil_loaned_avg = total_loaned / self.zil_count\"\"\"\n\n        else:\n            self.replacement_insulation += replaced_by.groupby(levels).sum()\n            self.investment_insulation += (replaced_by * self.cost_insulation_indiv).groupby(levels).sum()\n            self.taxed_insulation += (replaced_by * self.tax_insulation).groupby(levels).sum()\n            self.subsidies_insulation += (replaced_by * self.subsidies_insulation_indiv).groupby(levels).sum()\n\n            for key in self.subsidies_details_insulation.keys():\n                self.subsidies_details_insulation[key] += (replaced_by * reindex_mi(\n                    self.subsidies_details_insulation[key], replaced_by.index)).groupby(levels).sum()\n\n            rslt = {}\n            l = unique(self.certif_jump_all.values.ravel('K'))\n            for i in l:\n                rslt.update({i: ((self.certif_jump_all == i) * replaced_by).sum(axis=1)})\n            self.certificate_jump_all += DataFrame(rslt).groupby(levels).sum()\n\n            gest = {1: [(False, False, False, True), (False, False, True, False), (False, True, False, False),\n                        (True, False, False, False)],\n                    2: [(False, False, True, True), (False, True, False, True), (True, False, False, True),\n                        (True, False, True, False),\n                        (True, True, False, False), (False, True, True, False)],\n                    3: [(False, True, True, True), (True, False, True, True), (True, True, False, True),\n                        (True, True, True, False)],\n                    4: [(True, True, True, True)]}\n            rslt = {i: 0 for i in range(1, 6)}\n            for n, g in gest.items():\n                rslt[n] += replaced_by.loc[:, g].xs(False, level='Heater replacement').sum().sum()\n                # rslt[n + 1] += replaced_by.loc[:, g].xs(True, level='Heater replacement').sum().sum()\n            self.gest_nb += Series(rslt)\n\n            # self.retrofit_with_heater += replaced_by.xs(True, level='Heater replacement').sum().sum()\n\n            for key, sub in self.subsidies_details_insulation.items():\n                mask = sub.copy()\n                mask[mask > 0] = 1\n                self.subsidies_count_insulation[key] += (replaced_by.fillna(0) * mask).sum().sum()\n                # self.subsidies_average_insulation[key] += sub.sum().sum() / replaced_by.fillna(0).sum().sum()\n\n    def prepare_cost_insulation(self, cost_insulation):\n        \"\"\"Constitute insulation choice set cost. Cost is equal to the sum of each individual cost component.\n\n        Parameters\n        ----------\n        cost_insulation: Series\n\n        Returns\n        -------\n        Series\n            Multiindex series. Levels are Wall, Floor, Roof and Windows and values are boolean.\n        \"\"\"\n        if self.prepared_cost_insulation is None:\n            cost = DataFrame(0, index=cost_insulation.index, columns=self._choice_insulation)\n            idx = IndexSlice\n            cost.loc[:, idx[True, :, :, :]] = (cost.loc[:, idx[True, :, :, :]].T + cost_insulation['Wall']).T\n            cost.loc[:, idx[:, True, :, :]] = (cost.loc[:, idx[:, True, :, :]].T + cost_insulation['Floor']).T\n            cost.loc[:, idx[:, :, True, :]] = (cost.loc[:, idx[:, :, True, :]].T + cost_insulation['Roof']).T\n            cost.loc[:, idx[:, :, :, True]] = (cost.loc[:, idx[:, :, :, True]].T + cost_insulation['Windows']).T\n            self.prepared_cost_insulation = cost.copy()\n            return cost\n        else:\n            # to reduce run time but doesn't seem to be very useful\n            return self.prepared_cost_insulation\n\n    def prepare_subsidy_insulation(self, subsidies_insulation, policy=None):\n        \"\"\"Constitute insulation choice set subsidies. Subsidies are equal to the sum of each individual subsidy.\n\n        Parameters\n        ----------\n        policy\n        subsidies_insulation: DataFrame\n\n        Returns\n        -------\n        DataFrame\n            Multiindex columns. Levels are Wall, Floor, Roof and Windows and values are boolean.\n        \"\"\"\n\n        idx = IndexSlice\n        subsidies = {}\n        for i in self.surface_insulation.index:\n            subsidy = DataFrame(0, index=subsidies_insulation.index, columns=self._choice_insulation)\n            subsidy.loc[:, idx[True, :, :, :]] = subsidy.loc[:, idx[True, :, :, :]].add(\n                subsidies_insulation['Wall'] * self.surface_insulation.loc[i, 'Wall'], axis=0)\n            subsidy.loc[:, idx[:, True, :, :]] = subsidy.loc[:, idx[:, True, :, :]].add(\n                subsidies_insulation['Floor'] * self.surface_insulation.loc[i, 'Floor'], axis=0)\n            subsidy.loc[:, idx[:, :, True, :]] = subsidy.loc[:, idx[:, :, True, :]].add(\n                subsidies_insulation['Roof'] * self.surface_insulation.loc[i, 'Roof'], axis=0)\n            subsidy.loc[:, idx[:, :, :, True]] = subsidy.loc[:, idx[:, :, :, True]].add(\n                subsidies_insulation['Windows'] * self.surface_insulation.loc[i, 'Windows'], axis=0)\n            subsidies[i] = subsidy.copy()\n        subsidies = concat(list(subsidies.values()), axis=0, keys=self.surface_insulation.index,\n                           names=self.surface_insulation.index.names)\n\n        if policy == 'subsidy_ad_volarem':\n            # NotImplemented: ad_volarem with different subsidides rate\n            value = [v for v in subsidies_insulation.stack().unique() if v != 0][0]\n            subsidies[subsidies > 0] = value\n\n        return subsidies\n\n    def endogenous_retrofit(self, stock, prices, subsidies_total, cost_insulation, ms_insulation=None,\n                            renovation_rate_ini=None, delta_subsidies=None, target_freeriders=0.85,\n                            financing_cost=None):\n        \"\"\"Calculate endogenous retrofit based on discrete choice model.\n\n        Utility variables are investment cost, energy bill saving, and subsidies.\n        Preferences are object attributes defined initially.\n\n        # bill saved calculated based on the new heating system\n        # certificate before work and so subsidies before the new heating system\n\n        Parameters\n        ----------\n        financing_cost\n        prices: Series\n        subsidies_total: DataFrame\n        cost_insulation: DataFrame\n        ms_insulation: Series, default None\n        renovation_rate_ini: Series, default None\n        stock: Series, default None\n        delta_subsidies: DataFrame, default None\n        target_freeriders: float, default 0.85\n\n        Returns\n        -------\n        Series\n            Retrofit rate\n        DataFrame\n            Market-share insulation\n        \"\"\"\n\n        def logit_model(bill_save, subsidies, investment, discount, coeff_landlord, collective):\n\n            util = - investment + subsidies + bill_save * discount * coeff_landlord + collective\n\n            if self.constant_test is not None:\n                util += self.constant_test\n\n            ms = (exp(util).T / exp(util).sum(axis=1)).T\n            return ms, util\n\n        def to_market_share(bill_save, subsidies, investment):\n            \"\"\"Calculate market-share between insulation options.\n\n\n            Parameters\n            ----------\n            bill_save: DataFrame\n            subsidies: DataFrame\n            investment: DataFrame\n\n            Returns\n            -------\n            ms_intensive: DataFrame\n            util_intensive: DataFrame\n            \"\"\"\n\n            pref_sub = reindex_mi(self.preferences_insulation_int['subsidy'], subsidies.index).rename(None)\n            utility_subsidies = (subsidies.T * pref_sub).T / 1000\n\n            pref_investment = reindex_mi(self.preferences_insulation_int['investment'], investment.index).rename(None)\n            utility_investment = (investment.T * pref_investment).T / 1000\n\n            utility_bill_saving = (bill_save.T * reindex_mi(self.preferences_insulation_int['bill_saved'], bill_save.index)).T / 1000\n\n            util_intensive = utility_bill_saving + utility_investment + utility_subsidies\n\n            if self.constant_insulation_intensive is not None:\n                util_intensive += self.constant_insulation_intensive\n\n            ms_intensive = (exp(util_intensive).T / exp(util_intensive).sum(axis=1)).T\n            return ms_intensive, util_intensive\n\n        def retrofit_func(u):\n            return 1 / (1 + exp(- u))\n\n        def to_retrofit_rate(bill_save, subsidies, investment):\n            \"\"\"Calculate retrofit rate based on binomial logit model.\n\n            Parameters\n            ----------\n            bill_save\n            subsidies\n            investment\n\n            Returns\n            -------\n            retrofit_proba: pd.Series\n                Retrofit rate for each household.\n            utility: pd.Series\n                Utility to renovate for each household.\n            \"\"\"\n\n            utility_bill_saving = reindex_mi(self.preferences_insulation_ext['bill_saved'], bill_save.index) * bill_save / 1000\n\n            pref_sub = reindex_mi(self.preferences_insulation_ext['subsidy'], subsidies.index).rename(None)\n            utility_subsidies = (pref_sub * subsidies) / 1000\n\n            pref_investment = reindex_mi(self.preferences_insulation_ext['investment'], investment.index).rename(None)\n            utility_investment = (pref_investment * investment) / 1000\n\n            utility_renovate = utility_investment + utility_bill_saving + utility_subsidies\n\n            if self.constant_insulation_extensive is not None:\n                _utility = self.add_certificate(utility_renovate.copy())\n                utility_constant = reindex_mi(self.constant_insulation_extensive, _utility.index)\n                _utility += utility_constant\n                utility_renovate = _utility.droplevel('Performance')\n\n            retrofit_proba = retrofit_func(utility_renovate)\n\n            return retrofit_proba, utility_renovate\n\n        def to_freeriders(scal, util, stock_segment, delta_sub, pref_sub):\n            \"\"\"Calculate freeriders due to implementation of subsidy.\n\n\n            Parameters\n            ----------\n            scal: int\n            util: Series\n            stock_segment: Series\n            delta_sub: Series\n            pref_sub: Series\n\n            Returns\n            -------\n            float\n            \"\"\"\n\n            retrofit = retrofit_func(util * scal)\n            flow = (retrofit * stock_segment).sum()\n\n            utility_plus = (util + pref_sub * delta_sub).dropna() * scal\n            retrofit_plus = retrofit_func(utility_plus)\n            flow_plus = (retrofit_plus * stock_segment).sum()\n\n            return min(flow, flow_plus) / max(flow, flow_plus)\n\n        def calibration_intensive(util, stock_segment, market_share_ini, retrofit_rate_ini, iteration=200):\n            \"\"\"Calibrate alternative-specific constant to match observed market-share.\n\n\n            Parameters\n            ----------\n            market_share_ini\n            stock_segment: Series\n            util: DataFrame\n            ms_ini: Series\n                Observed market-share.\n            retrofit_rate_ini: Series\n                Observed renovation rate.\n            iteration: optional, int, default 100\n\n            Returns\n            -------\n            Series\n            \"\"\"\n\n            if 'Performance' in retrofit_rate_ini.index.names:\n                stock_segment = self.add_certificate(stock_segment)\n\n            f_retrofit = stock_segment * reindex_mi(retrofit_rate_ini, stock_segment.index)\n            utility_ref = reindex_mi(util, f_retrofit.index).dropna()\n\n            const = market_share_ini.reindex(utility_ref.columns, axis=0).copy()\n            const[const > 0] = 0\n            insulation_ref = (False, False, True, False)\n            ms_segment, ms_agg, ms_ini = None, None, None\n            for i in range(iteration):\n                const.loc[insulation_ref] = 0\n                _utility = (utility_ref + const).copy()\n                ms_segment = (exp(_utility).T / exp(_utility).sum(axis=1)).T\n                f_replace = (ms_segment.T * f_retrofit).T\n                ms_agg = (f_replace.sum() / f_replace.sum().sum()).reindex(market_share_ini.index)\n                if i == 0:\n                    ms_ini = ms_agg.copy()\n                const = const + log(market_share_ini / ms_agg)\n\n                if (ms_agg.round(decimals=2) == market_share_ini.round(decimals=2)).all():\n                    self.logger.debug('Constant intensive optim worked')\n                    break\n            const.loc[insulation_ref] = 0\n            _utility = (utility_ref + const).copy()\n            ms_segment = (exp(_utility).T / exp(_utility).sum(axis=1)).T\n            f_replace = (ms_segment.T * f_retrofit).T\n            ms_agg = (f_replace.sum() / f_replace.sum().sum()).reindex(market_share_ini.index)\n\n            nb_renovation = (stock_segment * reindex_mi(retrofit_rate_ini, stock_segment.index)).sum()\n            wtp = const / self.preferences_insulation_int['investment']\n            details = concat((const, ms_ini, ms_agg, market_share_ini, (market_share_ini * nb_renovation) / 10 ** 3, wtp), axis=1,\n                             keys=['constant', 'calcul ini', 'calcul', 'observed', 'thousand', 'wtp']).round(decimals=3)\n            if self.path is not None:\n                details.to_csv(os.path.join(self.path_calibration, 'calibration_constant_insulation.csv'))\n\n            return const\n\n        def calibration_constant_scale_ext(util, stock_segment, retrofit_rate_ini, freeriders, delta_sub,\n                                           pref_sub):\n            \"\"\"Simultaneously calibrate constant and scale to match freeriders and retrofit rate.\n\n            Parameters\n            ----------\n            util\n            stock_segment\n            retrofit_rate_ini\n            freeriders\n            delta_sub\n            pref_sub\n\n            Returns\n            -------\n\n            \"\"\"\n\n            def solve_old(x, utility_ini, stock_ini, retrofit_rate_target, freeride, delta_sub, pref_sub):\n                scale = x[-1]\n                cst = x[:-1]\n\n                # calibration constant\n                cst = Series(cst, index=retrofit_rate_target.index)\n                utility_ref = utility_ini.copy()\n                stock_ref = stock_ini.copy()\n                utility_cst = reindex_mi(cst, utility_ref.index)\n                u = (utility_ref + utility_cst).copy()\n                retrofit_rate_calc = retrofit_func(u * scale)\n                agg = (retrofit_rate_calc * stock_ref).groupby(retrofit_rate_target.index.names).sum()\n                retrofit_rate_agg = agg / stock_ref.groupby(retrofit_rate_target.index.names).sum()\n                rslt = retrofit_rate_agg - retrofit_rate_target\n\n                # calibration scale\n                calcul = to_freeriders(scale, u, stock_ini, delta_sub, pref_sub)\n                rslt = append(rslt, calcul - freeride)\n\n                return rslt\n\n            def solve(x, utility_ini, stock_ini, retrofit_rate_target, std_deviation=0.048):\n                scale = x[-1]\n                cst = x[:-1]\n\n                # calibration constant\n                cst = Series(cst, index=retrofit_rate_target.index)\n                utility_ref = utility_ini.copy()\n                stock_ref = stock_ini.copy()\n                utility_cst = reindex_mi(cst, utility_ref.index)\n                u = (utility_ref + utility_cst).copy()\n                retrofit_rate_calc = retrofit_func(u * scale)\n                agg = (retrofit_rate_calc * stock_ref).groupby(retrofit_rate_target.index.names).sum()\n                retrofit_rate_agg = agg / stock_ref.groupby(retrofit_rate_target.index.names).sum()\n                rslt = retrofit_rate_agg - retrofit_rate_target\n\n                # calibration scale\n                retrofit_mean = (retrofit_rate_calc * stock_ini).sum() / stock_ini.sum()\n                std_deviation_calc = (((retrofit_rate_calc - retrofit_mean)**2 * stock_ini).sum() / (stock_ini.sum() - 1))**(1/2)\n                rslt = append(rslt, std_deviation - std_deviation_calc)\n\n                return rslt\n\n            def solve_noscale(x, utility_ini, stock_ini, retrofit_rate_target):\n\n                # calibration constant\n                cst = Series(x, index=retrofit_rate_target.index)\n                utility_ref = utility_ini.copy()\n                stock_ref = stock_ini.copy()\n                utility_cst = reindex_mi(cst, utility_ref.index)\n                u = (utility_ref + utility_cst).copy()\n                retrofit_rate_calc = retrofit_func(u)\n                agg = (retrofit_rate_calc * stock_ref).groupby(retrofit_rate_target.index.names).sum()\n                retrofit_rate_agg = agg / stock_ref.groupby(retrofit_rate_target.index.names).sum()\n                rslt = retrofit_rate_agg - retrofit_rate_target\n\n                return rslt\n\n            if 'Performance' in retrofit_rate_ini.index.names:\n                stock_segment = self.add_certificate(stock_segment)\n                stock_retrofit = stock_segment[stock_segment.index.get_level_values('Performance') > 'B']\n                util = self.add_certificate(util)\n            else:\n                stock_retrofit = stock_segment\n\n            constant = retrofit_rate_ini.copy()\n            constant[retrofit_rate_ini > 0] = 0\n            \"\"\"a = stock_segment.groupby(retrofit_rate_ini.index.names).mean()\n            b = util.groupby(retrofit_rate_ini.index.names).mean()\n            pd.concat((retrofit_rate_ini, a, b), axis=1)\"\"\"\n            if self._calib_scale:\n                x = append(constant.to_numpy(), 1)\n                \"\"\"root, infodict, ier, mess = fsolve(solve, x, args=(\n                    util, stock_retrofit, retrofit_rate_ini, freeriders, - delta_sub / 1000, pref_sub),\n                                                   full_output=True)\"\"\"\n                root, infodict, ier, mess = fsolve(solve, x, args=(\n                    util, stock_retrofit, retrofit_rate_ini), full_output=True)\n\n                self.logger.info(mess)\n                scale = root[-1]\n                self.logger.info('Scale: {}'.format(scale))\n                constant = Series(root[:-1], index=retrofit_rate_ini.index) * scale\n            else:\n                x = constant.to_numpy()\n                root, infodict, _, _ = fsolve(solve_noscale, x, args=(util, stock_retrofit, retrofit_rate_ini),\n                                              full_output=True)\n                scale = 1.0\n                constant = Series(root, index=retrofit_rate_ini.index) * scale\n\n            utility_constant = reindex_mi(constant, util.index)\n            util = util * scale + utility_constant\n            retrofit_rate = retrofit_func(util)\n            agg = (retrofit_rate * stock_segment).groupby(retrofit_rate_ini.index.names).sum()\n            retrofit_rate_agg = agg / stock_segment.groupby(retrofit_rate_ini.index.names).sum()\n\n            coefficient_cost = abs(self.preferences_insulation_ext['investment'] * scale)\n            wtp = constant / coefficient_cost\n            transaction_gain = wtp[wtp.index.get_level_values('Heater replacement') == False].droplevel('Heater replacement') - wtp[wtp.index.get_level_values('Heater replacement') == True].droplevel('Heater replacement')\n            landlord_loss = wtp[wtp.index.get_level_values('Occupancy status') == 'Privately rented'].droplevel('Occupancy status') - wtp[wtp.index.get_level_values('Occupancy status') == 'Owner-occupied'].droplevel('Occupancy status')\n            multi_family_loss = wtp[wtp.index.get_level_values('Occupancy status') != 'Social-housing']\n            multi_family_loss = multi_family_loss[multi_family_loss.index.get_level_values('Housing type') == 'Multi-family'].droplevel('Housing type') - multi_family_loss[multi_family_loss.index.get_level_values('Housing type') == 'Single-family'].droplevel('Housing type')\n\n\n            details = concat((constant, retrofit_rate_agg, retrofit_rate_ini, agg / 10 ** 3), axis=1,\n                             keys=['constant', 'calcul', 'observed', 'thousand']).round(decimals=3)\n            if self.path is not None:\n                details.to_csv(os.path.join(self.path_calibration, 'calibration_constant_extensive.csv'))\n\n            return constant, scale\n\n        def calculation_intensive_margin(stock_segment, retrofit_rate_ini, bill_save, sub_total, cost_insul,\n                                         delta_sub, target_invest=0.2):\n            \"\"\" This function can be adapted to calibrate intensive margin on Risch 2020 result.\n\n\n            However, for now just returns percentage of intensive margin difference\n\n            Parameters\n            ----------\n            stock_segment\n            retrofit_rate_ini\n            bill_save: DataFrame\n            sub_total: DataFrame\n            cost_insul: DataFrame\n            delta_sub: DataFrame, policies used to calibrate the scale.\n            target_invest: float\n\n            Returns\n            -------\n\n            \"\"\"\n\n            if 'Performance' in retrofit_rate_ini.index.names:\n                stock_segment = self.add_certificate(stock_segment)\n            f_retrofit = stock_segment * reindex_mi(retrofit_rate_ini, stock_segment.index)\n            f_retrofit = f_retrofit.droplevel('Performance').dropna()\n\n            def solve(scal, retrofit, b_save, sub_tot, c_insul, d_sub, target):\n                ms_before, _ = to_market_share(b_save, sub_tot, c_insul)\n                investment_insulation_before = (c_insul.reindex(ms_before.index) * ms_before).sum(axis=1)\n                investment_insulation_before = (investment_insulation_before * retrofit).sum() / retrofit.sum()\n                new_sub = sub_tot + d_sub\n                ms_after, _ = to_market_share(b_save, new_sub, c_insul)\n                investment_insulation_after = (c_insul.reindex(ms_after.index) * ms_after).sum(axis=1)\n                investment_insulation_after = (investment_insulation_after * retrofit).sum() / retrofit.sum()\n\n                delta_invest = (investment_insulation_before - investment_insulation_after) / investment_insulation_before\n                return delta_invest - target\n\n            return solve(1, f_retrofit, bill_save, sub_total, cost_insul, -0.5 * delta_sub,\n                         target_invest) + target_invest\n\n        index = stock.index\n\n        cost_insulation = reindex_mi(cost_insulation, index)\n        cost_total = cost_insulation.copy()\n        discount_factor = None\n        if financing_cost is not None and self.financing_cost:\n            share_debt = financing_cost['share_debt'][0] + cost_insulation * financing_cost['share_debt'][1]\n            cost_debt = financing_cost['interest_rate'] * share_debt * cost_insulation * financing_cost['duration']\n            cost_saving = (financing_cost['saving_rate'] * reindex_mi(financing_cost['factor_saving_rate'], cost_insulation.index) * ((1 - share_debt) * cost_insulation).T).T * financing_cost['duration']\n            cost_financing = cost_debt + cost_saving\n            cost_total += cost_financing\n\n            # discount = financing_cost['interest_rate'] * share_debt + (1 - share_debt) * financing_cost['factor_saving_rate']\n            # discount_factor = (1 - (1 + discount) ** -30) / 30\n\n        consumption_before = self.consumption_standard(index, level_heater='Heating system final')[0]\n        consumption_before = reindex_mi(consumption_before, index) * reindex_mi(self._surface, index)\n        energy_bill_before = AgentBuildings.energy_bill(prices, consumption_before, level_heater='Heating system final')\n\n        consumption_sd = self.prepare_consumption(self._choice_insulation, index=index,\n                                                  level_heater='Heating system final')[0]\n        consumption_sd = reindex_mi(consumption_sd, index).reindex(self._choice_insulation, axis=1)\n\n        energy = pd.Series(index.get_level_values('Heating system final'), index=index).str.split('-').str[0].rename('Energy')\n        energy_prices = prices.reindex(energy).set_axis(index)\n        energy_bill_sd = (consumption_sd.T * energy_prices * reindex_mi(self._surface, index)).T\n        bill_saved = - energy_bill_sd.sub(energy_bill_before, axis=0).dropna()\n\n        market_share, utility_intensive = to_market_share(bill_saved, subsidies_total, cost_total)\n\n        if self.constant_insulation_intensive is None:\n            self.logger.info('Calibration intensive')\n            self.constant_insulation_intensive = calibration_intensive(utility_intensive, stock, ms_insulation,\n                                                                       renovation_rate_ini)\n\n            market_share, utility_intensive = to_market_share(bill_saved, subsidies_total, cost_total)\n\n            percentage_intensive_margin = None\n            if False:\n                percentage_intensive_margin = calculation_intensive_margin(stock, renovation_rate_ini, bill_saved,\n                                                                           subsidies_total, cost_insulation, delta_subsidies)\n\n            if self._debug_mode:\n                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                utility_intensive.boxplot(ax=ax, fontsize=12, figsize=(8, 10))\n                plt.xticks(fontsize=7, rotation=45)\n                fig.savefig(os.path.join(self.path_calibration_renovation, 'utility_insulation_distribution.png'))\n                plt.close(fig)\n\n                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                market_share.boxplot(ax=ax, fontsize=12, figsize=(8, 10))\n                plt.xticks(fontsize=7, rotation=45)\n                fig.savefig(os.path.join(self.path_calibration_renovation, 'market_share_distribution.png'))\n                plt.close(fig)\n\n        # calculating market-shares\n        if self._debug_mode:\n            s = self.add_certificate(stock)\n            stock_single = s.xs('Single-family', level='Housing type', drop_level=False)\n            flow_retrofit = stock_single * reindex_mi(renovation_rate_ini, stock_single.index)\n            ms = market_share.groupby([i for i in market_share.index.names if i != 'Heating system final']).first()\n            ms = reindex_mi(ms, flow_retrofit.index).dropna()\n            flow_retrofit = flow_retrofit.reindex(ms.index)\n            agg = (ms.T * flow_retrofit).T\n            market_share_agg = (agg.sum() / agg.sum().sum()).reindex(ms_insulation.index)\n            self.market_share = market_share_agg\n\n        # extensive margin\n        bill_saved_insulation, subsidies_insulation, investment_insulation = None, None, None\n        if self._insulation_representative == 'market_share':\n            bill_saved_insulation = (bill_saved.reindex(market_share.index) * market_share).sum(axis=1)\n            subsidies_insulation = (subsidies_total.reindex(market_share.index) * market_share).sum(axis=1)\n            investment_insulation = (cost_total.reindex(market_share.index) * market_share).sum(axis=1)\n\n        elif self._insulation_representative == 'max':\n            utility_intensive = utility_intensive.dropna(how='all')\n            dict_df = {'investment': cost_insulation, 'bill_saved': bill_saved, 'subsidies': subsidies_total}\n            dict_int = self.find_best_option(utility_intensive, dict_df, func='max')\n\n            def rename_tuple(tuple, names):\n                idx = tuple.index\n                tuple = DataFrame([[a, b, c, d] for a, b, c, d in tuple.values])\n                tuple.columns = names\n                for i in names:\n                    tuple.loc[tuple[i] == True, i] = i\n                    tuple.loc[tuple[i] == False, i] = ''\n                return Series(list(zip(*(tuple[i] for i in names))), index=idx)\n\n            dict_int['representative'] = rename_tuple(dict_int['columns'], utility_intensive.columns.names)\n            bill_saved_insulation = dict_int['bill_saved']\n            subsidies_insulation = dict_int['subsidies']\n            investment_insulation = dict_int['investment']\n\n        idx = bill_saved_insulation[bill_saved_insulation <= 0].index\n        bill_saved_insulation.drop(idx, inplace=True)\n        subsidies_insulation.drop(idx, inplace=True)\n        investment_insulation.drop(idx, inplace=True)\n\n        retrofit_rate, utility = to_retrofit_rate(bill_saved_insulation, subsidies_insulation, investment_insulation)\n\n        if self.constant_insulation_extensive is None:\n            self.logger.debug('Calibration renovation rate')\n            if self._insulation_representative == 'market_share':\n                delta_subsidies_sum = (delta_subsidies.reindex(market_share.index) * market_share).sum(axis=1)\n            else:\n                delta_subsidies_sum = self.find_best_option(utility_intensive, {'delta_subsidies': delta_subsidies}, func='max')['delta_subsidies']\n                delta_subsidies_sum = delta_subsidies_sum.loc[bill_saved_insulation.index].rename(None)\n\n            pref_subsidies = reindex_mi(self.preferences_insulation_ext['subsidy'], subsidies_insulation.index).rename(None)\n\n            # graphic showing the impact of the scale in a general case\n            if self._debug_mode:\n                x, free_riders, elasticity = [], [], []\n                for scale in arange(0.1, 5, 0.1):\n                    x.append(scale)\n                    free_riders.append(to_freeriders(scale, utility, stock, - delta_subsidies_sum / 1000, pref_subsidies,\n                                                        ))\n\n                graphs = {'Freeriders cite': free_riders}\n                for name, data in graphs.items():\n                    df = Series(data, index=Index(x, name='Scale'), name=name)\n                    fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                    df.plot(ax=ax)\n                    format_ax(ax, format_y=lambda y, _: '{:.0%}'.format(y), y_label=name)\n                    save_fig(fig, save=os.path.join(self.path_calibration, 'scale_calibration_{}.png'.format(name.lower())))\n\n            constant, scale = calibration_constant_scale_ext(utility, stock, renovation_rate_ini, target_freeriders,\n                                                             delta_subsidies_sum, pref_subsidies)\n            self.constant_insulation_extensive = constant\n\n            # graphic showing the impact of the scale\n            if self._debug_mode:\n                stock_single = stock.xs('Single-family', level='Housing type', drop_level=False)\n                stock_multi = stock.xs('Multi-family', level='Housing type', drop_level=False)\n                x_before, y_before, y_before_single, y_before_multi = [], [], [], []\n                for delta in arange(0, 2, 0.1):\n                    sub = subsidies_insulation * (1 + delta)\n                    x_before.append((sub * stock).sum() / stock.sum())\n                    rate = to_retrofit_rate(bill_saved_insulation, sub, investment_insulation)[0]\n                    y_before.append((rate * stock).sum() / stock.sum())\n                    y_before_single.append((rate * stock_single).sum() / stock_single.sum())\n                    y_before_multi.append((rate * stock_multi).sum() / stock_multi.sum())\n\n            self.scale_ext = scale\n            self.preferences_insulation_ext['subsidy'] *= self.scale_ext\n            self.preferences_insulation_ext['investment'] *= self.scale_ext\n            self.preferences_insulation_ext['bill_saved'] *= self.scale_ext\n\n            # graphic showing the impact of the scale\n            if self._debug_mode:\n                x_after, y_after, y_after_single, y_after_multi = [], [], [], []\n                for delta in arange(0, 2, 0.1):\n                    sub = subsidies_insulation * (1 + delta)\n                    x_after.append((sub * stock).sum() / stock.sum())\n                    rate = to_retrofit_rate(bill_saved_insulation, sub, investment_insulation)[0]\n                    y_after.append((rate * stock).sum() / stock.sum())\n                    y_after_single.append((rate * stock_single).sum() / stock_single.sum())\n                    y_after_multi.append((rate * stock_multi).sum() / stock_multi.sum())\n\n                df = concat(\n                    (Series(x_before), Series(y_before), Series(y_after), Series(y_before_single),\n                     Series(y_after_single), Series(y_before_multi),\n                     Series(y_after_multi)), axis=1)\n\n                df.columns = ['Subsidies (€)', 'Before', 'After', 'Before single', 'After single', 'Before multi',\n                              'After multi']\n                color = {'Before': 'black', 'After': 'black',\n                         'Before single': 'darkorange', 'After single': 'darkorange',\n                         'Before multi': 'royalblue', 'After multi': 'royalblue'\n                         }\n                style = ['--', '-'] * 10\n                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                df.plot(ax=ax, x='Subsidies (€)', color=color, style=style)\n                format_ax(ax, format_y=lambda y, _: '{:.0%}'.format(y), y_label='Retrofit rate')\n                format_legend(ax)\n                save_fig(fig, save=os.path.join(self.path_calibration, 'scale_effect.png'))\n\n            retrofit_rate, utility = to_retrofit_rate(bill_saved_insulation, subsidies_insulation,\n                                                      investment_insulation)\n\n            # graphics showing the distribution of retrofit rate after calibration\n            if self._debug_mode:\n                r = retrofit_rate.xs(False, level='Heater replacement').rename('')\n\n                fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                r.plot.box(ax=ax)\n                format_ax(ax, format_y=lambda y, _: '{:.0%}'.format(y))\n                ax.set_xlabel('')\n                ax.set_ylabel('Retrofit rate (%)')\n                save_fig(fig, save=os.path.join(self.path_calibration_renovation, 'retrofit_rate_distribution.png'))\n\n                certificate = self.certificate.groupby([l for l in self.stock.index.names if l != 'Income tenant']).first()\n                certificate = reindex_mi(certificate, r.index)\n                r.to_frame().groupby(certificate).boxplot(fontsize=12, figsize=(8, 10))\n                plt.savefig(os.path.join(self.path_calibration_renovation, 'retrofit_rate_distribution_dpe.png'))\n                plt.close()\n\n                r = retrofit_rate.rename('')\n                certificate = self.certificate.groupby([l for l in self.stock.index.names if l != 'Income tenant']).first()\n                certificate = reindex_mi(certificate, r.index)\n                temp = concat((r, certificate.rename('Performance')), axis=1).set_index('Performance', append=True)\n                temp.groupby(renovation_rate_ini.index.names).describe().to_csv(\n                    os.path.join(self.path_calibration_renovation, 'retrofit_rate_desription.csv'))\n\n                consumption_sd = self.consumption_standard(r.index)[2]\n                consumption_sd = reindex_mi(consumption_sd, index)\n\n                consumption_sd = reindex_mi(consumption_sd, r.index)\n                df = concat((consumption_sd, r), axis=1, keys=['Consumption', 'Retrofit rate'])\n\n                make_plot(df.set_index('Consumption').squeeze().sort_index(), 'Retrofit rate (%)',\n                          format_y=lambda x, _: '{:.0%}'.format(x),\n                          save=os.path.join(self.path_calibration_renovation, 'retrofit_rate_consumption_calib.png'),\n                          legend=False, integer=False)\n\n                df.reset_index('Income owner', inplace=True)\n                df['Income owner'] = df['Income owner'].replace(resources_data['colors'])\n                for i in renovation_rate_ini.index:\n                    if not i[2]:\n                        d = df.xs(i[0], level='Housing type').xs(i[1], level='Occupancy status')\n                        name = '{}_{}_{}'.format(i[0].lower(), i[1].lower(), str(i[2]).lower())\n                        fig, ax = plt.subplots(1, 1, figsize=(12.8, 9.6))\n                        d.plot.scatter(ax=ax, x='Consumption', y='Retrofit rate', c=d['Income owner'])\n                        format_ax(ax, format_y=lambda y, _: '{:.0%}'.format(y), y_label=name)\n                        save_fig(fig, save=os.path.join(self.path_calibration_renovation, 'retrofit_rate_{}_calib.png'.format(name)))\n\n            # file concatenating all calibration results\n            scale = Series(self.scale_ext, index=['Scale'])\n            constant_ext = self.constant_insulation_extensive.copy()\n            constant_ext.index = constant_ext.index.to_flat_index()\n            constant_int = self.constant_insulation_intensive.copy()\n            constant_int.index = constant_int.index.to_flat_index()\n            if isinstance(constant_int, DataFrame):\n                constant_int = constant_int.stack(constant_int.columns.names)\n\n            r = self.add_certificate(retrofit_rate)\n            s = self.add_certificate(stock)\n            flow_retrofit = r * s\n            retrofit_rate_mean = flow_retrofit.sum() / s.sum()\n            retrofit_rate_mean = Series(retrofit_rate_mean, index=['Retrofit rate mean (%)'])\n            retrofit_calibrated = flow_retrofit.groupby(renovation_rate_ini.index.names).sum() / s.groupby(renovation_rate_ini.index.names).sum()\n            retrofit_calibrated.index = retrofit_calibrated.index.to_flat_index()\n            flow_retrofit = flow_retrofit.droplevel('Performance')\n            flow_insulation = (flow_retrofit * market_share.T).T.sum()\n            flow_insulation_agg, name = list(), ''\n            for i in flow_insulation.index.names:\n                flow_insulation_agg.append(flow_insulation.xs(True, level=i).sum())\n                name = '{}{},'.format(name, i)\n            name = Series('', index=[name])\n            flow_insulation_agg = Series(flow_insulation_agg, index=flow_insulation.index.names)\n            flow_insulation.index = flow_insulation.index.to_flat_index()\n            flow_insulation_sum = Series(flow_insulation.sum(), index=['Replacement insulation'])\n            ms_calibrated = flow_insulation / flow_insulation.sum()\n            ms_calibrated.index = ms_calibrated.index.to_flat_index()\n            result = concat((scale, constant_ext, retrofit_rate_mean, retrofit_calibrated, flow_insulation_sum,\n                                flow_insulation_agg, name, constant_int, flow_insulation, ms_calibrated,\n                                ), axis=0)\n            if percentage_intensive_margin is not None:\n                percentage_intensive_margin = Series(percentage_intensive_margin, index=['Percentage intensive margin'])\n                result = concat((result, percentage_intensive_margin), axis=0)\n\n            if self.path is not None:\n                result.to_csv(os.path.join(self.path_calibration, 'result_calibration.csv'))\n\n        return retrofit_rate, market_share\n\n    @staticmethod\n    def exogenous_retrofit(index, choice_insulation):\n        \"\"\"Format retrofit rate and market share for each segment.\n\n        Global retrofit and retrofit rate to match exogenous numbers.\n        Retrofit all heating system replacement dwelling.\n\n        Parameters\n        ----------\n        index: MultiIndex\n        choice_insulation: MultiIndex\n\n        Returns\n        -------\n        Series\n            Retrofit rate by segment.\n        DataFrame\n            Market-share by segment and insulation choice.\n        \"\"\"\n\n        retrofit_rate = concat([Series(1, dtype=float, index=index)], keys=[True], names=['Heater replacement'])\n\n        market_share = DataFrame(0, index=index, columns=choice_insulation)\n        market_share.loc[:, (True, True, True, True)] = 1\n\n        return retrofit_rate, market_share\n\n    def flow_obligation(self, policies_insulation, option='global'):\n        \"\"\"Account for flow obligation if defined in policies_insulation.\n\n        Parameters\n        ----------\n        option: {'global', 'market_share'}, default 'global'\n            'market_share' Not implemented yet.\n        policies_insulation: list\n            Check if obligation.\n\n        Returns\n        -------\n        flow_obligation: Series\n        \"\"\"\n\n        stock = self.stock.copy()\n\n        obligation = [p for p in policies_insulation if p.name == 'obligation']\n        if obligation:\n\n            stock_certificate = self.add_certificate(stock)\n            idx = stock.index[stock_certificate.index.get_level_values('Performance').isin(['F', 'G'])]\n            to_replace = stock.loc[idx]\n\n            # formatting replace_by\n            replaced_by = to_replace.copy()\n            replaced_by = replaced_by.groupby([i for i in replaced_by.index.names if i != 'Income tenant']).sum()\n\n            if 'Heater replacement' not in replaced_by:\n                replaced_by = concat([replaced_by], keys=[False], names=['Heater replacement'])\n            if 'Heating system final' not in replaced_by.index.names:\n                temp = replaced_by.reset_index('Heating system')\n                temp['Heating system final'] = temp['Heating system']\n                replaced_by = temp.set_index(['Heating system', 'Heating system final'], append=True).squeeze()\n            replaced_by.index = replaced_by.index.reorder_levels(self.market_share.index.names)\n\n            market_share = None\n            if option == 'market_share':\n                # index that have been created in year do not have market-share already calculated in self.market_share\n                market_share = self.market_share\n                idx_full = market_share.index.intersection(replaced_by.index)\n                market_share = market_share.loc[idx_full, :]\n            elif option == 'global':\n                market_share = DataFrame(0, index=replaced_by.index, columns=self._choice_insulation)\n                market_share.loc[:, (True, True, True, True)] = 1\n\n            replaced_by = (replaced_by.rename(None) * market_share.T).T\n\n            if self.detailed_mode:\n                self.store_information_retrofit(replaced_by)\n\n            replaced_by = self.frame_to_flow(replaced_by)\n\n            assert to_replace.sum().round(0) == replaced_by.sum().round(0), 'Sum problem'\n            flow_obligation = concat((- to_replace, replaced_by), axis=0)\n            flow_obligation = flow_obligation.groupby(flow_obligation.index.names).sum()\n            return flow_obligation\n\n    def frame_to_flow(self, replaced_by):\n        \"\"\"Transform insulation transition Dataframe to flow.\n\n        Parameters\n        ----------\n        replaced_by: DataFrame\n\n        Returns\n        -------\n        replaced_by: Series\n            Flow Series.\n        \"\"\"\n\n        replaced_by_sum = replaced_by.sum().sum()\n\n        if 'Income tenant' not in replaced_by.index.names:\n            share = (self.stock_mobile.unstack('Income tenant').T / self.stock_mobile.unstack('Income tenant').sum(\n                axis=1)).T\n            temp = concat([replaced_by] * share.shape[1], keys=share.columns, names=share.columns.names, axis=1)\n            share = reindex_mi(share, temp.columns, axis=1)\n            share = reindex_mi(share, temp.index)\n            replaced_by = (share * temp).stack('Income tenant').dropna()\n            assert round(replaced_by.sum().sum(), 0) == round(replaced_by_sum, 0), 'Sum problem'\n\n        replaced_by = replaced_by.droplevel('Heating system').rename_axis(\n            index={'Heating system final': 'Heating system'})\n\n        replaced_by.index.set_names(\n            {'Wall': 'Wall before', 'Roof': 'Roof before', 'Floor': 'Floor before', 'Windows': 'Windows before'},\n            inplace=True)\n        replaced_by.columns.set_names(\n            {'Wall': 'Wall after', 'Roof': 'Roof after', 'Floor': 'Floor after', 'Windows': 'Windows after'},\n            inplace=True)\n        replaced_by = replaced_by.stack(replaced_by.columns.names).rename('Data')\n\n        replaced_by = replaced_by[replaced_by > 0]\n\n        replaced_by = replaced_by.reset_index()\n\n        for component in ['Wall', 'Floor', 'Roof', 'Windows']:\n            replaced_by[component] = replaced_by['{} before'.format(component)]\n            replaced_by.loc[replaced_by['{} after'.format(component)], component] = self._performance_insulation[component]\n\n        replaced_by.drop(\n            ['Wall before', 'Wall after', 'Roof before', 'Roof after', 'Floor before', 'Floor after', 'Windows before',\n             'Windows after'], axis=1, inplace=True)\n\n        replaced_by = replaced_by.set_index(self.stock.index.names).loc[:, 'Data']\n        replaced_by = replaced_by.groupby(replaced_by.index.names).sum()\n\n        assert replaced_by.sum().round(0) == replaced_by_sum.round(0), 'Sum problem'\n\n        return replaced_by\n\n    def flow_retrofit(self, prices, cost_heater, cost_insulation, policies_heater=None, policies_insulation=None,\n                      ms_heater=None, ms_insulation=None, renovation_rate_ini=None, target_freeriders=None,\n                      financing_cost=None):\n        \"\"\"Compute heater replacement and insulation retrofit.\n\n        1. Heater replacement based on current stock segment.\n        2. Knowing heater replacement (and new heating system) calculating retrofit rate by segment and market\n        share by segment.\n        3. Then, managing inflow and outflow.\n\n        Parameters\n        ----------\n        prices: Series\n        cost_heater: Series\n        ms_heater: DataFrame\n        cost_insulation\n        ms_insulation: Series\n        renovation_rate_ini: Series\n        policies_heater: list\n            List of policies for heating system.\n        policies_insulation: list\n            List of policies for insulation.\n        target_freeriders: float, default None\n            Number of freeriders in calibration year for the income tax credit.\n        financing_cost: optional, dict\n\n        Returns\n        -------\n        Series\n        \"\"\"\n\n        # removing unused attributes to determine flow retrofit\n        stock = self.stock_mobile.groupby([i for i in self.stock_mobile.index.names if i != 'Income tenant']).sum()\n\n        # accounts for heater replacement - depends on energy prices, cost and policies heater\n        stock = self.heater_replacement(stock, prices, cost_heater, policies_heater, ms_heater=ms_heater)\n\n        self.logger.debug('Agents: {:,.0f}'.format(stock.shape[0]))\n        stock_existing = stock.xs(True, level='Existing', drop_level=False)\n        retrofit_rate, market_share = self.insulation_replacement(stock_existing, prices, cost_insulation,\n                                                                  ms_insulation=ms_insulation,\n                                                                  renovation_rate_ini=renovation_rate_ini,\n                                                                  policies_insulation=policies_insulation,\n                                                                  target_freeriders=target_freeriders,\n                                                                  financing_cost=financing_cost)\n\n        # heater replacement without insulation upgrade\n        flow_only_heater = (1 - retrofit_rate.reindex(stock.index).fillna(0)) * stock\n        flow_only_heater = flow_only_heater.xs(True, level='Heater replacement', drop_level=False).unstack('Heating system final')\n        flow_only_heater_sum = flow_only_heater.sum().sum()\n\n        # insulation upgrade\n        flow = (retrofit_rate * stock).dropna()\n        replacement_sum = flow.sum().sum()\n\n        replaced_by = (flow * market_share.T).T\n\n        assert round(replaced_by.sum().sum(), 0) == round(replacement_sum, 0), 'Sum problem'\n\n        # energy performance certificate jump due to heater replacement without insulation upgrade\n        only_heater = (stock - flow.reindex(stock.index, fill_value=0)).xs(True, level='Heater replacement')\n        certificate_jump = self.certificate_jump_heater.stack()\n        rslt = {}\n        l = unique(certificate_jump)\n        for i in l:\n            rslt.update({i: ((certificate_jump == i) * only_heater).sum()})\n        self.certificate_jump_heater = Series(rslt).sort_index()\n\n        # storing information (flow, investment, subsidies)\n        if self.detailed_mode:\n            self.store_information_retrofit(replaced_by)\n\n        # removing heater replacement level\n        replaced_by = replaced_by.groupby(\n            [c for c in replaced_by.index.names if c != 'Heater replacement']).sum()\n        flow_only_heater = flow_only_heater.groupby(\n            [c for c in flow_only_heater.index.names if c != 'Heater replacement']).sum()\n\n        # adding income tenant information\n        share = (self.stock_mobile.unstack('Income tenant').T / self.stock_mobile.unstack('Income tenant').sum(axis=1)).T\n        temp = concat([replaced_by] * share.shape[1], keys=share.columns, names=share.columns.names, axis=1)\n        share = reindex_mi(share, temp.columns, axis=1)\n        share = reindex_mi(share, temp.index)\n        replaced_by = (share * temp).stack('Income tenant').dropna()\n        assert round(replaced_by.sum().sum(), 0) == round(replacement_sum, 0), 'Sum problem'\n\n        share = (self.stock_mobile.unstack('Income tenant').T / self.stock_mobile.unstack('Income tenant').sum(axis=1)).T\n        temp = concat([flow_only_heater] * share.shape[1], keys=share.columns, names=share.columns.names, axis=1)\n        share = reindex_mi(share, temp.columns, axis=1)\n        share = reindex_mi(share, temp.index)\n        flow_only_heater = (share * temp).stack('Income tenant').dropna()\n        assert round(flow_only_heater.sum().sum(), 0) == round(flow_only_heater_sum, 0), 'Sum problem'\n\n        flow_only_heater = flow_only_heater.stack('Heating system final')\n        to_replace_only_heater = - flow_only_heater.droplevel('Heating system final')\n\n        flow_replaced_by = flow_only_heater.droplevel('Heating system')\n        flow_replaced_by.index = flow_replaced_by.index.rename('Heating system', level='Heating system final')\n        flow_replaced_by = flow_replaced_by.reorder_levels(to_replace_only_heater.index.names)\n\n        flow_only_heater = pd.concat((to_replace_only_heater, flow_replaced_by), axis=0)\n        flow_only_heater = flow_only_heater.groupby(flow_only_heater.index.names).sum()\n        assert round(flow_only_heater.sum(), 0) == 0, 'Sum problem'\n\n        to_replace = replaced_by.droplevel('Heating system final').sum(axis=1).copy()\n        to_replace = to_replace.groupby(to_replace.index.names).sum()\n        assert round(to_replace.sum(), 0) == round(replacement_sum, 0), 'Sum problem'\n\n        replaced_by = self.frame_to_flow(replaced_by)\n\n        to_replace = to_replace.reorder_levels(replaced_by.index.names)\n        flow_only_heater = flow_only_heater.reorder_levels(replaced_by.index.names)\n        flow_retrofit = concat((-to_replace, replaced_by, flow_only_heater), axis=0)\n        flow_retrofit = flow_retrofit.groupby(flow_retrofit.index.names).sum()\n\n        assert round(flow_retrofit.sum(), 0) == 0, 'Sum problem'\n\n        return flow_retrofit\n\n    def flow_demolition(self):\n        \"\"\"Demolition of E, F and G buildings based on their share in the mobile stock.\n\n        Returns\n        -------\n        Series\n        \"\"\"\n        self.logger.info('Demolition')\n        stock_demolition = self.stock_mobile[self.certificate.isin(self._target_demolition)]\n        if stock_demolition.sum() < self._demolition_total:\n            self._target_demolition = ['G', 'F', 'E', 'D']\n            stock_demolition = self.stock_mobile[self.certificate.isin(self._target_demolition)]\n            if stock_demolition.sum() < self._demolition_total:\n                self._target_demolition = ['G', 'F', 'E', 'D', 'C']\n                stock_demolition = self.stock_mobile[self.certificate.isin(self._target_demolition)]\n\n        stock_demolition = stock_demolition / stock_demolition.sum()\n        flow_demolition = (stock_demolition * self._demolition_total).dropna()\n        return flow_demolition.reorder_levels(self.stock.index.names)\n\n    def health_cost(self, param, stock=None):\n        if stock is None:\n            stock = self.simplified_stock()\n\n        health_cost_type = {'health_expenditure': 'Health expenditure (Billion euro)',\n                            'mortality_cost': 'Social cost of mortality (Billion euro)',\n                            'loss_well_being': 'Loss of well-being (Billion euro)'}\n        health_cost = dict()\n        for key, item in health_cost_type.items():\n            health_cost[item] = (stock * reindex_mi(param[key], stock.index)).sum() / 10 ** 9\n\n        health_cost_total = Series(health_cost).sum()\n        return health_cost_total, health_cost\n\n    def parse_output_run(self, inputs):\n        \"\"\"Parse output.\n\n        Renovation : envelope\n        Retrofit : envelope and/or heating system\n\n        Parameters\n        ----------\n        inputs: dict\n            Exogenous data for post-treatment.\n            'carbon_emission'\n            'population'\n            'surface'\n            'embodied_energy_renovation'\n            'carbon_footprint_renovation'\n            'Carbon footprint construction (MtCO2)'\n            'health_expenditure', 'mortality_cost', 'loss_well_being'\n            'Embodied energy construction (TWh PE)'\n\n        Returns\n        -------\n\n        \"\"\"\n\n        stock = self.simplified_stock()\n\n        output = dict()\n        output['Consumption standard (TWh)'] = (self.heat_consumption_sd * self.stock).sum() / 10 ** 9\n\n        consumption = self.heat_consumption_calib\n        output['Consumption (TWh)'] = consumption.sum() / 10 ** 9\n\n        temp = consumption.groupby(self.energy).sum()\n        temp.index = temp.index.map(lambda x: 'Consumption {} (TWh)'.format(x))\n        output.update(temp.T / 10 ** 9)\n\n        temp = consumption.groupby('Existing').sum()\n        temp.rename(index={True: 'Existing', False: 'New'}, inplace=True)\n        temp.index = temp.index.map(lambda x: 'Consumption {} (TWh)'.format(x))\n        output.update(temp.T / 10 ** 9)\n\n        temp = consumption.groupby(self.certificate).sum()\n        temp.index = temp.index.map(lambda x: 'Consumption {} (TWh)'.format(x))\n        output.update(temp.T / 10 ** 9)\n\n        c = self.add_energy(consumption)\n        emission = reindex_mi(inputs['carbon_emission'].T.rename_axis('Energy', axis=0), c.index).loc[:,\n                   self.year] * c\n\n        output['Emission (MtCO2)'] = emission.sum() / 10 ** 12\n\n        temp = emission.groupby('Existing').sum()\n        temp.rename(index={True: 'Existing', False: 'New'}, inplace=True)\n        temp.index = temp.index.map(lambda x: 'Emission {} (MtCO2)'.format(x))\n        output.update(temp.T / 10 ** 12)\n\n        temp = emission.groupby('Energy').sum()\n        temp.index = temp.index.map(lambda x: 'Emission {} (MtCO2)'.format(x))\n        output.update(temp.T / 10 ** 12)\n\n        output['Stock (Million)'] = stock.sum() / 10 ** 6\n\n        output['Surface (Million m2)'] = (self.stock * self.surface).sum() / 10 ** 6\n        output['Surface (m2/person)'] = (\n                    output['Surface (Million m2)'] / (inputs['population'].loc[self.year] / 10 ** 6))\n\n        output['Consumption standard (kWh/m2)'] = (output['Consumption standard (TWh)'] * 10 ** 9) / (\n                output['Surface (Million m2)'] * 10 ** 6)\n        output['Consumption (kWh/m2)'] = (output['Consumption (TWh)'] * 10 ** 9) / (\n                output['Surface (Million m2)'] * 10 ** 6)\n\n        output['Heating intensity (%)'] = self.heating_intensity_avg\n\n        output['Energy poverty (Million)'] = self.energy_poverty / 10 ** 6\n\n        temp = self.stock.groupby(self.certificate).sum()\n        temp.index = temp.index.map(lambda x: 'Stock {} (Million)'.format(x))\n        output.update(temp.T / 10 ** 6)\n        try:\n            output['Stock efficient (Million)'] = output['Stock A (Million)'] + output['Stock B (Million)']\n        except KeyError:\n            output['Stock efficient (Million)'] = output['Stock B (Million)']\n\n        output['Stock low-efficient (Million)'] = 0\n        if 'Stock F (Million)' in output.keys():\n            output['Stock low-efficient (Million)'] += output['Stock F (Million)']\n        if 'Stock G (Million)' in output.keys():\n            output['Stock low-efficient (Million)'] += output['Stock G (Million)']\n\n        if self.year > self.first_year:\n            temp = self.retrofit_rate.dropna(how='all')\n            temp = temp.groupby([i for i in temp.index.names if i not in ['Heating system final']]).mean()\n            t = temp.xs(False, level='Heater replacement')\n\n            s_temp = self.stock\n            s_temp = s_temp.groupby([i for i in s_temp.index.names if i != 'Income tenant']).sum()\n\n            # Weighted average with stock to calculate real retrofit rate\n            output['Renovation rate (%)'] = ((t * s_temp).sum() / s_temp.sum())\n            t_grouped = (t * s_temp).groupby(['Housing type', 'Occupancy status']).sum() / s_temp.groupby(\n                ['Housing type',\n                 'Occupancy status']).sum()\n            t_grouped.index = t_grouped.index.map(lambda x: 'Renovation rate {} - {} (%)'.format(x[0], x[1]))\n            output.update(t_grouped.T)\n\n            t = temp.xs(True, level='Heater replacement')\n            s_temp = self.stock\n            s_temp = s_temp.groupby([i for i in s_temp.index.names if i != 'Income tenant']).sum()\n            output['Renovation rate w/ heater (%)'] = ((t * s_temp).sum() / s_temp.sum())\n\n            t_grouped = (t * s_temp).groupby(['Housing type', 'Occupancy status']).sum() / s_temp.groupby(\n                ['Housing type',\n                 'Occupancy status']).sum()\n            t_grouped.index = t_grouped.index.map(lambda x: 'Renovation rate heater {} - {} (%)'.format(x[0], x[1]))\n            output.update(t_grouped.T)\n\n            temp = self.gest_nb.copy()\n            temp.index = temp.index.map(lambda x: 'Renovation types {} (Thousand households)'.format(x))\n            output['Renovation (Thousand households)'] = temp.sum() / 10 ** 3\n            output['Renovation with heater replacement (Thousand households)'] = self.retrofit_with_heater / 10 ** 3\n            output['Replacement renovation (Thousand)'] = (self.gest_nb * self.gest_nb.index).sum() / 10 ** 3\n            output.update(temp.T / 10 ** 3)\n            output['Replacement total (Thousand)'] = output['Replacement renovation (Thousand)'] - output[\n                'Renovation with heater replacement (Thousand households)'] + self.replacement_heater.sum().sum() / 10 ** 3\n\n            output['Retrofit (Thousand households)'] = output['Renovation (Thousand households)'] - output[\n                'Renovation with heater replacement (Thousand households)'] + self.replacement_heater.sum().sum() / 10 ** 3\n\n            # output['Renovation (Thousand households)'] = self.certificate_jump.sum().sum() / 10 ** 3\n            # We need them by income for freeriders ratios per income deciles\n\n            # TODO: optimizing: only need certificate_jump summed or by index by not dataframe\n\n            temp = self.certificate_jump_all.sum().squeeze().sort_index()\n            temp = temp[temp.index.dropna()]\n            o = {}\n            for i in temp.index.union(self.certificate_jump_heater.index):\n                t_renovation = 0\n                if i in temp.index:\n                    t_renovation = temp.loc[i]\n                    o['Renovation {} EPC (Thousand households)'.format(i)] = t_renovation / 10 ** 3\n                t_heater = 0\n                if i in self.certificate_jump_heater.index:\n                    t_heater = self.certificate_jump_heater.loc[i]\n                o['Retrofit {} EPC (Thousand households)'.format(i)] = (t_renovation + t_heater) / 10 ** 3\n            o = Series(o).sort_index(ascending=False)\n\n            output['Renovation >= 1 EPC (Thousand households)'] = self.certificate_jump_all.loc[:,\n                                                     [i for i in self.certificate_jump_all.columns if\n                                                      i > 0]].sum().sum() / 10 ** 3\n            output['Retrofit >= 1 EPC (Thousand households)'] = sum([o['Retrofit {} EPC (Thousand households)'.format(i)] for i in temp.index.unique() if i >=1])\n\n            output.update(o.T)\n            # output['Retrofit rate {} EPC (%)'.format(i)] = temp.sum() / stock.sum()\n\n            # output['Efficient retrofits (Thousand)'] = Series(self.efficient_renovation_yrs) / 10**3\n            output['Global renovation high income (Thousand households)'] = self.global_renovation_high_income / 10 ** 3\n            output['Global renovation low income (Thousand households)'] = self.global_renovation_low_income / 10 ** 3\n            output['Global renovation (Thousand households)'] = output['Global renovation high income (Thousand households)'] + output['Global renovation low income (Thousand households)']\n            output['Bonus best renovation (Thousand households)'] = self.bonus_best / 10 ** 3\n            output['Bonus worst renovation (Thousand households)'] = self.bonus_worst / 10 ** 3\n            output['Percentage of global renovation (% households)'] = output['Global renovation (Thousand households)'] / output[\n                'Renovation (Thousand households)']\n            output['Percentage of bonus best renovation (% households)'] = output['Bonus best renovation (Thousand households)'] / output[\n                'Renovation (Thousand households)']\n            output['Percentage of bonus worst renovation (% households)'] = output['Bonus worst renovation (Thousand households)'] / output[\n                'Renovation (Thousand households)']\n\n            temp = self.certificate_jump_all.sum(axis=1)\n            t = temp.groupby('Income owner').sum()\n            t.index = t.index.map(lambda x: 'Renovation {} (Thousand households)'.format(x))\n            output.update(t.T / 10 ** 3)\n\n            # for replacement output need to be presented by technologies (what is used) and by agent (who change)\n            temp = self.replacement_heater.sum()\n            output['Replacement heater (Thousand households)'] = temp.sum() / 10 ** 3\n            t = temp.copy()\n            t.index = t.index.map(lambda x: 'Replacement heater {} (Thousand households)'.format(x))\n            output.update((t / 10 ** 3).T)\n\n            \"\"\"\n            # summing accoridng to heating system beafore instead of final \n            temp = self.replacement_heater.sum(axis=1) \n            t = temp.groupby(['Heating system', 'Housing type']).sum()\n            t.index = t.index.map(lambda x: 'Replacement heater {} {} (Thousand households)'.format(x[0], x[1]))\n            output.update((t / 10 ** 3).T)\n            \"\"\"\n\n            t = self.replacement_heater.groupby('Housing type').sum().loc['Multi-family']\n            t.index = t.index.map(lambda x: 'Replacement heater Multi-family {} (Thousand households)'.format(x))\n            output.update((t / 10 ** 3).T)\n\n            t = self.replacement_heater.groupby('Housing type').sum().loc['Single-family']\n            t.index = t.index.map(lambda x: 'Replacement heater Single-family {} (Thousand households)'.format(x))\n            output.update((t / 10 ** 3).T)\n\n            temp = self.replacement_insulation.sum(axis=1)\n            output['Replacement insulation (Thousand households)'] = temp.sum() / 10 ** 3\n            t = temp.groupby(['Housing type', 'Occupancy status']).sum()\n            t.index = t.index.map(lambda x: 'Replacement insulation {} - {} (Thousand households)'.format(x[0], x[1]))\n            output.update((t / 10 ** 3).T)\n            t = temp.groupby('Income owner').sum()\n            t.index = t.index.map(lambda x: 'Replacement insulation {} (Thousand households)'.format(x))\n            output.update(t.T / 10 ** 3)\n\n            \"\"\"t.index = t.index.str.replace('Thousand', '%')\n            s = stock.groupby(['Housing type', 'Occupancy status']).sum()\n            s.index = s.index.map(lambda x: 'Replacement insulation {} - {} (%)'.format(x[0], x[1]))\n            t = t / s\n            output.update(t.T)\"\"\"\n            o = {}\n            for i in ['Wall', 'Floor', 'Roof', 'Windows']:\n                temp = self.replacement_insulation.xs(True, level=i, axis=1).sum(axis=1)\n                o['Replacement {} (Thousand households)'.format(i)] = temp.sum() / 10 ** 3\n\n                cost = self.cost_component.loc[:, i]\n                t = reindex_mi(cost, temp.index) * temp\n                surface = reindex_mi(inputs['surface'].loc[:, self.year], t.index)\n                o['Investment {} (Billion euro)'.format(i)] = (t * surface).sum() / 10 ** 9\n\n                surface = reindex_mi(inputs['surface'].loc[:, self.year], temp.index)\n                o['Embodied energy {} (TWh PE)'.format(i)] = (temp * surface *\n                                                                   inputs['embodied_energy_renovation'][\n                                                                       i]).sum() / 10 ** 9\n                o['Carbon footprint {} (MtCO2)'.format(i)] = (temp * surface *\n                                                                   inputs['carbon_footprint_renovation'][\n                                                                       i]).sum() / 10 ** 9\n            output['Replacement insulation (Thousand)'] = sum(\n                [o['Replacement {} (Thousand households)'.format(i)] for i in\n                 ['Wall', 'Floor', 'Roof', 'Windows']])\n\n            o = Series(o).sort_index(ascending=False)\n            output.update(o.T)\n\n            output['Embodied energy renovation (TWh PE)'] = output['Embodied energy Wall (TWh PE)'] + output[\n                'Embodied energy Floor (TWh PE)'] + output['Embodied energy Roof (TWh PE)'] + output[\n                                                                'Embodied energy Windows (TWh PE)']\n\n            output['Embodied energy construction (TWh PE)'] = inputs['Embodied energy construction (TWh PE)'].loc[\n                self.year]\n            output['Embodied energy (TWh PE)'] = output['Embodied energy renovation (TWh PE)'] + output[\n                'Embodied energy construction (TWh PE)']\n\n            output['Carbon footprint renovation (MtCO2)'] = output['Carbon footprint Wall (MtCO2)'] + output[\n                'Carbon footprint Floor (MtCO2)'] + output['Carbon footprint Roof (MtCO2)'] + output[\n                                                                'Carbon footprint Windows (MtCO2)']\n\n            output['Carbon footprint construction (MtCO2)'] = inputs['Carbon footprint construction (MtCO2)'].loc[\n                self.year]\n            output['Carbon footprint (MtCO2)'] = output['Carbon footprint renovation (MtCO2)'] + output[\n                'Carbon footprint construction (MtCO2)']\n\n            temp = self.investment_heater.sum()\n            output['Investment heater (Billion euro)'] = temp.sum() / 10 ** 9\n            temp.index = temp.index.map(lambda x: 'Investment {} (Billion euro)'.format(x))\n            output.update(temp.T / 10 ** 9)\n            investment_heater = self.investment_heater.sum(axis=1)\n\n            # representative insulation investment: weighted average with number of insulation actions as weights\n            if False:\n                investment_insulation_repr = DataFrame(self.investment_insulation_repr_yrs)\n                gest = DataFrame({year: item.sum(axis=1) for year, item in replacement_insulation.items()})\n                gest = reindex_mi(gest, investment_insulation_repr.index)\n                temp = gest * investment_insulation_repr\n\n                t = temp.groupby('Income owner').sum() / gest.groupby('Income owner').sum()\n                t.index = t.index.map(lambda x: 'Investment per insulation action {} (euro)'.format(x))\n                output.update(t.T)\n\n                t = temp.groupby(['Housing type', 'Occupancy status']).sum() / gest.groupby(['Housing type',\n                                                                                             'Occupancy status']).sum()\n                t.index = t.index.map(lambda x: 'Investment per insulation action {} - {} (euro)'.format(x[0], x[1]))\n                output.update(t.T)\n\n            investment_insulation = self.investment_insulation.sum(axis=1)\n            output['Investment insulation (Billion euro)'] = investment_insulation.sum() / 10 ** 9\n\n            index = investment_heater.index.union(investment_insulation.index)\n            investment_total = investment_heater.reindex(index, fill_value=0) + investment_insulation.reindex(index,\n                                                                                                              fill_value=0)\n            output['Investment total (Billion euro)'] = investment_total.sum() / 10 ** 9\n            temp = investment_total.groupby('Income owner').sum()\n            temp.index = temp.index.map(lambda x: 'Investment total {} (Billion euro)'.format(x))\n            output.update(temp.T / 10 ** 9)\n            temp = investment_total.groupby(['Housing type', 'Occupancy status']).sum()\n            temp.index = temp.index.map(lambda x: 'Investment total {} - {} (Billion euro)'.format(x[0], x[1]))\n            output.update(temp.T / 10 ** 9)\n\n            subsidies_heater = self.subsidies_heater.sum(axis=1)\n            output['Subsidies heater (Billion euro)'] = subsidies_heater.sum() / 10 ** 9\n\n            subsidies_insulation = self.subsidies_insulation.sum(axis=1)\n            output['Subsidies insulation (Billion euro)'] = subsidies_insulation.sum() / 10 ** 9\n\n            index = subsidies_heater.index.union(subsidies_insulation.index)\n            subsidies_total = subsidies_heater.reindex(index, fill_value=0) + subsidies_insulation.reindex(index,\n                                                                                                           fill_value=0)\n            output['Subsidies total (Billion euro)'] = subsidies_total.sum() / 10 ** 9\n            temp = subsidies_total.groupby('Income owner').sum()\n            temp.index = temp.index.map(lambda x: 'Subsidies total {} (Million euro)'.format(x))\n            output.update(temp.T / 10 ** 6)\n            temp = subsidies_total.groupby(['Housing type', 'Occupancy status']).sum()\n            temp.index = temp.index.map(lambda x: 'Subsidies total {} - {} (Million euro)'.format(x[0], x[1]))\n            output.update(temp.T / 10 ** 6)\n\n            subsidies, subsidies_count, sub_count = None, None, None\n            for gest, subsidies_details in {'heater': self.subsidies_details_heater,\n                                            'insulation': self.subsidies_details_insulation}.items():\n                if gest == 'heater':\n                    sub_count = Series(self.subsidies_count_heater)\n                elif gest == 'insulation':\n                    sub_count = Series(self.subsidies_count_insulation)\n\n                subsidies_details = Series({k: i.sum().sum() for k, i in subsidies_details.items()}, dtype='float64')\n\n                for i in subsidies_details.index:\n                    output['{} {} (Thousand)'.format(i.capitalize().replace('_', ' '), gest)] = sub_count[i] / 10**3\n                    output['{} {} (Billion euro)'.format(i.capitalize().replace('_', ' '), gest)] = \\\n                    subsidies_details.loc[i] / 10 ** 9\n                if subsidies is None:\n                    subsidies = subsidies_details.copy()\n                    subsidies_count = sub_count.copy()\n                else:\n                    subsidies = concat((subsidies, subsidies_details), axis=0)\n                    subsidies_count = concat((subsidies_count, sub_count))\n\n                subsidies = subsidies.groupby(subsidies.index).sum()\n                subsidies_count = subsidies_count.groupby(subsidies_count.index).sum()\n                for i in subsidies.index:\n                    output['{} (Thousand)'.format(i.capitalize().replace('_', ' '))] = subsidies_count.loc[i] / 10 ** 3\n                    output['{} (Billion euro)'.format(i.capitalize().replace('_', ' '))] = subsidies.loc[i] / 10 ** 9\n            # output['Zero interest loan headcount'] = self.zil_count\n            # output['Zero interest loan average amount'] = self.zil_loaned_avg\n            taxes_expenditures = self.taxes_expenditure_details\n            taxes_expenditures = DataFrame(taxes_expenditures).sum()\n            taxes_expenditures.index = taxes_expenditures.index.map(\n                lambda x: '{} (Billion euro)'.format(x.capitalize().replace('_', ' ').replace('Cee', 'Cee tax')))\n            output.update((taxes_expenditures / 10 ** 9).T)\n            output['Taxes expenditure (Billion euro)'] = taxes_expenditures.sum() / 10 ** 9\n\n            energy_expenditure = self.energy_expenditure\n            output['Energy expenditures (Billion euro)'] = energy_expenditure.sum() / 10 ** 9\n            temp = energy_expenditure.groupby('Income tenant').sum()\n            temp.index = temp.index.map(lambda x: 'Energy expenditures {} (Billion euro)'.format(x))\n            output.update(temp.T / 10 ** 9)\n\n            output['VTA heater (Billion euro)'] = self.tax_heater.sum().sum() / 10 ** 9\n\n            output['VTA insulation (Billion euro)'] = self.taxed_insulation.sum().sum() / 10 ** 9\n            output['VTA (Billion euro)'] = output['VTA heater (Billion euro)'] + output['VTA insulation (Billion euro)']\n\n            output['Investment total HT (Billion euro)'] = output['Investment total (Billion euro)'] - output[\n                'VTA (Billion euro)']\n\n            output['Carbon value (Billion euro)'] = (self.heat_consumption_energy * inputs['carbon_value_kwh'].loc[\n                                                                                         self.year,\n                                                                                         :]).sum() / 10 ** 9\n\n            output['Health cost (Billion euro)'], o = self.health_cost(inputs)\n            output.update(o)\n\n            output['Income state (Billion euro)'] = output['VTA (Billion euro)'] + output[\n                'Taxes expenditure (Billion euro)']\n            output['Expenditure state (Billion euro)'] = output['Subsidies heater (Billion euro)'] + output[\n                'Subsidies insulation (Billion euro)']\n            output['Balance state (Billion euro)'] = output['Income state (Billion euro)'] - output[\n                'Expenditure state (Billion euro)']\n\n            levels = ['Occupancy status', 'Income owner', 'Housing type']\n            for level in levels:\n                temp = subsidies_total.groupby(level).sum() / investment_total.groupby(level).sum()\n                temp.index = temp.index.map(lambda x: 'Share subsidies {} (%)'.format(x))\n                output.update(temp.T)\n\n            output['Investment total HT / households (Thousand euro)'] = output['Investment total HT (Billion euro)'] * 10**6 / (output['Retrofit (Thousand households)'] * 10**3)\n            output['Investment total / households (Thousand euro)'] = output['Investment total (Billion euro)'] * 10**6 / (output['Retrofit (Thousand households)'] * 10**3)\n            output['Investment insulation / households (Thousand euro)'] = output['Investment insulation (Billion euro)'] * 10**6 / (output['Renovation (Thousand households)'] * 10**3)\n\n        output = Series(output).rename(self.year)\n        stock = stock.rename(self.year)\n        return stock, output\n\n    @staticmethod\n    def find_best_option(criteria, dict_df, func='max'):\n        \"\"\"Find best option (columns), and returns\n\n        Parameters\n        ----------\n        criteria: DataFrame\n            Find for each index the column based on criteria values.\n        dict_df: dict\n            Dataframe to return.\n        func\n\n        Returns\n        -------\n        DataFrame\n        \"\"\"\n        dict_ds = {key: Series(dtype=float) for key in dict_df.keys()}\n        dict_ds.update({'criteria': Series(dtype=float)})\n\n        columns = None\n        if func == 'max':\n            columns = criteria.idxmax(axis=1)\n        elif func == 'min':\n            columns = criteria.idxmin(axis=1)\n\n        for c in columns.unique():\n            idx = columns.index[columns == c]\n            for key in dict_df.keys():\n                dict_ds[key] = concat((dict_ds[key], dict_df[key].loc[idx, c]), axis=0)\n            dict_ds['criteria'] = concat((dict_ds['criteria'], criteria.loc[idx, c]), axis=0)\n        for key in dict_df.keys():\n            dict_ds[key].index = MultiIndex.from_tuples(dict_ds[key].index).set_names(\n                dict_df[key].index.names)\n        dict_ds['criteria'].index = MultiIndex.from_tuples(dict_ds['criteria'].index).set_names(criteria.index.names)\n        dict_ds['columns'] = columns\n\n        return concat(dict_ds, axis=1)\n\n    def mitigation_potential(self, prices, cost_insulation_raw, carbon_emission=None, carbon_value=None, health_cost=None,\n                             index=None):\n        \"\"\"Function returns bill saved and cost for buildings stock retrofit.\n\n        Not implemented yet but should be able to calculate private and social indicator.\n        Make cost abatement cost graphs, payback period graphs.\n\n        Parameters\n        ----------\n        index\n        prices\n        cost_insulation_raw\n        carbon_emission\n        carbon_value\n        health_cost\n\n        Returns\n        -------\n\n        \"\"\"\n\n        output = dict()\n\n        if index is None:\n            index = self.stock.index\n\n        consumption_before = self.consumption_standard(index)[0]\n        consumption_after, _, certificate_after = self.prepare_consumption(self._choice_insulation, index=index)\n        consumption_saved = (consumption_before - consumption_after.T).T\n\n        self._efficiency.index.names = ['Heating system']\n        efficiency = reindex_mi(self._efficiency, consumption_before.index)\n        need_before = consumption_before * efficiency\n\n        consumption_before = reindex_mi(consumption_before, index)\n        need_before = reindex_mi(need_before, index)\n        consumption_after = reindex_mi(consumption_after, index)\n        consumption_saved = reindex_mi(consumption_saved, index)\n        efficiency = reindex_mi(self._efficiency, consumption_saved.index)\n        need_saved = (consumption_saved.T * efficiency).T\n\n        consumption_actual_before = self.consumption_actual(prices.loc[self.year, :], consumption_before)\n        consumption_actual_after = self.consumption_actual(prices.loc[self.year, :], consumption_after)\n        consumption_actual_saved = (consumption_actual_before - consumption_actual_after.T).T\n\n        consumption_before = reindex_mi(self._surface, index) * consumption_before\n        consumption_after = (reindex_mi(self._surface, index) * consumption_after.T).T\n        consumption_saved = (reindex_mi(self._surface, index) * consumption_saved.T).T\n\n        need_before = reindex_mi(self._surface, index) * need_before\n        need_saved = (reindex_mi(self._surface, index) * need_saved.T).T\n\n        consumption_actual_before = (reindex_mi(self._surface, index) * consumption_actual_before.T).T\n        consumption_actual_after = (reindex_mi(self._surface, index) * consumption_actual_after.T).T\n        consumption_actual_saved = (reindex_mi(self._surface, index) * consumption_actual_saved.T).T\n\n        output.update({'Stock (dwellings/segment)': self.stock,\n                       'Surface (m2/segment)': self.stock * reindex_mi(self._surface, index),\n                       'Consumption before (kWh/dwelling)': consumption_before,\n                       'Consumption before (kWh/segment)': consumption_before * self.stock,\n                       'Need before (kWh/segment)': need_before * self.stock,\n                       'Consumption actual before (kWh/dwelling)': consumption_actual_before,\n                       'Consumption actual before (kWh/segment)': consumption_actual_before * self.stock,\n                       'Consumption actual after (kWh/dwelling)': consumption_actual_after,\n                       'Consumption actual after (kWh/segment)': (consumption_actual_after.T * self.stock).T,\n                       'Consumption saved (kWh/dwelling)': consumption_saved,\n                       'Consumption saved (kWh/segment)': (consumption_saved.T * self.stock).T,\n                       'Need saved (kWh/segment)': (need_saved.T * self.stock).T,\n                       'Consumption actual saved (kWh/dwelling)': consumption_actual_saved,\n                       'Consumption actual saved (kWh/segment)': (consumption_actual_saved.T * self.stock).T\n                       })\n\n        consumption_saved_agg = (self.stock * consumption_saved.T).T\n        consumption_actual_saved_agg = (self.stock * consumption_actual_saved.T).T\n\n        if carbon_emission is not None:\n            c = self.add_energy(consumption_actual_before)\n            emission_before = reindex_mi(carbon_emission.T.rename_axis('Energy', axis=0), c.index).loc[:,\n                              self.year] * c\n\n            c = self.add_energy(consumption_actual_after)\n            emission_after = (reindex_mi(carbon_emission.T.rename_axis('Energy', axis=0), c.index).loc[:,\n                              self.year] * c.T).T\n\n            emission_saved = - emission_after.sub(emission_before, axis=0).dropna()\n\n            output.update({'Emission before (gCO2/dwelling)': emission_before,\n                           'Emission after (gCO2/dwelling)': emission_after,\n                           'Emission saved (gCO2/dwelling)': emission_saved,\n                           })\n\n            if carbon_value is not None:\n                c = self.add_energy(consumption_actual_before)\n                emission_value_before = reindex_mi(carbon_value.T.rename_axis('Energy', axis=0), c.index).loc[:,\n                                        self.year] * c\n\n                c = self.add_energy(consumption_actual_after)\n                emission_value_after = (reindex_mi(carbon_value.T.rename_axis('Energy', axis=0), c.index).loc[:,\n                                        self.year] * c.T).T\n\n                emission_value_saved = - emission_value_after.sub(emission_value_before, axis=0).dropna()\n\n                output.update({'Emission value before (euro/dwelling)': emission_value_before,\n                               'Emission value after (euro/dwelling)': emission_value_after,\n                               'Emission value saved (euro/dwelling)': emission_value_saved\n                               })\n\n        cost_insulation = self.prepare_cost_insulation(cost_insulation_raw * self.surface_insulation)\n        cost_insulation = reindex_mi(cost_insulation, index)\n        potential_cost_insulation = (reindex_mi(self._surface, index) * cost_insulation.T).T\n\n        output.update({'Cost insulation (euro/dwelling)': potential_cost_insulation,\n                       'Cost insulation (euro/segment)': (potential_cost_insulation.T * self.stock).T\n                       })\n\n        index = self.stock.index\n        energy = pd.Series(index.get_level_values('Heating system'), index=index).str.split('-').str[0].rename('Energy')\n        energy_prices = prices.loc[self.year, :].reindex(energy).set_axis(index)\n\n        bill_before = consumption_before * energy_prices\n        bill_after = (consumption_after.T * energy_prices).T\n        bill_saved = - bill_after.sub(bill_before, axis=0).dropna()\n\n        output.update({'Bill before (euro/dwelling)': bill_before,\n                       'Bill after (euro/dwelling)': bill_after,\n                       'Bill saved (euro/dwelling)': bill_saved\n                       })\n\n        discount_rate, lifetime = 0.05, 30\n        discount_factor = (1 - (1 + discount_rate) ** -lifetime) / discount_rate\n        npv = bill_saved * discount_factor - potential_cost_insulation\n\n        out = AgentBuildings.find_best_option(npv, {'bill_saved': bill_saved,\n                                                    'cost': potential_cost_insulation,\n                                                    'consumption_saved': consumption_saved,\n                                                    'consumption_saved_agg': consumption_saved_agg,\n                                                    'consumption_actual_saved_agg': consumption_actual_saved_agg\n                                                    })\n        output.update({'Best NPV': out})\n\n        out = AgentBuildings.find_best_option(consumption_saved_agg, {'bill_saved': bill_saved,\n                                                                      'cost': potential_cost_insulation,\n                                                                      'consumption_saved': consumption_saved,\n                                                                      'consumption_saved_agg': consumption_saved_agg,\n                                                                      'consumption_actual_saved_agg': consumption_actual_saved_agg})\n\n        output.update({'Max consumption saved': out})\n        return output\n\n    def calibration_exogenous(self, energy_prices, taxes, path_heater=None, path_insulation_int=None,\n                              path_insulation_ext=None, scale=1.19651508552344):\n        \"\"\"Function calibrating buildings object with exogenous data.\n\n        Parameters\n        ----------\n        energy_prices: Series\n            Energy prices for year y. Index are energy carriers {'Electricity', 'Natural gas', 'Oil fuel', 'Wood fuel'}.\n        taxes: Series\n            Energy taxes for year y.\n        \"\"\"\n        # calibration energy consumption first year\n        self.calculate_consumption(energy_prices.loc[self.first_year, :], taxes)\n\n        # calibration flow retrofit second year\n        self.year = 2019\n\n        if path_heater is not None:\n            calibration_constant_heater = read_csv(path_heater, index_col=[0, 1, 2]).squeeze()\n        else:\n            calibration_constant_heater = get_pandas('project/input/calibration/calibration_constant_heater.csv',\n                                                     lambda x: pd.read_csv(x, index_col=[0, 1, 2]).squeeze())\n        self.constant_heater = calibration_constant_heater.unstack('Heating system final')\n        self._choice_heater = list(self.constant_heater.columns)\n\n        if path_insulation_int is not None:\n            calibration_constant_insulation = read_csv(path_insulation_int, index_col=[0, 1, 2, 3]).squeeze()\n        else:\n            calibration_constant_insulation = get_pandas('project/input/calibration/calibration_constant_insulation.csv',\n                                                         lambda x: pd.read_csv(x, index_col=[0, 1, 2, 3]).squeeze())\n        self.constant_insulation_intensive = calibration_constant_insulation\n\n        if path_insulation_ext is not None:\n            calibration_constant_extensive = read_csv(path_insulation_ext, index_col=[0, 1, 2, 3]).squeeze()\n        else:\n            calibration_constant_extensive = get_pandas('project/input/calibration/calibration_constant_extensive.csv',\n                                                         lambda x: pd.read_csv(x, index_col=[0, 1, 2, 3]).squeeze())\n        self.constant_insulation_extensive = calibration_constant_extensive.dropna()\n\n        self.scale_ext = scale\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/project/building.py b/project/building.py
--- a/project/building.py	
+++ b/project/building.py	
@@ -2011,9 +2011,7 @@
 
             constant = retrofit_rate_ini.copy()
             constant[retrofit_rate_ini > 0] = 0
-            """a = stock_segment.groupby(retrofit_rate_ini.index.names).mean()
-            b = util.groupby(retrofit_rate_ini.index.names).mean()
-            pd.concat((retrofit_rate_ini, a, b), axis=1)"""
+
             if self._calib_scale:
                 x = append(constant.to_numpy(), 1)
                 """root, infodict, ier, mess = fsolve(solve, x, args=(
